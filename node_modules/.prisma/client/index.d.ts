
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectUser
 * 
 */
export type ProjectUser = $Result.DefaultSelection<Prisma.$ProjectUserPayload>
/**
 * Model ProjectAccount
 * 
 */
export type ProjectAccount = $Result.DefaultSelection<Prisma.$ProjectAccountPayload>
/**
 * Model Board
 * 
 */
export type Board = $Result.DefaultSelection<Prisma.$BoardPayload>
/**
 * Model Column
 * 
 */
export type Column = $Result.DefaultSelection<Prisma.$ColumnPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskAccount
 * 
 */
export type TaskAccount = $Result.DefaultSelection<Prisma.$TaskAccountPayload>
/**
 * Model TaskAssignee
 * 
 */
export type TaskAssignee = $Result.DefaultSelection<Prisma.$TaskAssigneePayload>
/**
 * Model TaskComment
 * 
 */
export type TaskComment = $Result.DefaultSelection<Prisma.$TaskCommentPayload>
/**
 * Model TaskAttachment
 * 
 */
export type TaskAttachment = $Result.DefaultSelection<Prisma.$TaskAttachmentPayload>
/**
 * Model TaskLabel
 * 
 */
export type TaskLabel = $Result.DefaultSelection<Prisma.$TaskLabelPayload>
/**
 * Model Label
 * 
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Verify
 * 
 */
export type Verify = $Result.DefaultSelection<Prisma.$VerifyPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model ProjectClaim
 * 
 */
export type ProjectClaim = $Result.DefaultSelection<Prisma.$ProjectClaimPayload>
/**
 * Model Envelop
 * 
 */
export type Envelop = $Result.DefaultSelection<Prisma.$EnvelopPayload>
/**
 * Model ClaimList
 * 
 */
export type ClaimList = $Result.DefaultSelection<Prisma.$ClaimListPayload>
/**
 * Model Source
 * 
 */
export type Source = $Result.DefaultSelection<Prisma.$SourcePayload>
/**
 * Model Questionnaire
 * 
 */
export type Questionnaire = $Result.DefaultSelection<Prisma.$QuestionnairePayload>
/**
 * Model QuestionAnswer
 * 
 */
export type QuestionAnswer = $Result.DefaultSelection<Prisma.$QuestionAnswerPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Choice
 * 
 */
export type Choice = $Result.DefaultSelection<Prisma.$ChoicePayload>
/**
 * Model Defendant
 * 
 */
export type Defendant = $Result.DefaultSelection<Prisma.$DefendantPayload>
/**
 * Model DefendantDetails
 * 
 */
export type DefendantDetails = $Result.DefaultSelection<Prisma.$DefendantDetailsPayload>
/**
 * Model TreatmentAndInjury
 * 
 */
export type TreatmentAndInjury = $Result.DefaultSelection<Prisma.$TreatmentAndInjuryPayload>
/**
 * Model Treatment
 * 
 */
export type Treatment = $Result.DefaultSelection<Prisma.$TreatmentPayload>
/**
 * Model Injury
 * 
 */
export type Injury = $Result.DefaultSelection<Prisma.$InjuryPayload>
/**
 * Model AccidentMedia
 * 
 */
export type AccidentMedia = $Result.DefaultSelection<Prisma.$AccidentMediaPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model Witness
 * 
 */
export type Witness = $Result.DefaultSelection<Prisma.$WitnessPayload>
/**
 * Model WitnessDetails
 * 
 */
export type WitnessDetails = $Result.DefaultSelection<Prisma.$WitnessDetailsPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RoleType
 * 
 */
export type RoleType = $Result.DefaultSelection<Prisma.$RoleTypePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model SubAccount
 * 
 */
export type SubAccount = $Result.DefaultSelection<Prisma.$SubAccountPayload>
/**
 * Model Car
 * 
 */
export type Car = $Result.DefaultSelection<Prisma.$CarPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TaskPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const WereYouInjured: {
  Yes: 'Yes',
  Someone: 'Someone',
  No: 'No'
};

export type WereYouInjured = (typeof WereYouInjured)[keyof typeof WereYouInjured]


export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ClaimStatus: {
  PENDING_INFORMATION: 'PENDING_INFORMATION',
  UNDER_REVIEW: 'UNDER_REVIEW',
  PENDING_DOCUMENTS: 'PENDING_DOCUMENTS',
  INVESTIGATION: 'INVESTIGATION',
  PRE_SUIT: 'PRE_SUIT',
  PRE_LITIGATION: 'PRE_LITIGATION',
  LITIGATION: 'LITIGATION',
  RESOLVED_AND_CLOSED: 'RESOLVED_AND_CLOSED'
};

export type ClaimStatus = (typeof ClaimStatus)[keyof typeof ClaimStatus]


export const Relationship: {
  Self: 'Self',
  Parent: 'Parent',
  Child: 'Child',
  Sibiling: 'Sibiling',
  Friend: 'Friend',
  Representative: 'Representative',
  Other: 'Other'
};

export type Relationship = (typeof Relationship)[keyof typeof Relationship]


export const QuestionType: {
  TEXTFIELD: 'TEXTFIELD',
  DATE: 'DATE',
  SELECTMENU: 'SELECTMENU',
  YESNO: 'YESNO'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const DefendantRole: {
  Operator: 'Operator',
  Owner: 'Owner',
  Operator_Owner: 'Operator_Owner',
  MTA: 'MTA',
  AVIATION: 'AVIATION',
  EMPLOYER: 'EMPLOYER',
  SUPERVISOR: 'SUPERVISOR',
  PROPERTY_OWNER: 'PROPERTY_OWNER',
  TRAIN: 'TRAIN',
  Other: 'Other'
};

export type DefendantRole = (typeof DefendantRole)[keyof typeof DefendantRole]


export const CollisionType: {
  HEAD_ON: 'HEAD_ON',
  REAR_END: 'REAR_END',
  SIDE_IMPACT: 'SIDE_IMPACT',
  SIDESWIPE: 'SIDESWIPE'
};

export type CollisionType = (typeof CollisionType)[keyof typeof CollisionType]


export const InjuryPoint: {
  Shoulder: 'Shoulder',
  Elbow: 'Elbow',
  Leg: 'Leg',
  Knee: 'Knee',
  Hip_Pelvic: 'Hip_Pelvic',
  Arm: 'Arm',
  Wrist: 'Wrist',
  Thigh: 'Thigh',
  Ankle: 'Ankle',
  Finger: 'Finger',
  Toe: 'Toe',
  Hand: 'Hand',
  Foot: 'Foot',
  Other: 'Other'
};

export type InjuryPoint = (typeof InjuryPoint)[keyof typeof InjuryPoint]


export const InjuryType: {
  Laceration: 'Laceration',
  Contusion_Bruises: 'Contusion_Bruises',
  Broken: 'Broken',
  Fracture: 'Fracture',
  Tear: 'Tear',
  Sprain: 'Sprain',
  Other: 'Other'
};

export type InjuryType = (typeof InjuryType)[keyof typeof InjuryType]


export const InjurySide: {
  Left: 'Left',
  Right: 'Right',
  Both: 'Both'
};

export type InjurySide = (typeof InjurySide)[keyof typeof InjurySide]


export const BusOrVehicle: {
  Passenger: 'Passenger',
  Other_Vehicle: 'Other_Vehicle'
};

export type BusOrVehicle = (typeof BusOrVehicle)[keyof typeof BusOrVehicle]


export const TransportType: {
  Bus: 'Bus',
  Train: 'Train'
};

export type TransportType = (typeof TransportType)[keyof typeof TransportType]


export const PropertyType: {
  Business: 'Business',
  Private_Property: 'Private_Property'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]

}

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type WereYouInjured = $Enums.WereYouInjured

export const WereYouInjured: typeof $Enums.WereYouInjured

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ClaimStatus = $Enums.ClaimStatus

export const ClaimStatus: typeof $Enums.ClaimStatus

export type Relationship = $Enums.Relationship

export const Relationship: typeof $Enums.Relationship

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type DefendantRole = $Enums.DefendantRole

export const DefendantRole: typeof $Enums.DefendantRole

export type CollisionType = $Enums.CollisionType

export const CollisionType: typeof $Enums.CollisionType

export type InjuryPoint = $Enums.InjuryPoint

export const InjuryPoint: typeof $Enums.InjuryPoint

export type InjuryType = $Enums.InjuryType

export const InjuryType: typeof $Enums.InjuryType

export type InjurySide = $Enums.InjurySide

export const InjurySide: typeof $Enums.InjurySide

export type BusOrVehicle = $Enums.BusOrVehicle

export const BusOrVehicle: typeof $Enums.BusOrVehicle

export type TransportType = $Enums.TransportType

export const TransportType: typeof $Enums.TransportType

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Projects
 * const projects = await prisma.project.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Projects
   * const projects = await prisma.project.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectUser`: Exposes CRUD operations for the **ProjectUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectUsers
    * const projectUsers = await prisma.projectUser.findMany()
    * ```
    */
  get projectUser(): Prisma.ProjectUserDelegate<ExtArgs>;

  /**
   * `prisma.projectAccount`: Exposes CRUD operations for the **ProjectAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectAccounts
    * const projectAccounts = await prisma.projectAccount.findMany()
    * ```
    */
  get projectAccount(): Prisma.ProjectAccountDelegate<ExtArgs>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<ExtArgs>;

  /**
   * `prisma.column`: Exposes CRUD operations for the **Column** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Columns
    * const columns = await prisma.column.findMany()
    * ```
    */
  get column(): Prisma.ColumnDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.taskAccount`: Exposes CRUD operations for the **TaskAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAccounts
    * const taskAccounts = await prisma.taskAccount.findMany()
    * ```
    */
  get taskAccount(): Prisma.TaskAccountDelegate<ExtArgs>;

  /**
   * `prisma.taskAssignee`: Exposes CRUD operations for the **TaskAssignee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignees
    * const taskAssignees = await prisma.taskAssignee.findMany()
    * ```
    */
  get taskAssignee(): Prisma.TaskAssigneeDelegate<ExtArgs>;

  /**
   * `prisma.taskComment`: Exposes CRUD operations for the **TaskComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskComments
    * const taskComments = await prisma.taskComment.findMany()
    * ```
    */
  get taskComment(): Prisma.TaskCommentDelegate<ExtArgs>;

  /**
   * `prisma.taskAttachment`: Exposes CRUD operations for the **TaskAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAttachments
    * const taskAttachments = await prisma.taskAttachment.findMany()
    * ```
    */
  get taskAttachment(): Prisma.TaskAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.taskLabel`: Exposes CRUD operations for the **TaskLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskLabels
    * const taskLabels = await prisma.taskLabel.findMany()
    * ```
    */
  get taskLabel(): Prisma.TaskLabelDelegate<ExtArgs>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.verify`: Exposes CRUD operations for the **Verify** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifies
    * const verifies = await prisma.verify.findMany()
    * ```
    */
  get verify(): Prisma.VerifyDelegate<ExtArgs>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs>;

  /**
   * `prisma.projectClaim`: Exposes CRUD operations for the **ProjectClaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectClaims
    * const projectClaims = await prisma.projectClaim.findMany()
    * ```
    */
  get projectClaim(): Prisma.ProjectClaimDelegate<ExtArgs>;

  /**
   * `prisma.envelop`: Exposes CRUD operations for the **Envelop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Envelops
    * const envelops = await prisma.envelop.findMany()
    * ```
    */
  get envelop(): Prisma.EnvelopDelegate<ExtArgs>;

  /**
   * `prisma.claimList`: Exposes CRUD operations for the **ClaimList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClaimLists
    * const claimLists = await prisma.claimList.findMany()
    * ```
    */
  get claimList(): Prisma.ClaimListDelegate<ExtArgs>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.SourceDelegate<ExtArgs>;

  /**
   * `prisma.questionnaire`: Exposes CRUD operations for the **Questionnaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questionnaires
    * const questionnaires = await prisma.questionnaire.findMany()
    * ```
    */
  get questionnaire(): Prisma.QuestionnaireDelegate<ExtArgs>;

  /**
   * `prisma.questionAnswer`: Exposes CRUD operations for the **QuestionAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionAnswers
    * const questionAnswers = await prisma.questionAnswer.findMany()
    * ```
    */
  get questionAnswer(): Prisma.QuestionAnswerDelegate<ExtArgs>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs>;

  /**
   * `prisma.choice`: Exposes CRUD operations for the **Choice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Choices
    * const choices = await prisma.choice.findMany()
    * ```
    */
  get choice(): Prisma.ChoiceDelegate<ExtArgs>;

  /**
   * `prisma.defendant`: Exposes CRUD operations for the **Defendant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defendants
    * const defendants = await prisma.defendant.findMany()
    * ```
    */
  get defendant(): Prisma.DefendantDelegate<ExtArgs>;

  /**
   * `prisma.defendantDetails`: Exposes CRUD operations for the **DefendantDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefendantDetails
    * const defendantDetails = await prisma.defendantDetails.findMany()
    * ```
    */
  get defendantDetails(): Prisma.DefendantDetailsDelegate<ExtArgs>;

  /**
   * `prisma.treatmentAndInjury`: Exposes CRUD operations for the **TreatmentAndInjury** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TreatmentAndInjuries
    * const treatmentAndInjuries = await prisma.treatmentAndInjury.findMany()
    * ```
    */
  get treatmentAndInjury(): Prisma.TreatmentAndInjuryDelegate<ExtArgs>;

  /**
   * `prisma.treatment`: Exposes CRUD operations for the **Treatment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treatments
    * const treatments = await prisma.treatment.findMany()
    * ```
    */
  get treatment(): Prisma.TreatmentDelegate<ExtArgs>;

  /**
   * `prisma.injury`: Exposes CRUD operations for the **Injury** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Injuries
    * const injuries = await prisma.injury.findMany()
    * ```
    */
  get injury(): Prisma.InjuryDelegate<ExtArgs>;

  /**
   * `prisma.accidentMedia`: Exposes CRUD operations for the **AccidentMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccidentMedias
    * const accidentMedias = await prisma.accidentMedia.findMany()
    * ```
    */
  get accidentMedia(): Prisma.AccidentMediaDelegate<ExtArgs>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs>;

  /**
   * `prisma.witness`: Exposes CRUD operations for the **Witness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Witnesses
    * const witnesses = await prisma.witness.findMany()
    * ```
    */
  get witness(): Prisma.WitnessDelegate<ExtArgs>;

  /**
   * `prisma.witnessDetails`: Exposes CRUD operations for the **WitnessDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WitnessDetails
    * const witnessDetails = await prisma.witnessDetails.findMany()
    * ```
    */
  get witnessDetails(): Prisma.WitnessDetailsDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.roleType`: Exposes CRUD operations for the **RoleType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTypes
    * const roleTypes = await prisma.roleType.findMany()
    * ```
    */
  get roleType(): Prisma.RoleTypeDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.subAccount`: Exposes CRUD operations for the **SubAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccounts
    * const subAccounts = await prisma.subAccount.findMany()
    * ```
    */
  get subAccount(): Prisma.SubAccountDelegate<ExtArgs>;

  /**
   * `prisma.car`: Exposes CRUD operations for the **Car** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cars
    * const cars = await prisma.car.findMany()
    * ```
    */
  get car(): Prisma.CarDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Project: 'Project',
    ProjectUser: 'ProjectUser',
    ProjectAccount: 'ProjectAccount',
    Board: 'Board',
    Column: 'Column',
    Task: 'Task',
    TaskAccount: 'TaskAccount',
    TaskAssignee: 'TaskAssignee',
    TaskComment: 'TaskComment',
    TaskAttachment: 'TaskAttachment',
    TaskLabel: 'TaskLabel',
    Label: 'Label',
    User: 'User',
    Verify: 'Verify',
    Claim: 'Claim',
    ProjectClaim: 'ProjectClaim',
    Envelop: 'Envelop',
    ClaimList: 'ClaimList',
    Source: 'Source',
    Questionnaire: 'Questionnaire',
    QuestionAnswer: 'QuestionAnswer',
    Question: 'Question',
    Choice: 'Choice',
    Defendant: 'Defendant',
    DefendantDetails: 'DefendantDetails',
    TreatmentAndInjury: 'TreatmentAndInjury',
    Treatment: 'Treatment',
    Injury: 'Injury',
    AccidentMedia: 'AccidentMedia',
    Incident: 'Incident',
    Witness: 'Witness',
    WitnessDetails: 'WitnessDetails',
    Role: 'Role',
    RoleType: 'RoleType',
    Account: 'Account',
    SubAccount: 'SubAccount',
    Car: 'Car'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "project" | "projectUser" | "projectAccount" | "board" | "column" | "task" | "taskAccount" | "taskAssignee" | "taskComment" | "taskAttachment" | "taskLabel" | "label" | "user" | "verify" | "claim" | "projectClaim" | "envelop" | "claimList" | "source" | "questionnaire" | "questionAnswer" | "question" | "choice" | "defendant" | "defendantDetails" | "treatmentAndInjury" | "treatment" | "injury" | "accidentMedia" | "incident" | "witness" | "witnessDetails" | "role" | "roleType" | "account" | "subAccount" | "car"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectUser: {
        payload: Prisma.$ProjectUserPayload<ExtArgs>
        fields: Prisma.ProjectUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          findFirst: {
            args: Prisma.ProjectUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          findMany: {
            args: Prisma.ProjectUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>[]
          }
          create: {
            args: Prisma.ProjectUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          createMany: {
            args: Prisma.ProjectUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>[]
          }
          delete: {
            args: Prisma.ProjectUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          update: {
            args: Prisma.ProjectUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          deleteMany: {
            args: Prisma.ProjectUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          aggregate: {
            args: Prisma.ProjectUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectUser>
          }
          groupBy: {
            args: Prisma.ProjectUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectUserCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectUserCountAggregateOutputType> | number
          }
        }
      }
      ProjectAccount: {
        payload: Prisma.$ProjectAccountPayload<ExtArgs>
        fields: Prisma.ProjectAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>
          }
          findFirst: {
            args: Prisma.ProjectAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>
          }
          findMany: {
            args: Prisma.ProjectAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>[]
          }
          create: {
            args: Prisma.ProjectAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>
          }
          createMany: {
            args: Prisma.ProjectAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>[]
          }
          delete: {
            args: Prisma.ProjectAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>
          }
          update: {
            args: Prisma.ProjectAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>
          }
          deleteMany: {
            args: Prisma.ProjectAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectAccountPayload>
          }
          aggregate: {
            args: Prisma.ProjectAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectAccount>
          }
          groupBy: {
            args: Prisma.ProjectAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectAccountCountAggregateOutputType> | number
          }
        }
      }
      Board: {
        payload: Prisma.$BoardPayload<ExtArgs>
        fields: Prisma.BoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoard>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
          }
        }
      }
      Column: {
        payload: Prisma.$ColumnPayload<ExtArgs>
        fields: Prisma.ColumnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColumnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColumnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          findFirst: {
            args: Prisma.ColumnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColumnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          findMany: {
            args: Prisma.ColumnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          create: {
            args: Prisma.ColumnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          createMany: {
            args: Prisma.ColumnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColumnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          delete: {
            args: Prisma.ColumnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          update: {
            args: Prisma.ColumnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          deleteMany: {
            args: Prisma.ColumnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColumnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ColumnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          aggregate: {
            args: Prisma.ColumnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColumn>
          }
          groupBy: {
            args: Prisma.ColumnGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColumnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColumnCountArgs<ExtArgs>
            result: $Utils.Optional<ColumnCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskAccount: {
        payload: Prisma.$TaskAccountPayload<ExtArgs>
        fields: Prisma.TaskAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>
          }
          findFirst: {
            args: Prisma.TaskAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>
          }
          findMany: {
            args: Prisma.TaskAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>[]
          }
          create: {
            args: Prisma.TaskAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>
          }
          createMany: {
            args: Prisma.TaskAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>[]
          }
          delete: {
            args: Prisma.TaskAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>
          }
          update: {
            args: Prisma.TaskAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>
          }
          deleteMany: {
            args: Prisma.TaskAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAccountPayload>
          }
          aggregate: {
            args: Prisma.TaskAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAccount>
          }
          groupBy: {
            args: Prisma.TaskAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAccountCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAccountCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignee: {
        payload: Prisma.$TaskAssigneePayload<ExtArgs>
        fields: Prisma.TaskAssigneeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssigneeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findFirst: {
            args: Prisma.TaskAssigneeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssigneeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findMany: {
            args: Prisma.TaskAssigneeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          create: {
            args: Prisma.TaskAssigneeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          createMany: {
            args: Prisma.TaskAssigneeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssigneeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          delete: {
            args: Prisma.TaskAssigneeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          update: {
            args: Prisma.TaskAssigneeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          deleteMany: {
            args: Prisma.TaskAssigneeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssigneeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskAssigneeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          aggregate: {
            args: Prisma.TaskAssigneeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignee>
          }
          groupBy: {
            args: Prisma.TaskAssigneeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssigneeCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeCountAggregateOutputType> | number
          }
        }
      }
      TaskComment: {
        payload: Prisma.$TaskCommentPayload<ExtArgs>
        fields: Prisma.TaskCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          findFirst: {
            args: Prisma.TaskCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          findMany: {
            args: Prisma.TaskCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
          }
          create: {
            args: Prisma.TaskCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          createMany: {
            args: Prisma.TaskCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
          }
          delete: {
            args: Prisma.TaskCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          update: {
            args: Prisma.TaskCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          deleteMany: {
            args: Prisma.TaskCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          aggregate: {
            args: Prisma.TaskCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskComment>
          }
          groupBy: {
            args: Prisma.TaskCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCommentCountAggregateOutputType> | number
          }
        }
      }
      TaskAttachment: {
        payload: Prisma.$TaskAttachmentPayload<ExtArgs>
        fields: Prisma.TaskAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          findMany: {
            args: Prisma.TaskAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          create: {
            args: Prisma.TaskAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          createMany: {
            args: Prisma.TaskAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TaskAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          update: {
            args: Prisma.TaskAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAttachment>
          }
          groupBy: {
            args: Prisma.TaskAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAttachmentCountAggregateOutputType> | number
          }
        }
      }
      TaskLabel: {
        payload: Prisma.$TaskLabelPayload<ExtArgs>
        fields: Prisma.TaskLabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskLabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskLabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          findFirst: {
            args: Prisma.TaskLabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskLabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          findMany: {
            args: Prisma.TaskLabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>[]
          }
          create: {
            args: Prisma.TaskLabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          createMany: {
            args: Prisma.TaskLabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskLabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>[]
          }
          delete: {
            args: Prisma.TaskLabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          update: {
            args: Prisma.TaskLabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          deleteMany: {
            args: Prisma.TaskLabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskLabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskLabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          aggregate: {
            args: Prisma.TaskLabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskLabel>
          }
          groupBy: {
            args: Prisma.TaskLabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskLabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskLabelCountArgs<ExtArgs>
            result: $Utils.Optional<TaskLabelCountAggregateOutputType> | number
          }
        }
      }
      Label: {
        payload: Prisma.$LabelPayload<ExtArgs>
        fields: Prisma.LabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findFirst: {
            args: Prisma.LabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findMany: {
            args: Prisma.LabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          create: {
            args: Prisma.LabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          createMany: {
            args: Prisma.LabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          delete: {
            args: Prisma.LabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          update: {
            args: Prisma.LabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          deleteMany: {
            args: Prisma.LabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          aggregate: {
            args: Prisma.LabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabel>
          }
          groupBy: {
            args: Prisma.LabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabelCountArgs<ExtArgs>
            result: $Utils.Optional<LabelCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Verify: {
        payload: Prisma.$VerifyPayload<ExtArgs>
        fields: Prisma.VerifyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerifyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerifyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>
          }
          findFirst: {
            args: Prisma.VerifyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerifyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>
          }
          findMany: {
            args: Prisma.VerifyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>[]
          }
          create: {
            args: Prisma.VerifyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>
          }
          createMany: {
            args: Prisma.VerifyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerifyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>[]
          }
          delete: {
            args: Prisma.VerifyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>
          }
          update: {
            args: Prisma.VerifyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>
          }
          deleteMany: {
            args: Prisma.VerifyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerifyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerifyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifyPayload>
          }
          aggregate: {
            args: Prisma.VerifyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerify>
          }
          groupBy: {
            args: Prisma.VerifyGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerifyGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerifyCountArgs<ExtArgs>
            result: $Utils.Optional<VerifyCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      ProjectClaim: {
        payload: Prisma.$ProjectClaimPayload<ExtArgs>
        fields: Prisma.ProjectClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>
          }
          findFirst: {
            args: Prisma.ProjectClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>
          }
          findMany: {
            args: Prisma.ProjectClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>[]
          }
          create: {
            args: Prisma.ProjectClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>
          }
          createMany: {
            args: Prisma.ProjectClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>[]
          }
          delete: {
            args: Prisma.ProjectClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>
          }
          update: {
            args: Prisma.ProjectClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>
          }
          deleteMany: {
            args: Prisma.ProjectClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectClaimPayload>
          }
          aggregate: {
            args: Prisma.ProjectClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectClaim>
          }
          groupBy: {
            args: Prisma.ProjectClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectClaimCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectClaimCountAggregateOutputType> | number
          }
        }
      }
      Envelop: {
        payload: Prisma.$EnvelopPayload<ExtArgs>
        fields: Prisma.EnvelopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvelopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvelopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>
          }
          findFirst: {
            args: Prisma.EnvelopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvelopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>
          }
          findMany: {
            args: Prisma.EnvelopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>[]
          }
          create: {
            args: Prisma.EnvelopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>
          }
          createMany: {
            args: Prisma.EnvelopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvelopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>[]
          }
          delete: {
            args: Prisma.EnvelopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>
          }
          update: {
            args: Prisma.EnvelopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>
          }
          deleteMany: {
            args: Prisma.EnvelopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvelopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnvelopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopPayload>
          }
          aggregate: {
            args: Prisma.EnvelopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvelop>
          }
          groupBy: {
            args: Prisma.EnvelopGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvelopGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvelopCountArgs<ExtArgs>
            result: $Utils.Optional<EnvelopCountAggregateOutputType> | number
          }
        }
      }
      ClaimList: {
        payload: Prisma.$ClaimListPayload<ExtArgs>
        fields: Prisma.ClaimListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>
          }
          findFirst: {
            args: Prisma.ClaimListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>
          }
          findMany: {
            args: Prisma.ClaimListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>[]
          }
          create: {
            args: Prisma.ClaimListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>
          }
          createMany: {
            args: Prisma.ClaimListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaimListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>[]
          }
          delete: {
            args: Prisma.ClaimListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>
          }
          update: {
            args: Prisma.ClaimListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>
          }
          deleteMany: {
            args: Prisma.ClaimListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClaimListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimListPayload>
          }
          aggregate: {
            args: Prisma.ClaimListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaimList>
          }
          groupBy: {
            args: Prisma.ClaimListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimListCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimListCountAggregateOutputType> | number
          }
        }
      }
      Source: {
        payload: Prisma.$SourcePayload<ExtArgs>
        fields: Prisma.SourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findFirst: {
            args: Prisma.SourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findMany: {
            args: Prisma.SourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          create: {
            args: Prisma.SourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          createMany: {
            args: Prisma.SourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          delete: {
            args: Prisma.SourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          update: {
            args: Prisma.SourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          deleteMany: {
            args: Prisma.SourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          aggregate: {
            args: Prisma.SourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSource>
          }
          groupBy: {
            args: Prisma.SourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceCountArgs<ExtArgs>
            result: $Utils.Optional<SourceCountAggregateOutputType> | number
          }
        }
      }
      Questionnaire: {
        payload: Prisma.$QuestionnairePayload<ExtArgs>
        fields: Prisma.QuestionnaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionnaireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionnaireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>
          }
          findFirst: {
            args: Prisma.QuestionnaireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionnaireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>
          }
          findMany: {
            args: Prisma.QuestionnaireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>[]
          }
          create: {
            args: Prisma.QuestionnaireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>
          }
          createMany: {
            args: Prisma.QuestionnaireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionnaireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>[]
          }
          delete: {
            args: Prisma.QuestionnaireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>
          }
          update: {
            args: Prisma.QuestionnaireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>
          }
          deleteMany: {
            args: Prisma.QuestionnaireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionnaireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionnaireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnairePayload>
          }
          aggregate: {
            args: Prisma.QuestionnaireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaire>
          }
          groupBy: {
            args: Prisma.QuestionnaireGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionnaireCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireCountAggregateOutputType> | number
          }
        }
      }
      QuestionAnswer: {
        payload: Prisma.$QuestionAnswerPayload<ExtArgs>
        fields: Prisma.QuestionAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuestionAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          findMany: {
            args: Prisma.QuestionAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>[]
          }
          create: {
            args: Prisma.QuestionAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          createMany: {
            args: Prisma.QuestionAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>[]
          }
          delete: {
            args: Prisma.QuestionAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          update: {
            args: Prisma.QuestionAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuestionAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuestionAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionAnswer>
          }
          groupBy: {
            args: Prisma.QuestionAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnswerCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Choice: {
        payload: Prisma.$ChoicePayload<ExtArgs>
        fields: Prisma.ChoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          findFirst: {
            args: Prisma.ChoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          findMany: {
            args: Prisma.ChoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>[]
          }
          create: {
            args: Prisma.ChoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          createMany: {
            args: Prisma.ChoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>[]
          }
          delete: {
            args: Prisma.ChoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          update: {
            args: Prisma.ChoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          deleteMany: {
            args: Prisma.ChoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          aggregate: {
            args: Prisma.ChoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoice>
          }
          groupBy: {
            args: Prisma.ChoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoiceCountArgs<ExtArgs>
            result: $Utils.Optional<ChoiceCountAggregateOutputType> | number
          }
        }
      }
      Defendant: {
        payload: Prisma.$DefendantPayload<ExtArgs>
        fields: Prisma.DefendantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefendantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefendantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>
          }
          findFirst: {
            args: Prisma.DefendantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefendantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>
          }
          findMany: {
            args: Prisma.DefendantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>[]
          }
          create: {
            args: Prisma.DefendantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>
          }
          createMany: {
            args: Prisma.DefendantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefendantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>[]
          }
          delete: {
            args: Prisma.DefendantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>
          }
          update: {
            args: Prisma.DefendantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>
          }
          deleteMany: {
            args: Prisma.DefendantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefendantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefendantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantPayload>
          }
          aggregate: {
            args: Prisma.DefendantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefendant>
          }
          groupBy: {
            args: Prisma.DefendantGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefendantGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefendantCountArgs<ExtArgs>
            result: $Utils.Optional<DefendantCountAggregateOutputType> | number
          }
        }
      }
      DefendantDetails: {
        payload: Prisma.$DefendantDetailsPayload<ExtArgs>
        fields: Prisma.DefendantDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefendantDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefendantDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>
          }
          findFirst: {
            args: Prisma.DefendantDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefendantDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>
          }
          findMany: {
            args: Prisma.DefendantDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>[]
          }
          create: {
            args: Prisma.DefendantDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>
          }
          createMany: {
            args: Prisma.DefendantDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefendantDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>[]
          }
          delete: {
            args: Prisma.DefendantDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>
          }
          update: {
            args: Prisma.DefendantDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>
          }
          deleteMany: {
            args: Prisma.DefendantDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefendantDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefendantDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefendantDetailsPayload>
          }
          aggregate: {
            args: Prisma.DefendantDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefendantDetails>
          }
          groupBy: {
            args: Prisma.DefendantDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefendantDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefendantDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<DefendantDetailsCountAggregateOutputType> | number
          }
        }
      }
      TreatmentAndInjury: {
        payload: Prisma.$TreatmentAndInjuryPayload<ExtArgs>
        fields: Prisma.TreatmentAndInjuryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreatmentAndInjuryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreatmentAndInjuryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>
          }
          findFirst: {
            args: Prisma.TreatmentAndInjuryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreatmentAndInjuryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>
          }
          findMany: {
            args: Prisma.TreatmentAndInjuryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>[]
          }
          create: {
            args: Prisma.TreatmentAndInjuryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>
          }
          createMany: {
            args: Prisma.TreatmentAndInjuryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreatmentAndInjuryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>[]
          }
          delete: {
            args: Prisma.TreatmentAndInjuryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>
          }
          update: {
            args: Prisma.TreatmentAndInjuryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>
          }
          deleteMany: {
            args: Prisma.TreatmentAndInjuryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreatmentAndInjuryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreatmentAndInjuryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentAndInjuryPayload>
          }
          aggregate: {
            args: Prisma.TreatmentAndInjuryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreatmentAndInjury>
          }
          groupBy: {
            args: Prisma.TreatmentAndInjuryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreatmentAndInjuryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreatmentAndInjuryCountArgs<ExtArgs>
            result: $Utils.Optional<TreatmentAndInjuryCountAggregateOutputType> | number
          }
        }
      }
      Treatment: {
        payload: Prisma.$TreatmentPayload<ExtArgs>
        fields: Prisma.TreatmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreatmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreatmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          findFirst: {
            args: Prisma.TreatmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreatmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          findMany: {
            args: Prisma.TreatmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
          }
          create: {
            args: Prisma.TreatmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          createMany: {
            args: Prisma.TreatmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreatmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
          }
          delete: {
            args: Prisma.TreatmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          update: {
            args: Prisma.TreatmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          deleteMany: {
            args: Prisma.TreatmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreatmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreatmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          aggregate: {
            args: Prisma.TreatmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreatment>
          }
          groupBy: {
            args: Prisma.TreatmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreatmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreatmentCountArgs<ExtArgs>
            result: $Utils.Optional<TreatmentCountAggregateOutputType> | number
          }
        }
      }
      Injury: {
        payload: Prisma.$InjuryPayload<ExtArgs>
        fields: Prisma.InjuryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InjuryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InjuryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>
          }
          findFirst: {
            args: Prisma.InjuryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InjuryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>
          }
          findMany: {
            args: Prisma.InjuryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>[]
          }
          create: {
            args: Prisma.InjuryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>
          }
          createMany: {
            args: Prisma.InjuryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InjuryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>[]
          }
          delete: {
            args: Prisma.InjuryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>
          }
          update: {
            args: Prisma.InjuryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>
          }
          deleteMany: {
            args: Prisma.InjuryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InjuryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InjuryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjuryPayload>
          }
          aggregate: {
            args: Prisma.InjuryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInjury>
          }
          groupBy: {
            args: Prisma.InjuryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InjuryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InjuryCountArgs<ExtArgs>
            result: $Utils.Optional<InjuryCountAggregateOutputType> | number
          }
        }
      }
      AccidentMedia: {
        payload: Prisma.$AccidentMediaPayload<ExtArgs>
        fields: Prisma.AccidentMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccidentMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccidentMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>
          }
          findFirst: {
            args: Prisma.AccidentMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccidentMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>
          }
          findMany: {
            args: Prisma.AccidentMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>[]
          }
          create: {
            args: Prisma.AccidentMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>
          }
          createMany: {
            args: Prisma.AccidentMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccidentMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>[]
          }
          delete: {
            args: Prisma.AccidentMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>
          }
          update: {
            args: Prisma.AccidentMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>
          }
          deleteMany: {
            args: Prisma.AccidentMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccidentMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccidentMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentMediaPayload>
          }
          aggregate: {
            args: Prisma.AccidentMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccidentMedia>
          }
          groupBy: {
            args: Prisma.AccidentMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccidentMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccidentMediaCountArgs<ExtArgs>
            result: $Utils.Optional<AccidentMediaCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      Witness: {
        payload: Prisma.$WitnessPayload<ExtArgs>
        fields: Prisma.WitnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WitnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WitnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          findFirst: {
            args: Prisma.WitnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WitnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          findMany: {
            args: Prisma.WitnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>[]
          }
          create: {
            args: Prisma.WitnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          createMany: {
            args: Prisma.WitnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WitnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>[]
          }
          delete: {
            args: Prisma.WitnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          update: {
            args: Prisma.WitnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          deleteMany: {
            args: Prisma.WitnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WitnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WitnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessPayload>
          }
          aggregate: {
            args: Prisma.WitnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWitness>
          }
          groupBy: {
            args: Prisma.WitnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<WitnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.WitnessCountArgs<ExtArgs>
            result: $Utils.Optional<WitnessCountAggregateOutputType> | number
          }
        }
      }
      WitnessDetails: {
        payload: Prisma.$WitnessDetailsPayload<ExtArgs>
        fields: Prisma.WitnessDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WitnessDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WitnessDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>
          }
          findFirst: {
            args: Prisma.WitnessDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WitnessDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>
          }
          findMany: {
            args: Prisma.WitnessDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>[]
          }
          create: {
            args: Prisma.WitnessDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>
          }
          createMany: {
            args: Prisma.WitnessDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WitnessDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>[]
          }
          delete: {
            args: Prisma.WitnessDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>
          }
          update: {
            args: Prisma.WitnessDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>
          }
          deleteMany: {
            args: Prisma.WitnessDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WitnessDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WitnessDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessDetailsPayload>
          }
          aggregate: {
            args: Prisma.WitnessDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWitnessDetails>
          }
          groupBy: {
            args: Prisma.WitnessDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WitnessDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WitnessDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<WitnessDetailsCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RoleType: {
        payload: Prisma.$RoleTypePayload<ExtArgs>
        fields: Prisma.RoleTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>
          }
          findFirst: {
            args: Prisma.RoleTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>
          }
          findMany: {
            args: Prisma.RoleTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>[]
          }
          create: {
            args: Prisma.RoleTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>
          }
          createMany: {
            args: Prisma.RoleTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>[]
          }
          delete: {
            args: Prisma.RoleTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>
          }
          update: {
            args: Prisma.RoleTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>
          }
          deleteMany: {
            args: Prisma.RoleTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTypePayload>
          }
          aggregate: {
            args: Prisma.RoleTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleType>
          }
          groupBy: {
            args: Prisma.RoleTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTypeCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      SubAccount: {
        payload: Prisma.$SubAccountPayload<ExtArgs>
        fields: Prisma.SubAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findFirst: {
            args: Prisma.SubAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findMany: {
            args: Prisma.SubAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          create: {
            args: Prisma.SubAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          createMany: {
            args: Prisma.SubAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          delete: {
            args: Prisma.SubAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          update: {
            args: Prisma.SubAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          aggregate: {
            args: Prisma.SubAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccount>
          }
          groupBy: {
            args: Prisma.SubAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountCountAggregateOutputType> | number
          }
        }
      }
      Car: {
        payload: Prisma.$CarPayload<ExtArgs>
        fields: Prisma.CarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findFirst: {
            args: Prisma.CarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findMany: {
            args: Prisma.CarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>[]
          }
          create: {
            args: Prisma.CarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          createMany: {
            args: Prisma.CarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>[]
          }
          delete: {
            args: Prisma.CarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          update: {
            args: Prisma.CarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          deleteMany: {
            args: Prisma.CarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          aggregate: {
            args: Prisma.CarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCar>
          }
          groupBy: {
            args: Prisma.CarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarCountArgs<ExtArgs>
            result: $Utils.Optional<CarCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    boards: number
    projectClaims: number
    projectAccounts: number
    projectUsers: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boards?: boolean | ProjectCountOutputTypeCountBoardsArgs
    projectClaims?: boolean | ProjectCountOutputTypeCountProjectClaimsArgs
    projectAccounts?: boolean | ProjectCountOutputTypeCountProjectAccountsArgs
    projectUsers?: boolean | ProjectCountOutputTypeCountProjectUsersArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectClaimWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectAccountWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUserWhereInput
  }


  /**
   * Count Type BoardCountOutputType
   */

  export type BoardCountOutputType = {
    columns: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    columns?: boolean | BoardCountOutputTypeCountColumnsArgs
  }

  // Custom InputTypes
  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountColumnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColumnWhereInput
  }


  /**
   * Count Type ColumnCountOutputType
   */

  export type ColumnCountOutputType = {
    tasks: number
  }

  export type ColumnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ColumnCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ColumnCountOutputType without action
   */
  export type ColumnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColumnCountOutputType
     */
    select?: ColumnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColumnCountOutputType without action
   */
  export type ColumnCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    taskAccounts: number
    taskAssignees: number
    comments: number
    attachments: number
    labels: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskAccounts?: boolean | TaskCountOutputTypeCountTaskAccountsArgs
    taskAssignees?: boolean | TaskCountOutputTypeCountTaskAssigneesArgs
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
    attachments?: boolean | TaskCountOutputTypeCountAttachmentsArgs
    labels?: boolean | TaskCountOutputTypeCountLabelsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAccountWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
  }


  /**
   * Count Type LabelCountOutputType
   */

  export type LabelCountOutputType = {
    taskLabels: number
  }

  export type LabelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskLabels?: boolean | LabelCountOutputTypeCountTaskLabelsArgs
  }

  // Custom InputTypes
  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabelCountOutputType
     */
    select?: LabelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeCountTaskLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    claims: number
    projectsOwned: number
    tasksCreated: number
    taskAssignments: number
    projectAssignments: number
    taskComments: number
    labelsCreated: number
    taskAttachments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | UserCountOutputTypeCountClaimsArgs
    projectsOwned?: boolean | UserCountOutputTypeCountProjectsOwnedArgs
    tasksCreated?: boolean | UserCountOutputTypeCountTasksCreatedArgs
    taskAssignments?: boolean | UserCountOutputTypeCountTaskAssignmentsArgs
    projectAssignments?: boolean | UserCountOutputTypeCountProjectAssignmentsArgs
    taskComments?: boolean | UserCountOutputTypeCountTaskCommentsArgs
    labelsCreated?: boolean | UserCountOutputTypeCountLabelsCreatedArgs
    taskAttachments?: boolean | UserCountOutputTypeCountTaskAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLabelsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
  }


  /**
   * Count Type ClaimCountOutputType
   */

  export type ClaimCountOutputType = {
    envelop: number
    media: number
    tasks: number
    projectClaims: number
  }

  export type ClaimCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    envelop?: boolean | ClaimCountOutputTypeCountEnvelopArgs
    media?: boolean | ClaimCountOutputTypeCountMediaArgs
    tasks?: boolean | ClaimCountOutputTypeCountTasksArgs
    projectClaims?: boolean | ClaimCountOutputTypeCountProjectClaimsArgs
  }

  // Custom InputTypes
  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimCountOutputType
     */
    select?: ClaimCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountEnvelopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvelopWhereInput
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccidentMediaWhereInput
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountProjectClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectClaimWhereInput
  }


  /**
   * Count Type ClaimListCountOutputType
   */

  export type ClaimListCountOutputType = {
    claim: number
    user: number
    question: number
  }

  export type ClaimListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimListCountOutputTypeCountClaimArgs
    user?: boolean | ClaimListCountOutputTypeCountUserArgs
    question?: boolean | ClaimListCountOutputTypeCountQuestionArgs
  }

  // Custom InputTypes
  /**
   * ClaimListCountOutputType without action
   */
  export type ClaimListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimListCountOutputType
     */
    select?: ClaimListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClaimListCountOutputType without action
   */
  export type ClaimListCountOutputTypeCountClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * ClaimListCountOutputType without action
   */
  export type ClaimListCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ClaimListCountOutputType without action
   */
  export type ClaimListCountOutputTypeCountQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }


  /**
   * Count Type SourceCountOutputType
   */

  export type SourceCountOutputType = {
    user: number
  }

  export type SourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SourceCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     */
    select?: SourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type QuestionnaireCountOutputType
   */

  export type QuestionnaireCountOutputType = {
    question: number
  }

  export type QuestionnaireCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionnaireCountOutputTypeCountQuestionArgs
  }

  // Custom InputTypes
  /**
   * QuestionnaireCountOutputType without action
   */
  export type QuestionnaireCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireCountOutputType
     */
    select?: QuestionnaireCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionnaireCountOutputType without action
   */
  export type QuestionnaireCountOutputTypeCountQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    choices: number
    QuestionAnswer: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choices?: boolean | QuestionCountOutputTypeCountChoicesArgs
    QuestionAnswer?: boolean | QuestionCountOutputTypeCountQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type DefendantCountOutputType
   */

  export type DefendantCountOutputType = {
    defendantDetails: number
  }

  export type DefendantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defendantDetails?: boolean | DefendantCountOutputTypeCountDefendantDetailsArgs
  }

  // Custom InputTypes
  /**
   * DefendantCountOutputType without action
   */
  export type DefendantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantCountOutputType
     */
    select?: DefendantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DefendantCountOutputType without action
   */
  export type DefendantCountOutputTypeCountDefendantDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefendantDetailsWhereInput
  }


  /**
   * Count Type TreatmentCountOutputType
   */

  export type TreatmentCountOutputType = {
    injuries: number
  }

  export type TreatmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    injuries?: boolean | TreatmentCountOutputTypeCountInjuriesArgs
  }

  // Custom InputTypes
  /**
   * TreatmentCountOutputType without action
   */
  export type TreatmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentCountOutputType
     */
    select?: TreatmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TreatmentCountOutputType without action
   */
  export type TreatmentCountOutputTypeCountInjuriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InjuryWhereInput
  }


  /**
   * Count Type WitnessCountOutputType
   */

  export type WitnessCountOutputType = {
    witnessDetails: number
  }

  export type WitnessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    witnessDetails?: boolean | WitnessCountOutputTypeCountWitnessDetailsArgs
  }

  // Custom InputTypes
  /**
   * WitnessCountOutputType without action
   */
  export type WitnessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessCountOutputType
     */
    select?: WitnessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WitnessCountOutputType without action
   */
  export type WitnessCountOutputTypeCountWitnessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WitnessDetailsWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    clientClaims: number
    injuredPartyClaims: number
    healthInsuranceClaims: number
    defendantAccount: number
    defendantInsuranceCarrier: number
    hospitalTreatments: number
    doctorTreatments: number
    lawfirmIncidents: number
    policeStationIncidents: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientClaims?: boolean | RoleCountOutputTypeCountClientClaimsArgs
    injuredPartyClaims?: boolean | RoleCountOutputTypeCountInjuredPartyClaimsArgs
    healthInsuranceClaims?: boolean | RoleCountOutputTypeCountHealthInsuranceClaimsArgs
    defendantAccount?: boolean | RoleCountOutputTypeCountDefendantAccountArgs
    defendantInsuranceCarrier?: boolean | RoleCountOutputTypeCountDefendantInsuranceCarrierArgs
    hospitalTreatments?: boolean | RoleCountOutputTypeCountHospitalTreatmentsArgs
    doctorTreatments?: boolean | RoleCountOutputTypeCountDoctorTreatmentsArgs
    lawfirmIncidents?: boolean | RoleCountOutputTypeCountLawfirmIncidentsArgs
    policeStationIncidents?: boolean | RoleCountOutputTypeCountPoliceStationIncidentsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountClientClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountInjuredPartyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountHealthInsuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountDefendantAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefendantDetailsWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountDefendantInsuranceCarrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefendantDetailsWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountHospitalTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountDoctorTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountLawfirmIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPoliceStationIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }


  /**
   * Count Type RoleTypeCountOutputType
   */

  export type RoleTypeCountOutputType = {
    Role: number
  }

  export type RoleTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleTypeCountOutputTypeCountRoleArgs
  }

  // Custom InputTypes
  /**
   * RoleTypeCountOutputType without action
   */
  export type RoleTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTypeCountOutputType
     */
    select?: RoleTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleTypeCountOutputType without action
   */
  export type RoleTypeCountOutputTypeCountRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    Role: number
    subAccount: number
    projectAccounts: number
    taskAccounts: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | AccountCountOutputTypeCountRoleArgs
    subAccount?: boolean | AccountCountOutputTypeCountSubAccountArgs
    projectAccounts?: boolean | AccountCountOutputTypeCountProjectAccountsArgs
    taskAccounts?: boolean | AccountCountOutputTypeCountTaskAccountsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountProjectAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectAccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTaskAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAccountWhereInput
  }


  /**
   * Count Type SubAccountCountOutputType
   */

  export type SubAccountCountOutputType = {
    incidents: number
    policeIncidents: number
  }

  export type SubAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidents?: boolean | SubAccountCountOutputTypeCountIncidentsArgs
    policeIncidents?: boolean | SubAccountCountOutputTypeCountPoliceIncidentsArgs
  }

  // Custom InputTypes
  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountCountOutputType
     */
    select?: SubAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountPoliceIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    ownerId: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    ownerId: string
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    boards?: boolean | Project$boardsArgs<ExtArgs>
    projectClaims?: boolean | Project$projectClaimsArgs<ExtArgs>
    projectAccounts?: boolean | Project$projectAccountsArgs<ExtArgs>
    projectUsers?: boolean | Project$projectUsersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    boards?: boolean | Project$boardsArgs<ExtArgs>
    projectClaims?: boolean | Project$projectClaimsArgs<ExtArgs>
    projectAccounts?: boolean | Project$projectAccountsArgs<ExtArgs>
    projectUsers?: boolean | Project$projectUsersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      boards: Prisma.$BoardPayload<ExtArgs>[]
      projectClaims: Prisma.$ProjectClaimPayload<ExtArgs>[]
      projectAccounts: Prisma.$ProjectAccountPayload<ExtArgs>[]
      projectUsers: Prisma.$ProjectUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      ownerId: string
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    boards<T extends Project$boardsArgs<ExtArgs> = {}>(args?: Subset<T, Project$boardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany"> | Null>
    projectClaims<T extends Project$projectClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "findMany"> | Null>
    projectAccounts<T extends Project$projectAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "findMany"> | Null>
    projectUsers<T extends Project$projectUsersArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly ownerId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.boards
   */
  export type Project$boardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    cursor?: BoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Project.projectClaims
   */
  export type Project$projectClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    where?: ProjectClaimWhereInput
    orderBy?: ProjectClaimOrderByWithRelationInput | ProjectClaimOrderByWithRelationInput[]
    cursor?: ProjectClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectClaimScalarFieldEnum | ProjectClaimScalarFieldEnum[]
  }

  /**
   * Project.projectAccounts
   */
  export type Project$projectAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    where?: ProjectAccountWhereInput
    orderBy?: ProjectAccountOrderByWithRelationInput | ProjectAccountOrderByWithRelationInput[]
    cursor?: ProjectAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectAccountScalarFieldEnum | ProjectAccountScalarFieldEnum[]
  }

  /**
   * Project.projectUsers
   */
  export type Project$projectUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    where?: ProjectUserWhereInput
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    cursor?: ProjectUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectUser
   */

  export type AggregateProjectUser = {
    _count: ProjectUserCountAggregateOutputType | null
    _min: ProjectUserMinAggregateOutputType | null
    _max: ProjectUserMaxAggregateOutputType | null
  }

  export type ProjectUserMinAggregateOutputType = {
    projectId: string | null
    userId: string | null
    assignedAt: Date | null
  }

  export type ProjectUserMaxAggregateOutputType = {
    projectId: string | null
    userId: string | null
    assignedAt: Date | null
  }

  export type ProjectUserCountAggregateOutputType = {
    projectId: number
    userId: number
    assignedAt: number
    _all: number
  }


  export type ProjectUserMinAggregateInputType = {
    projectId?: true
    userId?: true
    assignedAt?: true
  }

  export type ProjectUserMaxAggregateInputType = {
    projectId?: true
    userId?: true
    assignedAt?: true
  }

  export type ProjectUserCountAggregateInputType = {
    projectId?: true
    userId?: true
    assignedAt?: true
    _all?: true
  }

  export type ProjectUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUser to aggregate.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectUsers
    **/
    _count?: true | ProjectUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectUserMaxAggregateInputType
  }

  export type GetProjectUserAggregateType<T extends ProjectUserAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectUser[P]>
      : GetScalarType<T[P], AggregateProjectUser[P]>
  }




  export type ProjectUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUserWhereInput
    orderBy?: ProjectUserOrderByWithAggregationInput | ProjectUserOrderByWithAggregationInput[]
    by: ProjectUserScalarFieldEnum[] | ProjectUserScalarFieldEnum
    having?: ProjectUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectUserCountAggregateInputType | true
    _min?: ProjectUserMinAggregateInputType
    _max?: ProjectUserMaxAggregateInputType
  }

  export type ProjectUserGroupByOutputType = {
    projectId: string
    userId: string
    assignedAt: Date
    _count: ProjectUserCountAggregateOutputType | null
    _min: ProjectUserMinAggregateOutputType | null
    _max: ProjectUserMaxAggregateOutputType | null
  }

  type GetProjectUserGroupByPayload<T extends ProjectUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectUserGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectUserGroupByOutputType[P]>
        }
      >
    >


  export type ProjectUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUser"]>

  export type ProjectUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUser"]>

  export type ProjectUserSelectScalar = {
    projectId?: boolean
    userId?: boolean
    assignedAt?: boolean
  }

  export type ProjectUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectUser"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      userId: string
      assignedAt: Date
    }, ExtArgs["result"]["projectUser"]>
    composites: {}
  }

  type ProjectUserGetPayload<S extends boolean | null | undefined | ProjectUserDefaultArgs> = $Result.GetResult<Prisma.$ProjectUserPayload, S>

  type ProjectUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectUserCountAggregateInputType | true
    }

  export interface ProjectUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectUser'], meta: { name: 'ProjectUser' } }
    /**
     * Find zero or one ProjectUser that matches the filter.
     * @param {ProjectUserFindUniqueArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectUserFindUniqueArgs>(args: SelectSubset<T, ProjectUserFindUniqueArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectUserFindUniqueOrThrowArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserFindFirstArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectUserFindFirstArgs>(args?: SelectSubset<T, ProjectUserFindFirstArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserFindFirstOrThrowArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectUsers
     * const projectUsers = await prisma.projectUser.findMany()
     * 
     * // Get first 10 ProjectUsers
     * const projectUsers = await prisma.projectUser.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectUserWithProjectIdOnly = await prisma.projectUser.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectUserFindManyArgs>(args?: SelectSubset<T, ProjectUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectUser.
     * @param {ProjectUserCreateArgs} args - Arguments to create a ProjectUser.
     * @example
     * // Create one ProjectUser
     * const ProjectUser = await prisma.projectUser.create({
     *   data: {
     *     // ... data to create a ProjectUser
     *   }
     * })
     * 
     */
    create<T extends ProjectUserCreateArgs>(args: SelectSubset<T, ProjectUserCreateArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectUsers.
     * @param {ProjectUserCreateManyArgs} args - Arguments to create many ProjectUsers.
     * @example
     * // Create many ProjectUsers
     * const projectUser = await prisma.projectUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectUserCreateManyArgs>(args?: SelectSubset<T, ProjectUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectUsers and returns the data saved in the database.
     * @param {ProjectUserCreateManyAndReturnArgs} args - Arguments to create many ProjectUsers.
     * @example
     * // Create many ProjectUsers
     * const projectUser = await prisma.projectUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectUsers and only return the `projectId`
     * const projectUserWithProjectIdOnly = await prisma.projectUser.createManyAndReturn({ 
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectUserCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectUser.
     * @param {ProjectUserDeleteArgs} args - Arguments to delete one ProjectUser.
     * @example
     * // Delete one ProjectUser
     * const ProjectUser = await prisma.projectUser.delete({
     *   where: {
     *     // ... filter to delete one ProjectUser
     *   }
     * })
     * 
     */
    delete<T extends ProjectUserDeleteArgs>(args: SelectSubset<T, ProjectUserDeleteArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectUser.
     * @param {ProjectUserUpdateArgs} args - Arguments to update one ProjectUser.
     * @example
     * // Update one ProjectUser
     * const projectUser = await prisma.projectUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUserUpdateArgs>(args: SelectSubset<T, ProjectUserUpdateArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectUsers.
     * @param {ProjectUserDeleteManyArgs} args - Arguments to filter ProjectUsers to delete.
     * @example
     * // Delete a few ProjectUsers
     * const { count } = await prisma.projectUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectUserDeleteManyArgs>(args?: SelectSubset<T, ProjectUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectUsers
     * const projectUser = await prisma.projectUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUserUpdateManyArgs>(args: SelectSubset<T, ProjectUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectUser.
     * @param {ProjectUserUpsertArgs} args - Arguments to update or create a ProjectUser.
     * @example
     * // Update or create a ProjectUser
     * const projectUser = await prisma.projectUser.upsert({
     *   create: {
     *     // ... data to create a ProjectUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectUser we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUserUpsertArgs>(args: SelectSubset<T, ProjectUserUpsertArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserCountArgs} args - Arguments to filter ProjectUsers to count.
     * @example
     * // Count the number of ProjectUsers
     * const count = await prisma.projectUser.count({
     *   where: {
     *     // ... the filter for the ProjectUsers we want to count
     *   }
     * })
    **/
    count<T extends ProjectUserCountArgs>(
      args?: Subset<T, ProjectUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectUserAggregateArgs>(args: Subset<T, ProjectUserAggregateArgs>): Prisma.PrismaPromise<GetProjectUserAggregateType<T>>

    /**
     * Group by ProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectUserGroupByArgs['orderBy'] }
        : { orderBy?: ProjectUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectUser model
   */
  readonly fields: ProjectUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectUser model
   */ 
  interface ProjectUserFieldRefs {
    readonly projectId: FieldRef<"ProjectUser", 'String'>
    readonly userId: FieldRef<"ProjectUser", 'String'>
    readonly assignedAt: FieldRef<"ProjectUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectUser findUnique
   */
  export type ProjectUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser findUniqueOrThrow
   */
  export type ProjectUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser findFirst
   */
  export type ProjectUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUsers.
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUsers.
     */
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * ProjectUser findFirstOrThrow
   */
  export type ProjectUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUsers.
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUsers.
     */
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * ProjectUser findMany
   */
  export type ProjectUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUsers to fetch.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectUsers.
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * ProjectUser create
   */
  export type ProjectUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectUser.
     */
    data: XOR<ProjectUserCreateInput, ProjectUserUncheckedCreateInput>
  }

  /**
   * ProjectUser createMany
   */
  export type ProjectUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectUsers.
     */
    data: ProjectUserCreateManyInput | ProjectUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectUser createManyAndReturn
   */
  export type ProjectUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectUsers.
     */
    data: ProjectUserCreateManyInput | ProjectUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectUser update
   */
  export type ProjectUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectUser.
     */
    data: XOR<ProjectUserUpdateInput, ProjectUserUncheckedUpdateInput>
    /**
     * Choose, which ProjectUser to update.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser updateMany
   */
  export type ProjectUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectUsers.
     */
    data: XOR<ProjectUserUpdateManyMutationInput, ProjectUserUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUsers to update
     */
    where?: ProjectUserWhereInput
  }

  /**
   * ProjectUser upsert
   */
  export type ProjectUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectUser to update in case it exists.
     */
    where: ProjectUserWhereUniqueInput
    /**
     * In case the ProjectUser found by the `where` argument doesn't exist, create a new ProjectUser with this data.
     */
    create: XOR<ProjectUserCreateInput, ProjectUserUncheckedCreateInput>
    /**
     * In case the ProjectUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUserUpdateInput, ProjectUserUncheckedUpdateInput>
  }

  /**
   * ProjectUser delete
   */
  export type ProjectUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter which ProjectUser to delete.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser deleteMany
   */
  export type ProjectUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUsers to delete
     */
    where?: ProjectUserWhereInput
  }

  /**
   * ProjectUser without action
   */
  export type ProjectUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
  }


  /**
   * Model ProjectAccount
   */

  export type AggregateProjectAccount = {
    _count: ProjectAccountCountAggregateOutputType | null
    _min: ProjectAccountMinAggregateOutputType | null
    _max: ProjectAccountMaxAggregateOutputType | null
  }

  export type ProjectAccountMinAggregateOutputType = {
    projectId: string | null
    accountId: string | null
    assignedAt: Date | null
  }

  export type ProjectAccountMaxAggregateOutputType = {
    projectId: string | null
    accountId: string | null
    assignedAt: Date | null
  }

  export type ProjectAccountCountAggregateOutputType = {
    projectId: number
    accountId: number
    assignedAt: number
    _all: number
  }


  export type ProjectAccountMinAggregateInputType = {
    projectId?: true
    accountId?: true
    assignedAt?: true
  }

  export type ProjectAccountMaxAggregateInputType = {
    projectId?: true
    accountId?: true
    assignedAt?: true
  }

  export type ProjectAccountCountAggregateInputType = {
    projectId?: true
    accountId?: true
    assignedAt?: true
    _all?: true
  }

  export type ProjectAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectAccount to aggregate.
     */
    where?: ProjectAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAccounts to fetch.
     */
    orderBy?: ProjectAccountOrderByWithRelationInput | ProjectAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectAccounts
    **/
    _count?: true | ProjectAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectAccountMaxAggregateInputType
  }

  export type GetProjectAccountAggregateType<T extends ProjectAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectAccount[P]>
      : GetScalarType<T[P], AggregateProjectAccount[P]>
  }




  export type ProjectAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectAccountWhereInput
    orderBy?: ProjectAccountOrderByWithAggregationInput | ProjectAccountOrderByWithAggregationInput[]
    by: ProjectAccountScalarFieldEnum[] | ProjectAccountScalarFieldEnum
    having?: ProjectAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectAccountCountAggregateInputType | true
    _min?: ProjectAccountMinAggregateInputType
    _max?: ProjectAccountMaxAggregateInputType
  }

  export type ProjectAccountGroupByOutputType = {
    projectId: string
    accountId: string
    assignedAt: Date
    _count: ProjectAccountCountAggregateOutputType | null
    _min: ProjectAccountMinAggregateOutputType | null
    _max: ProjectAccountMaxAggregateOutputType | null
  }

  type GetProjectAccountGroupByPayload<T extends ProjectAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectAccountGroupByOutputType[P]>
        }
      >
    >


  export type ProjectAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    accountId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectAccount"]>

  export type ProjectAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    accountId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectAccount"]>

  export type ProjectAccountSelectScalar = {
    projectId?: boolean
    accountId?: boolean
    assignedAt?: boolean
  }

  export type ProjectAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type ProjectAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $ProjectAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectAccount"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      accountId: string
      assignedAt: Date
    }, ExtArgs["result"]["projectAccount"]>
    composites: {}
  }

  type ProjectAccountGetPayload<S extends boolean | null | undefined | ProjectAccountDefaultArgs> = $Result.GetResult<Prisma.$ProjectAccountPayload, S>

  type ProjectAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectAccountCountAggregateInputType | true
    }

  export interface ProjectAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectAccount'], meta: { name: 'ProjectAccount' } }
    /**
     * Find zero or one ProjectAccount that matches the filter.
     * @param {ProjectAccountFindUniqueArgs} args - Arguments to find a ProjectAccount
     * @example
     * // Get one ProjectAccount
     * const projectAccount = await prisma.projectAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectAccountFindUniqueArgs>(args: SelectSubset<T, ProjectAccountFindUniqueArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectAccountFindUniqueOrThrowArgs} args - Arguments to find a ProjectAccount
     * @example
     * // Get one ProjectAccount
     * const projectAccount = await prisma.projectAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAccountFindFirstArgs} args - Arguments to find a ProjectAccount
     * @example
     * // Get one ProjectAccount
     * const projectAccount = await prisma.projectAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectAccountFindFirstArgs>(args?: SelectSubset<T, ProjectAccountFindFirstArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAccountFindFirstOrThrowArgs} args - Arguments to find a ProjectAccount
     * @example
     * // Get one ProjectAccount
     * const projectAccount = await prisma.projectAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectAccounts
     * const projectAccounts = await prisma.projectAccount.findMany()
     * 
     * // Get first 10 ProjectAccounts
     * const projectAccounts = await prisma.projectAccount.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectAccountWithProjectIdOnly = await prisma.projectAccount.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectAccountFindManyArgs>(args?: SelectSubset<T, ProjectAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectAccount.
     * @param {ProjectAccountCreateArgs} args - Arguments to create a ProjectAccount.
     * @example
     * // Create one ProjectAccount
     * const ProjectAccount = await prisma.projectAccount.create({
     *   data: {
     *     // ... data to create a ProjectAccount
     *   }
     * })
     * 
     */
    create<T extends ProjectAccountCreateArgs>(args: SelectSubset<T, ProjectAccountCreateArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectAccounts.
     * @param {ProjectAccountCreateManyArgs} args - Arguments to create many ProjectAccounts.
     * @example
     * // Create many ProjectAccounts
     * const projectAccount = await prisma.projectAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectAccountCreateManyArgs>(args?: SelectSubset<T, ProjectAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectAccounts and returns the data saved in the database.
     * @param {ProjectAccountCreateManyAndReturnArgs} args - Arguments to create many ProjectAccounts.
     * @example
     * // Create many ProjectAccounts
     * const projectAccount = await prisma.projectAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectAccounts and only return the `projectId`
     * const projectAccountWithProjectIdOnly = await prisma.projectAccount.createManyAndReturn({ 
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectAccount.
     * @param {ProjectAccountDeleteArgs} args - Arguments to delete one ProjectAccount.
     * @example
     * // Delete one ProjectAccount
     * const ProjectAccount = await prisma.projectAccount.delete({
     *   where: {
     *     // ... filter to delete one ProjectAccount
     *   }
     * })
     * 
     */
    delete<T extends ProjectAccountDeleteArgs>(args: SelectSubset<T, ProjectAccountDeleteArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectAccount.
     * @param {ProjectAccountUpdateArgs} args - Arguments to update one ProjectAccount.
     * @example
     * // Update one ProjectAccount
     * const projectAccount = await prisma.projectAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectAccountUpdateArgs>(args: SelectSubset<T, ProjectAccountUpdateArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectAccounts.
     * @param {ProjectAccountDeleteManyArgs} args - Arguments to filter ProjectAccounts to delete.
     * @example
     * // Delete a few ProjectAccounts
     * const { count } = await prisma.projectAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectAccountDeleteManyArgs>(args?: SelectSubset<T, ProjectAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectAccounts
     * const projectAccount = await prisma.projectAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectAccountUpdateManyArgs>(args: SelectSubset<T, ProjectAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectAccount.
     * @param {ProjectAccountUpsertArgs} args - Arguments to update or create a ProjectAccount.
     * @example
     * // Update or create a ProjectAccount
     * const projectAccount = await prisma.projectAccount.upsert({
     *   create: {
     *     // ... data to create a ProjectAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectAccount we want to update
     *   }
     * })
     */
    upsert<T extends ProjectAccountUpsertArgs>(args: SelectSubset<T, ProjectAccountUpsertArgs<ExtArgs>>): Prisma__ProjectAccountClient<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAccountCountArgs} args - Arguments to filter ProjectAccounts to count.
     * @example
     * // Count the number of ProjectAccounts
     * const count = await prisma.projectAccount.count({
     *   where: {
     *     // ... the filter for the ProjectAccounts we want to count
     *   }
     * })
    **/
    count<T extends ProjectAccountCountArgs>(
      args?: Subset<T, ProjectAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAccountAggregateArgs>(args: Subset<T, ProjectAccountAggregateArgs>): Prisma.PrismaPromise<GetProjectAccountAggregateType<T>>

    /**
     * Group by ProjectAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectAccountGroupByArgs['orderBy'] }
        : { orderBy?: ProjectAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectAccount model
   */
  readonly fields: ProjectAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectAccount model
   */ 
  interface ProjectAccountFieldRefs {
    readonly projectId: FieldRef<"ProjectAccount", 'String'>
    readonly accountId: FieldRef<"ProjectAccount", 'String'>
    readonly assignedAt: FieldRef<"ProjectAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectAccount findUnique
   */
  export type ProjectAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAccount to fetch.
     */
    where: ProjectAccountWhereUniqueInput
  }

  /**
   * ProjectAccount findUniqueOrThrow
   */
  export type ProjectAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAccount to fetch.
     */
    where: ProjectAccountWhereUniqueInput
  }

  /**
   * ProjectAccount findFirst
   */
  export type ProjectAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAccount to fetch.
     */
    where?: ProjectAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAccounts to fetch.
     */
    orderBy?: ProjectAccountOrderByWithRelationInput | ProjectAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectAccounts.
     */
    cursor?: ProjectAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectAccounts.
     */
    distinct?: ProjectAccountScalarFieldEnum | ProjectAccountScalarFieldEnum[]
  }

  /**
   * ProjectAccount findFirstOrThrow
   */
  export type ProjectAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAccount to fetch.
     */
    where?: ProjectAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAccounts to fetch.
     */
    orderBy?: ProjectAccountOrderByWithRelationInput | ProjectAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectAccounts.
     */
    cursor?: ProjectAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectAccounts.
     */
    distinct?: ProjectAccountScalarFieldEnum | ProjectAccountScalarFieldEnum[]
  }

  /**
   * ProjectAccount findMany
   */
  export type ProjectAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * Filter, which ProjectAccounts to fetch.
     */
    where?: ProjectAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectAccounts to fetch.
     */
    orderBy?: ProjectAccountOrderByWithRelationInput | ProjectAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectAccounts.
     */
    cursor?: ProjectAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectAccounts.
     */
    skip?: number
    distinct?: ProjectAccountScalarFieldEnum | ProjectAccountScalarFieldEnum[]
  }

  /**
   * ProjectAccount create
   */
  export type ProjectAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectAccount.
     */
    data: XOR<ProjectAccountCreateInput, ProjectAccountUncheckedCreateInput>
  }

  /**
   * ProjectAccount createMany
   */
  export type ProjectAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectAccounts.
     */
    data: ProjectAccountCreateManyInput | ProjectAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectAccount createManyAndReturn
   */
  export type ProjectAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectAccounts.
     */
    data: ProjectAccountCreateManyInput | ProjectAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectAccount update
   */
  export type ProjectAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectAccount.
     */
    data: XOR<ProjectAccountUpdateInput, ProjectAccountUncheckedUpdateInput>
    /**
     * Choose, which ProjectAccount to update.
     */
    where: ProjectAccountWhereUniqueInput
  }

  /**
   * ProjectAccount updateMany
   */
  export type ProjectAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectAccounts.
     */
    data: XOR<ProjectAccountUpdateManyMutationInput, ProjectAccountUncheckedUpdateManyInput>
    /**
     * Filter which ProjectAccounts to update
     */
    where?: ProjectAccountWhereInput
  }

  /**
   * ProjectAccount upsert
   */
  export type ProjectAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectAccount to update in case it exists.
     */
    where: ProjectAccountWhereUniqueInput
    /**
     * In case the ProjectAccount found by the `where` argument doesn't exist, create a new ProjectAccount with this data.
     */
    create: XOR<ProjectAccountCreateInput, ProjectAccountUncheckedCreateInput>
    /**
     * In case the ProjectAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectAccountUpdateInput, ProjectAccountUncheckedUpdateInput>
  }

  /**
   * ProjectAccount delete
   */
  export type ProjectAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    /**
     * Filter which ProjectAccount to delete.
     */
    where: ProjectAccountWhereUniqueInput
  }

  /**
   * ProjectAccount deleteMany
   */
  export type ProjectAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectAccounts to delete
     */
    where?: ProjectAccountWhereInput
  }

  /**
   * ProjectAccount without action
   */
  export type ProjectAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
  }


  /**
   * Model Board
   */

  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type BoardMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type BoardMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithAggregationInput | BoardOrderByWithAggregationInput[]
    by: BoardScalarFieldEnum[] | BoardScalarFieldEnum
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }

  export type BoardGroupByOutputType = {
    id: string
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    columns?: boolean | Board$columnsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type BoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    columns?: boolean | Board$columnsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $BoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Board"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      columns: Prisma.$ColumnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["board"]>
    composites: {}
  }

  type BoardGetPayload<S extends boolean | null | undefined | BoardDefaultArgs> = $Result.GetResult<Prisma.$BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BoardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardFindUniqueArgs>(args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Board that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardFindFirstArgs>(args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Board that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardFindManyArgs>(args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
     */
    create<T extends BoardCreateArgs>(args: SelectSubset<T, BoardCreateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Boards.
     * @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardCreateManyArgs>(args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boards and returns the data saved in the database.
     * @param {BoardCreateManyAndReturnArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
     */
    delete<T extends BoardDeleteArgs>(args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardUpdateArgs>(args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardDeleteManyArgs>(args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardUpdateManyArgs>(args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
     */
    upsert<T extends BoardUpsertArgs>(args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Board model
   */
  readonly fields: BoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    columns<T extends Board$columnsArgs<ExtArgs> = {}>(args?: Subset<T, Board$columnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Board model
   */ 
  interface BoardFieldRefs {
    readonly id: FieldRef<"Board", 'String'>
    readonly title: FieldRef<"Board", 'String'>
    readonly description: FieldRef<"Board", 'String'>
    readonly createdAt: FieldRef<"Board", 'DateTime'>
    readonly updatedAt: FieldRef<"Board", 'DateTime'>
    readonly projectId: FieldRef<"Board", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Board findUnique
   */
  export type BoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findFirst
   */
  export type BoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }

  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board createManyAndReturn
   */
  export type BoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
  }

  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }

  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
  }

  /**
   * Board.columns
   */
  export type Board$columnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    where?: ColumnWhereInput
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    cursor?: ColumnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Board without action
   */
  export type BoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
  }


  /**
   * Model Column
   */

  export type AggregateColumn = {
    _count: ColumnCountAggregateOutputType | null
    _avg: ColumnAvgAggregateOutputType | null
    _sum: ColumnSumAggregateOutputType | null
    _min: ColumnMinAggregateOutputType | null
    _max: ColumnMaxAggregateOutputType | null
  }

  export type ColumnAvgAggregateOutputType = {
    order: number | null
  }

  export type ColumnSumAggregateOutputType = {
    order: number | null
  }

  export type ColumnMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    boardId: string | null
  }

  export type ColumnMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    boardId: string | null
  }

  export type ColumnCountAggregateOutputType = {
    id: number
    title: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    boardId: number
    _all: number
  }


  export type ColumnAvgAggregateInputType = {
    order?: true
  }

  export type ColumnSumAggregateInputType = {
    order?: true
  }

  export type ColumnMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    boardId?: true
  }

  export type ColumnMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    boardId?: true
  }

  export type ColumnCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    boardId?: true
    _all?: true
  }

  export type ColumnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Column to aggregate.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Columns
    **/
    _count?: true | ColumnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColumnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColumnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColumnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColumnMaxAggregateInputType
  }

  export type GetColumnAggregateType<T extends ColumnAggregateArgs> = {
        [P in keyof T & keyof AggregateColumn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColumn[P]>
      : GetScalarType<T[P], AggregateColumn[P]>
  }




  export type ColumnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColumnWhereInput
    orderBy?: ColumnOrderByWithAggregationInput | ColumnOrderByWithAggregationInput[]
    by: ColumnScalarFieldEnum[] | ColumnScalarFieldEnum
    having?: ColumnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColumnCountAggregateInputType | true
    _avg?: ColumnAvgAggregateInputType
    _sum?: ColumnSumAggregateInputType
    _min?: ColumnMinAggregateInputType
    _max?: ColumnMaxAggregateInputType
  }

  export type ColumnGroupByOutputType = {
    id: string
    title: string
    description: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    boardId: string
    _count: ColumnCountAggregateOutputType | null
    _avg: ColumnAvgAggregateOutputType | null
    _sum: ColumnSumAggregateOutputType | null
    _min: ColumnMinAggregateOutputType | null
    _max: ColumnMaxAggregateOutputType | null
  }

  type GetColumnGroupByPayload<T extends ColumnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColumnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColumnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColumnGroupByOutputType[P]>
            : GetScalarType<T[P], ColumnGroupByOutputType[P]>
        }
      >
    >


  export type ColumnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boardId?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    tasks?: boolean | Column$tasksArgs<ExtArgs>
    _count?: boolean | ColumnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boardId?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boardId?: boolean
  }

  export type ColumnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    tasks?: boolean | Column$tasksArgs<ExtArgs>
    _count?: boolean | ColumnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColumnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }

  export type $ColumnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Column"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      order: number
      createdAt: Date
      updatedAt: Date
      boardId: string
    }, ExtArgs["result"]["column"]>
    composites: {}
  }

  type ColumnGetPayload<S extends boolean | null | undefined | ColumnDefaultArgs> = $Result.GetResult<Prisma.$ColumnPayload, S>

  type ColumnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ColumnFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ColumnCountAggregateInputType | true
    }

  export interface ColumnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Column'], meta: { name: 'Column' } }
    /**
     * Find zero or one Column that matches the filter.
     * @param {ColumnFindUniqueArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColumnFindUniqueArgs>(args: SelectSubset<T, ColumnFindUniqueArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Column that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ColumnFindUniqueOrThrowArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColumnFindUniqueOrThrowArgs>(args: SelectSubset<T, ColumnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Column that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindFirstArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColumnFindFirstArgs>(args?: SelectSubset<T, ColumnFindFirstArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Column that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindFirstOrThrowArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColumnFindFirstOrThrowArgs>(args?: SelectSubset<T, ColumnFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Columns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Columns
     * const columns = await prisma.column.findMany()
     * 
     * // Get first 10 Columns
     * const columns = await prisma.column.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const columnWithIdOnly = await prisma.column.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColumnFindManyArgs>(args?: SelectSubset<T, ColumnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Column.
     * @param {ColumnCreateArgs} args - Arguments to create a Column.
     * @example
     * // Create one Column
     * const Column = await prisma.column.create({
     *   data: {
     *     // ... data to create a Column
     *   }
     * })
     * 
     */
    create<T extends ColumnCreateArgs>(args: SelectSubset<T, ColumnCreateArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Columns.
     * @param {ColumnCreateManyArgs} args - Arguments to create many Columns.
     * @example
     * // Create many Columns
     * const column = await prisma.column.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColumnCreateManyArgs>(args?: SelectSubset<T, ColumnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Columns and returns the data saved in the database.
     * @param {ColumnCreateManyAndReturnArgs} args - Arguments to create many Columns.
     * @example
     * // Create many Columns
     * const column = await prisma.column.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Columns and only return the `id`
     * const columnWithIdOnly = await prisma.column.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColumnCreateManyAndReturnArgs>(args?: SelectSubset<T, ColumnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Column.
     * @param {ColumnDeleteArgs} args - Arguments to delete one Column.
     * @example
     * // Delete one Column
     * const Column = await prisma.column.delete({
     *   where: {
     *     // ... filter to delete one Column
     *   }
     * })
     * 
     */
    delete<T extends ColumnDeleteArgs>(args: SelectSubset<T, ColumnDeleteArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Column.
     * @param {ColumnUpdateArgs} args - Arguments to update one Column.
     * @example
     * // Update one Column
     * const column = await prisma.column.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColumnUpdateArgs>(args: SelectSubset<T, ColumnUpdateArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Columns.
     * @param {ColumnDeleteManyArgs} args - Arguments to filter Columns to delete.
     * @example
     * // Delete a few Columns
     * const { count } = await prisma.column.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColumnDeleteManyArgs>(args?: SelectSubset<T, ColumnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Columns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Columns
     * const column = await prisma.column.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColumnUpdateManyArgs>(args: SelectSubset<T, ColumnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Column.
     * @param {ColumnUpsertArgs} args - Arguments to update or create a Column.
     * @example
     * // Update or create a Column
     * const column = await prisma.column.upsert({
     *   create: {
     *     // ... data to create a Column
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Column we want to update
     *   }
     * })
     */
    upsert<T extends ColumnUpsertArgs>(args: SelectSubset<T, ColumnUpsertArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Columns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnCountArgs} args - Arguments to filter Columns to count.
     * @example
     * // Count the number of Columns
     * const count = await prisma.column.count({
     *   where: {
     *     // ... the filter for the Columns we want to count
     *   }
     * })
    **/
    count<T extends ColumnCountArgs>(
      args?: Subset<T, ColumnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColumnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Column.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColumnAggregateArgs>(args: Subset<T, ColumnAggregateArgs>): Prisma.PrismaPromise<GetColumnAggregateType<T>>

    /**
     * Group by Column.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColumnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColumnGroupByArgs['orderBy'] }
        : { orderBy?: ColumnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColumnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColumnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Column model
   */
  readonly fields: ColumnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Column.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColumnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tasks<T extends Column$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Column$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Column model
   */ 
  interface ColumnFieldRefs {
    readonly id: FieldRef<"Column", 'String'>
    readonly title: FieldRef<"Column", 'String'>
    readonly description: FieldRef<"Column", 'String'>
    readonly order: FieldRef<"Column", 'Int'>
    readonly createdAt: FieldRef<"Column", 'DateTime'>
    readonly updatedAt: FieldRef<"Column", 'DateTime'>
    readonly boardId: FieldRef<"Column", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Column findUnique
   */
  export type ColumnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column findUniqueOrThrow
   */
  export type ColumnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column findFirst
   */
  export type ColumnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Columns.
     */
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column findFirstOrThrow
   */
  export type ColumnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Columns.
     */
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column findMany
   */
  export type ColumnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Columns to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column create
   */
  export type ColumnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The data needed to create a Column.
     */
    data: XOR<ColumnCreateInput, ColumnUncheckedCreateInput>
  }

  /**
   * Column createMany
   */
  export type ColumnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Columns.
     */
    data: ColumnCreateManyInput | ColumnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Column createManyAndReturn
   */
  export type ColumnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Columns.
     */
    data: ColumnCreateManyInput | ColumnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Column update
   */
  export type ColumnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The data needed to update a Column.
     */
    data: XOR<ColumnUpdateInput, ColumnUncheckedUpdateInput>
    /**
     * Choose, which Column to update.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column updateMany
   */
  export type ColumnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Columns.
     */
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyInput>
    /**
     * Filter which Columns to update
     */
    where?: ColumnWhereInput
  }

  /**
   * Column upsert
   */
  export type ColumnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The filter to search for the Column to update in case it exists.
     */
    where: ColumnWhereUniqueInput
    /**
     * In case the Column found by the `where` argument doesn't exist, create a new Column with this data.
     */
    create: XOR<ColumnCreateInput, ColumnUncheckedCreateInput>
    /**
     * In case the Column was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColumnUpdateInput, ColumnUncheckedUpdateInput>
  }

  /**
   * Column delete
   */
  export type ColumnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter which Column to delete.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column deleteMany
   */
  export type ColumnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Columns to delete
     */
    where?: ColumnWhereInput
  }

  /**
   * Column.tasks
   */
  export type Column$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Column without action
   */
  export type ColumnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    position: number | null
  }

  export type TaskSumAggregateOutputType = {
    position: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.TaskPriority | null
    dueDate: Date | null
    status: string | null
    position: number | null
    archive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    columnId: string | null
    createdById: string | null
    claimId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.TaskPriority | null
    dueDate: Date | null
    status: string | null
    position: number | null
    archive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    columnId: string | null
    createdById: string | null
    claimId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    priority: number
    dueDate: number
    status: number
    position: number
    archive: number
    createdAt: number
    updatedAt: number
    columnId: number
    createdById: number
    claimId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    position?: true
  }

  export type TaskSumAggregateInputType = {
    position?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    dueDate?: true
    status?: true
    position?: true
    archive?: true
    createdAt?: true
    updatedAt?: true
    columnId?: true
    createdById?: true
    claimId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    dueDate?: true
    status?: true
    position?: true
    archive?: true
    createdAt?: true
    updatedAt?: true
    columnId?: true
    createdById?: true
    claimId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    dueDate?: true
    status?: true
    position?: true
    archive?: true
    createdAt?: true
    updatedAt?: true
    columnId?: true
    createdById?: true
    claimId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    priority: $Enums.TaskPriority
    dueDate: Date | null
    status: string
    position: number
    archive: boolean
    createdAt: Date
    updatedAt: Date
    columnId: string
    createdById: string
    claimId: string | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    dueDate?: boolean
    status?: boolean
    position?: boolean
    archive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    columnId?: boolean
    createdById?: boolean
    claimId?: boolean
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    taskAccounts?: boolean | Task$taskAccountsArgs<ExtArgs>
    taskAssignees?: boolean | Task$taskAssigneesArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    labels?: boolean | Task$labelsArgs<ExtArgs>
    claim?: boolean | Task$claimArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    dueDate?: boolean
    status?: boolean
    position?: boolean
    archive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    columnId?: boolean
    createdById?: boolean
    claimId?: boolean
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    claim?: boolean | Task$claimArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    dueDate?: boolean
    status?: boolean
    position?: boolean
    archive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    columnId?: boolean
    createdById?: boolean
    claimId?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    taskAccounts?: boolean | Task$taskAccountsArgs<ExtArgs>
    taskAssignees?: boolean | Task$taskAssigneesArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    labels?: boolean | Task$labelsArgs<ExtArgs>
    claim?: boolean | Task$claimArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    claim?: boolean | Task$claimArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      column: Prisma.$ColumnPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      taskAccounts: Prisma.$TaskAccountPayload<ExtArgs>[]
      taskAssignees: Prisma.$TaskAssigneePayload<ExtArgs>[]
      comments: Prisma.$TaskCommentPayload<ExtArgs>[]
      attachments: Prisma.$TaskAttachmentPayload<ExtArgs>[]
      labels: Prisma.$TaskLabelPayload<ExtArgs>[]
      claim: Prisma.$ClaimPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      priority: $Enums.TaskPriority
      dueDate: Date | null
      status: string
      position: number
      archive: boolean
      createdAt: Date
      updatedAt: Date
      columnId: string
      createdById: string
      claimId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    column<T extends ColumnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ColumnDefaultArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    taskAccounts<T extends Task$taskAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "findMany"> | Null>
    taskAssignees<T extends Task$taskAssigneesArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskAssigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends Task$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    labels<T extends Task$labelsArgs<ExtArgs> = {}>(args?: Subset<T, Task$labelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany"> | Null>
    claim<T extends Task$claimArgs<ExtArgs> = {}>(args?: Subset<T, Task$claimArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'TaskPriority'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly status: FieldRef<"Task", 'String'>
    readonly position: FieldRef<"Task", 'Int'>
    readonly archive: FieldRef<"Task", 'Boolean'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly columnId: FieldRef<"Task", 'String'>
    readonly createdById: FieldRef<"Task", 'String'>
    readonly claimId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.taskAccounts
   */
  export type Task$taskAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    where?: TaskAccountWhereInput
    orderBy?: TaskAccountOrderByWithRelationInput | TaskAccountOrderByWithRelationInput[]
    cursor?: TaskAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAccountScalarFieldEnum | TaskAccountScalarFieldEnum[]
  }

  /**
   * Task.taskAssignees
   */
  export type Task$taskAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    cursor?: TaskAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    cursor?: TaskCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * Task.attachments
   */
  export type Task$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    cursor?: TaskAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * Task.labels
   */
  export type Task$labelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    cursor?: TaskLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * Task.claim
   */
  export type Task$claimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskAccount
   */

  export type AggregateTaskAccount = {
    _count: TaskAccountCountAggregateOutputType | null
    _min: TaskAccountMinAggregateOutputType | null
    _max: TaskAccountMaxAggregateOutputType | null
  }

  export type TaskAccountMinAggregateOutputType = {
    taskId: string | null
    accountId: string | null
    assignedAt: Date | null
  }

  export type TaskAccountMaxAggregateOutputType = {
    taskId: string | null
    accountId: string | null
    assignedAt: Date | null
  }

  export type TaskAccountCountAggregateOutputType = {
    taskId: number
    accountId: number
    assignedAt: number
    _all: number
  }


  export type TaskAccountMinAggregateInputType = {
    taskId?: true
    accountId?: true
    assignedAt?: true
  }

  export type TaskAccountMaxAggregateInputType = {
    taskId?: true
    accountId?: true
    assignedAt?: true
  }

  export type TaskAccountCountAggregateInputType = {
    taskId?: true
    accountId?: true
    assignedAt?: true
    _all?: true
  }

  export type TaskAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAccount to aggregate.
     */
    where?: TaskAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAccounts to fetch.
     */
    orderBy?: TaskAccountOrderByWithRelationInput | TaskAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAccounts
    **/
    _count?: true | TaskAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAccountMaxAggregateInputType
  }

  export type GetTaskAccountAggregateType<T extends TaskAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAccount[P]>
      : GetScalarType<T[P], AggregateTaskAccount[P]>
  }




  export type TaskAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAccountWhereInput
    orderBy?: TaskAccountOrderByWithAggregationInput | TaskAccountOrderByWithAggregationInput[]
    by: TaskAccountScalarFieldEnum[] | TaskAccountScalarFieldEnum
    having?: TaskAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAccountCountAggregateInputType | true
    _min?: TaskAccountMinAggregateInputType
    _max?: TaskAccountMaxAggregateInputType
  }

  export type TaskAccountGroupByOutputType = {
    taskId: string
    accountId: string
    assignedAt: Date
    _count: TaskAccountCountAggregateOutputType | null
    _min: TaskAccountMinAggregateOutputType | null
    _max: TaskAccountMaxAggregateOutputType | null
  }

  type GetTaskAccountGroupByPayload<T extends TaskAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAccountGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAccountGroupByOutputType[P]>
        }
      >
    >


  export type TaskAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    accountId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAccount"]>

  export type TaskAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    accountId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAccount"]>

  export type TaskAccountSelectScalar = {
    taskId?: boolean
    accountId?: boolean
    assignedAt?: boolean
  }

  export type TaskAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type TaskAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $TaskAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAccount"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: string
      accountId: string
      assignedAt: Date
    }, ExtArgs["result"]["taskAccount"]>
    composites: {}
  }

  type TaskAccountGetPayload<S extends boolean | null | undefined | TaskAccountDefaultArgs> = $Result.GetResult<Prisma.$TaskAccountPayload, S>

  type TaskAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskAccountCountAggregateInputType | true
    }

  export interface TaskAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAccount'], meta: { name: 'TaskAccount' } }
    /**
     * Find zero or one TaskAccount that matches the filter.
     * @param {TaskAccountFindUniqueArgs} args - Arguments to find a TaskAccount
     * @example
     * // Get one TaskAccount
     * const taskAccount = await prisma.taskAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAccountFindUniqueArgs>(args: SelectSubset<T, TaskAccountFindUniqueArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskAccountFindUniqueOrThrowArgs} args - Arguments to find a TaskAccount
     * @example
     * // Get one TaskAccount
     * const taskAccount = await prisma.taskAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAccountFindFirstArgs} args - Arguments to find a TaskAccount
     * @example
     * // Get one TaskAccount
     * const taskAccount = await prisma.taskAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAccountFindFirstArgs>(args?: SelectSubset<T, TaskAccountFindFirstArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAccountFindFirstOrThrowArgs} args - Arguments to find a TaskAccount
     * @example
     * // Get one TaskAccount
     * const taskAccount = await prisma.taskAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAccounts
     * const taskAccounts = await prisma.taskAccount.findMany()
     * 
     * // Get first 10 TaskAccounts
     * const taskAccounts = await prisma.taskAccount.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskAccountWithTaskIdOnly = await prisma.taskAccount.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskAccountFindManyArgs>(args?: SelectSubset<T, TaskAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskAccount.
     * @param {TaskAccountCreateArgs} args - Arguments to create a TaskAccount.
     * @example
     * // Create one TaskAccount
     * const TaskAccount = await prisma.taskAccount.create({
     *   data: {
     *     // ... data to create a TaskAccount
     *   }
     * })
     * 
     */
    create<T extends TaskAccountCreateArgs>(args: SelectSubset<T, TaskAccountCreateArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskAccounts.
     * @param {TaskAccountCreateManyArgs} args - Arguments to create many TaskAccounts.
     * @example
     * // Create many TaskAccounts
     * const taskAccount = await prisma.taskAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAccountCreateManyArgs>(args?: SelectSubset<T, TaskAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAccounts and returns the data saved in the database.
     * @param {TaskAccountCreateManyAndReturnArgs} args - Arguments to create many TaskAccounts.
     * @example
     * // Create many TaskAccounts
     * const taskAccount = await prisma.taskAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAccounts and only return the `taskId`
     * const taskAccountWithTaskIdOnly = await prisma.taskAccount.createManyAndReturn({ 
     *   select: { taskId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskAccount.
     * @param {TaskAccountDeleteArgs} args - Arguments to delete one TaskAccount.
     * @example
     * // Delete one TaskAccount
     * const TaskAccount = await prisma.taskAccount.delete({
     *   where: {
     *     // ... filter to delete one TaskAccount
     *   }
     * })
     * 
     */
    delete<T extends TaskAccountDeleteArgs>(args: SelectSubset<T, TaskAccountDeleteArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskAccount.
     * @param {TaskAccountUpdateArgs} args - Arguments to update one TaskAccount.
     * @example
     * // Update one TaskAccount
     * const taskAccount = await prisma.taskAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAccountUpdateArgs>(args: SelectSubset<T, TaskAccountUpdateArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskAccounts.
     * @param {TaskAccountDeleteManyArgs} args - Arguments to filter TaskAccounts to delete.
     * @example
     * // Delete a few TaskAccounts
     * const { count } = await prisma.taskAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAccountDeleteManyArgs>(args?: SelectSubset<T, TaskAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAccounts
     * const taskAccount = await prisma.taskAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAccountUpdateManyArgs>(args: SelectSubset<T, TaskAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskAccount.
     * @param {TaskAccountUpsertArgs} args - Arguments to update or create a TaskAccount.
     * @example
     * // Update or create a TaskAccount
     * const taskAccount = await prisma.taskAccount.upsert({
     *   create: {
     *     // ... data to create a TaskAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAccount we want to update
     *   }
     * })
     */
    upsert<T extends TaskAccountUpsertArgs>(args: SelectSubset<T, TaskAccountUpsertArgs<ExtArgs>>): Prisma__TaskAccountClient<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAccountCountArgs} args - Arguments to filter TaskAccounts to count.
     * @example
     * // Count the number of TaskAccounts
     * const count = await prisma.taskAccount.count({
     *   where: {
     *     // ... the filter for the TaskAccounts we want to count
     *   }
     * })
    **/
    count<T extends TaskAccountCountArgs>(
      args?: Subset<T, TaskAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAccountAggregateArgs>(args: Subset<T, TaskAccountAggregateArgs>): Prisma.PrismaPromise<GetTaskAccountAggregateType<T>>

    /**
     * Group by TaskAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAccountGroupByArgs['orderBy'] }
        : { orderBy?: TaskAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAccount model
   */
  readonly fields: TaskAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAccount model
   */ 
  interface TaskAccountFieldRefs {
    readonly taskId: FieldRef<"TaskAccount", 'String'>
    readonly accountId: FieldRef<"TaskAccount", 'String'>
    readonly assignedAt: FieldRef<"TaskAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAccount findUnique
   */
  export type TaskAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * Filter, which TaskAccount to fetch.
     */
    where: TaskAccountWhereUniqueInput
  }

  /**
   * TaskAccount findUniqueOrThrow
   */
  export type TaskAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * Filter, which TaskAccount to fetch.
     */
    where: TaskAccountWhereUniqueInput
  }

  /**
   * TaskAccount findFirst
   */
  export type TaskAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * Filter, which TaskAccount to fetch.
     */
    where?: TaskAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAccounts to fetch.
     */
    orderBy?: TaskAccountOrderByWithRelationInput | TaskAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAccounts.
     */
    cursor?: TaskAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAccounts.
     */
    distinct?: TaskAccountScalarFieldEnum | TaskAccountScalarFieldEnum[]
  }

  /**
   * TaskAccount findFirstOrThrow
   */
  export type TaskAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * Filter, which TaskAccount to fetch.
     */
    where?: TaskAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAccounts to fetch.
     */
    orderBy?: TaskAccountOrderByWithRelationInput | TaskAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAccounts.
     */
    cursor?: TaskAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAccounts.
     */
    distinct?: TaskAccountScalarFieldEnum | TaskAccountScalarFieldEnum[]
  }

  /**
   * TaskAccount findMany
   */
  export type TaskAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * Filter, which TaskAccounts to fetch.
     */
    where?: TaskAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAccounts to fetch.
     */
    orderBy?: TaskAccountOrderByWithRelationInput | TaskAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAccounts.
     */
    cursor?: TaskAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAccounts.
     */
    skip?: number
    distinct?: TaskAccountScalarFieldEnum | TaskAccountScalarFieldEnum[]
  }

  /**
   * TaskAccount create
   */
  export type TaskAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAccount.
     */
    data: XOR<TaskAccountCreateInput, TaskAccountUncheckedCreateInput>
  }

  /**
   * TaskAccount createMany
   */
  export type TaskAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAccounts.
     */
    data: TaskAccountCreateManyInput | TaskAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAccount createManyAndReturn
   */
  export type TaskAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskAccounts.
     */
    data: TaskAccountCreateManyInput | TaskAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAccount update
   */
  export type TaskAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAccount.
     */
    data: XOR<TaskAccountUpdateInput, TaskAccountUncheckedUpdateInput>
    /**
     * Choose, which TaskAccount to update.
     */
    where: TaskAccountWhereUniqueInput
  }

  /**
   * TaskAccount updateMany
   */
  export type TaskAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAccounts.
     */
    data: XOR<TaskAccountUpdateManyMutationInput, TaskAccountUncheckedUpdateManyInput>
    /**
     * Filter which TaskAccounts to update
     */
    where?: TaskAccountWhereInput
  }

  /**
   * TaskAccount upsert
   */
  export type TaskAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAccount to update in case it exists.
     */
    where: TaskAccountWhereUniqueInput
    /**
     * In case the TaskAccount found by the `where` argument doesn't exist, create a new TaskAccount with this data.
     */
    create: XOR<TaskAccountCreateInput, TaskAccountUncheckedCreateInput>
    /**
     * In case the TaskAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAccountUpdateInput, TaskAccountUncheckedUpdateInput>
  }

  /**
   * TaskAccount delete
   */
  export type TaskAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    /**
     * Filter which TaskAccount to delete.
     */
    where: TaskAccountWhereUniqueInput
  }

  /**
   * TaskAccount deleteMany
   */
  export type TaskAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAccounts to delete
     */
    where?: TaskAccountWhereInput
  }

  /**
   * TaskAccount without action
   */
  export type TaskAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignee
   */

  export type AggregateTaskAssignee = {
    _count: TaskAssigneeCountAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  export type TaskAssigneeMinAggregateOutputType = {
    taskId: string | null
    userId: string | null
    assignedAt: Date | null
  }

  export type TaskAssigneeMaxAggregateOutputType = {
    taskId: string | null
    userId: string | null
    assignedAt: Date | null
  }

  export type TaskAssigneeCountAggregateOutputType = {
    taskId: number
    userId: number
    assignedAt: number
    _all: number
  }


  export type TaskAssigneeMinAggregateInputType = {
    taskId?: true
    userId?: true
    assignedAt?: true
  }

  export type TaskAssigneeMaxAggregateInputType = {
    taskId?: true
    userId?: true
    assignedAt?: true
  }

  export type TaskAssigneeCountAggregateInputType = {
    taskId?: true
    userId?: true
    assignedAt?: true
    _all?: true
  }

  export type TaskAssigneeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignee to aggregate.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignees
    **/
    _count?: true | TaskAssigneeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssigneeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type GetTaskAssigneeAggregateType<T extends TaskAssigneeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignee[P]>
      : GetScalarType<T[P], AggregateTaskAssignee[P]>
  }




  export type TaskAssigneeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithAggregationInput | TaskAssigneeOrderByWithAggregationInput[]
    by: TaskAssigneeScalarFieldEnum[] | TaskAssigneeScalarFieldEnum
    having?: TaskAssigneeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssigneeCountAggregateInputType | true
    _min?: TaskAssigneeMinAggregateInputType
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type TaskAssigneeGroupByOutputType = {
    taskId: string
    userId: string
    assignedAt: Date
    _count: TaskAssigneeCountAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  type GetTaskAssigneeGroupByPayload<T extends TaskAssigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssigneeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssigneeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssigneeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    userId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    userId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectScalar = {
    taskId?: boolean
    userId?: boolean
    assignedAt?: boolean
  }

  export type TaskAssigneeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAssigneeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskAssigneePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignee"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: string
      userId: string
      assignedAt: Date
    }, ExtArgs["result"]["taskAssignee"]>
    composites: {}
  }

  type TaskAssigneeGetPayload<S extends boolean | null | undefined | TaskAssigneeDefaultArgs> = $Result.GetResult<Prisma.$TaskAssigneePayload, S>

  type TaskAssigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskAssigneeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskAssigneeCountAggregateInputType | true
    }

  export interface TaskAssigneeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignee'], meta: { name: 'TaskAssignee' } }
    /**
     * Find zero or one TaskAssignee that matches the filter.
     * @param {TaskAssigneeFindUniqueArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssigneeFindUniqueArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskAssignee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskAssigneeFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssigneeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskAssignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssigneeFindFirstArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskAssignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssigneeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskAssignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany()
     * 
     * // Get first 10 TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskAssigneeWithTaskIdOnly = await prisma.taskAssignee.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskAssigneeFindManyArgs>(args?: SelectSubset<T, TaskAssigneeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskAssignee.
     * @param {TaskAssigneeCreateArgs} args - Arguments to create a TaskAssignee.
     * @example
     * // Create one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.create({
     *   data: {
     *     // ... data to create a TaskAssignee
     *   }
     * })
     * 
     */
    create<T extends TaskAssigneeCreateArgs>(args: SelectSubset<T, TaskAssigneeCreateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskAssignees.
     * @param {TaskAssigneeCreateManyArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssigneeCreateManyArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignees and returns the data saved in the database.
     * @param {TaskAssigneeCreateManyAndReturnArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignees and only return the `taskId`
     * const taskAssigneeWithTaskIdOnly = await prisma.taskAssignee.createManyAndReturn({ 
     *   select: { taskId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssigneeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskAssignee.
     * @param {TaskAssigneeDeleteArgs} args - Arguments to delete one TaskAssignee.
     * @example
     * // Delete one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignee
     *   }
     * })
     * 
     */
    delete<T extends TaskAssigneeDeleteArgs>(args: SelectSubset<T, TaskAssigneeDeleteArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskAssignee.
     * @param {TaskAssigneeUpdateArgs} args - Arguments to update one TaskAssignee.
     * @example
     * // Update one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssigneeUpdateArgs>(args: SelectSubset<T, TaskAssigneeUpdateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskAssignees.
     * @param {TaskAssigneeDeleteManyArgs} args - Arguments to filter TaskAssignees to delete.
     * @example
     * // Delete a few TaskAssignees
     * const { count } = await prisma.taskAssignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssigneeDeleteManyArgs>(args?: SelectSubset<T, TaskAssigneeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssigneeUpdateManyArgs>(args: SelectSubset<T, TaskAssigneeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskAssignee.
     * @param {TaskAssigneeUpsertArgs} args - Arguments to update or create a TaskAssignee.
     * @example
     * // Update or create a TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.upsert({
     *   create: {
     *     // ... data to create a TaskAssignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignee we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssigneeUpsertArgs>(args: SelectSubset<T, TaskAssigneeUpsertArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeCountArgs} args - Arguments to filter TaskAssignees to count.
     * @example
     * // Count the number of TaskAssignees
     * const count = await prisma.taskAssignee.count({
     *   where: {
     *     // ... the filter for the TaskAssignees we want to count
     *   }
     * })
    **/
    count<T extends TaskAssigneeCountArgs>(
      args?: Subset<T, TaskAssigneeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssigneeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssigneeAggregateArgs>(args: Subset<T, TaskAssigneeAggregateArgs>): Prisma.PrismaPromise<GetTaskAssigneeAggregateType<T>>

    /**
     * Group by TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssigneeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssigneeGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssigneeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssigneeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignee model
   */
  readonly fields: TaskAssigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssigneeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignee model
   */ 
  interface TaskAssigneeFieldRefs {
    readonly taskId: FieldRef<"TaskAssignee", 'String'>
    readonly userId: FieldRef<"TaskAssignee", 'String'>
    readonly assignedAt: FieldRef<"TaskAssignee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignee findUnique
   */
  export type TaskAssigneeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findUniqueOrThrow
   */
  export type TaskAssigneeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findFirst
   */
  export type TaskAssigneeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findFirstOrThrow
   */
  export type TaskAssigneeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findMany
   */
  export type TaskAssigneeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignees to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee create
   */
  export type TaskAssigneeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignee.
     */
    data: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
  }

  /**
   * TaskAssignee createMany
   */
  export type TaskAssigneeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignee createManyAndReturn
   */
  export type TaskAssigneeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignee update
   */
  export type TaskAssigneeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignee.
     */
    data: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignee to update.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee updateMany
   */
  export type TaskAssigneeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput
  }

  /**
   * TaskAssignee upsert
   */
  export type TaskAssigneeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignee to update in case it exists.
     */
    where: TaskAssigneeWhereUniqueInput
    /**
     * In case the TaskAssignee found by the `where` argument doesn't exist, create a new TaskAssignee with this data.
     */
    create: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
    /**
     * In case the TaskAssignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
  }

  /**
   * TaskAssignee delete
   */
  export type TaskAssigneeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignee to delete.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee deleteMany
   */
  export type TaskAssigneeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignees to delete
     */
    where?: TaskAssigneeWhereInput
  }

  /**
   * TaskAssignee without action
   */
  export type TaskAssigneeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
  }


  /**
   * Model TaskComment
   */

  export type AggregateTaskComment = {
    _count: TaskCommentCountAggregateOutputType | null
    _min: TaskCommentMinAggregateOutputType | null
    _max: TaskCommentMaxAggregateOutputType | null
  }

  export type TaskCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    taskId: string | null
    userId: string | null
  }

  export type TaskCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    taskId: string | null
    userId: string | null
  }

  export type TaskCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    taskId: number
    userId: number
    _all: number
  }


  export type TaskCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
    userId?: true
  }

  export type TaskCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
    userId?: true
  }

  export type TaskCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
    userId?: true
    _all?: true
  }

  export type TaskCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskComment to aggregate.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskComments
    **/
    _count?: true | TaskCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCommentMaxAggregateInputType
  }

  export type GetTaskCommentAggregateType<T extends TaskCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskComment[P]>
      : GetScalarType<T[P], AggregateTaskComment[P]>
  }




  export type TaskCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithAggregationInput | TaskCommentOrderByWithAggregationInput[]
    by: TaskCommentScalarFieldEnum[] | TaskCommentScalarFieldEnum
    having?: TaskCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCommentCountAggregateInputType | true
    _min?: TaskCommentMinAggregateInputType
    _max?: TaskCommentMaxAggregateInputType
  }

  export type TaskCommentGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    taskId: string
    userId: string
    _count: TaskCommentCountAggregateOutputType | null
    _min: TaskCommentMinAggregateOutputType | null
    _max: TaskCommentMaxAggregateOutputType | null
  }

  type GetTaskCommentGroupByPayload<T extends TaskCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCommentGroupByOutputType[P]>
        }
      >
    >


  export type TaskCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskComment"]>

  export type TaskCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskComment"]>

  export type TaskCommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    userId?: boolean
  }

  export type TaskCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskComment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      taskId: string
      userId: string
    }, ExtArgs["result"]["taskComment"]>
    composites: {}
  }

  type TaskCommentGetPayload<S extends boolean | null | undefined | TaskCommentDefaultArgs> = $Result.GetResult<Prisma.$TaskCommentPayload, S>

  type TaskCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCommentCountAggregateInputType | true
    }

  export interface TaskCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskComment'], meta: { name: 'TaskComment' } }
    /**
     * Find zero or one TaskComment that matches the filter.
     * @param {TaskCommentFindUniqueArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCommentFindUniqueArgs>(args: SelectSubset<T, TaskCommentFindUniqueArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskCommentFindUniqueOrThrowArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindFirstArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCommentFindFirstArgs>(args?: SelectSubset<T, TaskCommentFindFirstArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindFirstOrThrowArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskComments
     * const taskComments = await prisma.taskComment.findMany()
     * 
     * // Get first 10 TaskComments
     * const taskComments = await prisma.taskComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCommentWithIdOnly = await prisma.taskComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCommentFindManyArgs>(args?: SelectSubset<T, TaskCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskComment.
     * @param {TaskCommentCreateArgs} args - Arguments to create a TaskComment.
     * @example
     * // Create one TaskComment
     * const TaskComment = await prisma.taskComment.create({
     *   data: {
     *     // ... data to create a TaskComment
     *   }
     * })
     * 
     */
    create<T extends TaskCommentCreateArgs>(args: SelectSubset<T, TaskCommentCreateArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskComments.
     * @param {TaskCommentCreateManyArgs} args - Arguments to create many TaskComments.
     * @example
     * // Create many TaskComments
     * const taskComment = await prisma.taskComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCommentCreateManyArgs>(args?: SelectSubset<T, TaskCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskComments and returns the data saved in the database.
     * @param {TaskCommentCreateManyAndReturnArgs} args - Arguments to create many TaskComments.
     * @example
     * // Create many TaskComments
     * const taskComment = await prisma.taskComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskComments and only return the `id`
     * const taskCommentWithIdOnly = await prisma.taskComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskComment.
     * @param {TaskCommentDeleteArgs} args - Arguments to delete one TaskComment.
     * @example
     * // Delete one TaskComment
     * const TaskComment = await prisma.taskComment.delete({
     *   where: {
     *     // ... filter to delete one TaskComment
     *   }
     * })
     * 
     */
    delete<T extends TaskCommentDeleteArgs>(args: SelectSubset<T, TaskCommentDeleteArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskComment.
     * @param {TaskCommentUpdateArgs} args - Arguments to update one TaskComment.
     * @example
     * // Update one TaskComment
     * const taskComment = await prisma.taskComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCommentUpdateArgs>(args: SelectSubset<T, TaskCommentUpdateArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskComments.
     * @param {TaskCommentDeleteManyArgs} args - Arguments to filter TaskComments to delete.
     * @example
     * // Delete a few TaskComments
     * const { count } = await prisma.taskComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCommentDeleteManyArgs>(args?: SelectSubset<T, TaskCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskComments
     * const taskComment = await prisma.taskComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCommentUpdateManyArgs>(args: SelectSubset<T, TaskCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskComment.
     * @param {TaskCommentUpsertArgs} args - Arguments to update or create a TaskComment.
     * @example
     * // Update or create a TaskComment
     * const taskComment = await prisma.taskComment.upsert({
     *   create: {
     *     // ... data to create a TaskComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskComment we want to update
     *   }
     * })
     */
    upsert<T extends TaskCommentUpsertArgs>(args: SelectSubset<T, TaskCommentUpsertArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentCountArgs} args - Arguments to filter TaskComments to count.
     * @example
     * // Count the number of TaskComments
     * const count = await prisma.taskComment.count({
     *   where: {
     *     // ... the filter for the TaskComments we want to count
     *   }
     * })
    **/
    count<T extends TaskCommentCountArgs>(
      args?: Subset<T, TaskCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCommentAggregateArgs>(args: Subset<T, TaskCommentAggregateArgs>): Prisma.PrismaPromise<GetTaskCommentAggregateType<T>>

    /**
     * Group by TaskComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCommentGroupByArgs['orderBy'] }
        : { orderBy?: TaskCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskComment model
   */
  readonly fields: TaskCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskComment model
   */ 
  interface TaskCommentFieldRefs {
    readonly id: FieldRef<"TaskComment", 'String'>
    readonly content: FieldRef<"TaskComment", 'String'>
    readonly createdAt: FieldRef<"TaskComment", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskComment", 'DateTime'>
    readonly taskId: FieldRef<"TaskComment", 'String'>
    readonly userId: FieldRef<"TaskComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskComment findUnique
   */
  export type TaskCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment findUniqueOrThrow
   */
  export type TaskCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment findFirst
   */
  export type TaskCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskComments.
     */
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment findFirstOrThrow
   */
  export type TaskCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskComments.
     */
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment findMany
   */
  export type TaskCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComments to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment create
   */
  export type TaskCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskComment.
     */
    data: XOR<TaskCommentCreateInput, TaskCommentUncheckedCreateInput>
  }

  /**
   * TaskComment createMany
   */
  export type TaskCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskComments.
     */
    data: TaskCommentCreateManyInput | TaskCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskComment createManyAndReturn
   */
  export type TaskCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskComments.
     */
    data: TaskCommentCreateManyInput | TaskCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskComment update
   */
  export type TaskCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskComment.
     */
    data: XOR<TaskCommentUpdateInput, TaskCommentUncheckedUpdateInput>
    /**
     * Choose, which TaskComment to update.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment updateMany
   */
  export type TaskCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskComments.
     */
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyInput>
    /**
     * Filter which TaskComments to update
     */
    where?: TaskCommentWhereInput
  }

  /**
   * TaskComment upsert
   */
  export type TaskCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskComment to update in case it exists.
     */
    where: TaskCommentWhereUniqueInput
    /**
     * In case the TaskComment found by the `where` argument doesn't exist, create a new TaskComment with this data.
     */
    create: XOR<TaskCommentCreateInput, TaskCommentUncheckedCreateInput>
    /**
     * In case the TaskComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCommentUpdateInput, TaskCommentUncheckedUpdateInput>
  }

  /**
   * TaskComment delete
   */
  export type TaskCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter which TaskComment to delete.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment deleteMany
   */
  export type TaskCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskComments to delete
     */
    where?: TaskCommentWhereInput
  }

  /**
   * TaskComment without action
   */
  export type TaskCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
  }


  /**
   * Model TaskAttachment
   */

  export type AggregateTaskAttachment = {
    _count: TaskAttachmentCountAggregateOutputType | null
    _avg: TaskAttachmentAvgAggregateOutputType | null
    _sum: TaskAttachmentSumAggregateOutputType | null
    _min: TaskAttachmentMinAggregateOutputType | null
    _max: TaskAttachmentMaxAggregateOutputType | null
  }

  export type TaskAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type TaskAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type TaskAttachmentMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    originalName: string | null
    s3Key: string | null
    s3Bucket: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
    isPublic: boolean | null
    etag: string | null
    checksum: string | null
    taskId: string | null
    uploadedById: string | null
  }

  export type TaskAttachmentMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    originalName: string | null
    s3Key: string | null
    s3Bucket: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
    isPublic: boolean | null
    etag: string | null
    checksum: string | null
    taskId: string | null
    uploadedById: string | null
  }

  export type TaskAttachmentCountAggregateOutputType = {
    id: number
    fileName: number
    originalName: number
    s3Key: number
    s3Bucket: number
    fileSize: number
    mimeType: number
    uploadedAt: number
    isPublic: number
    etag: number
    checksum: number
    taskId: number
    uploadedById: number
    _all: number
  }


  export type TaskAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type TaskAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type TaskAttachmentMinAggregateInputType = {
    id?: true
    fileName?: true
    originalName?: true
    s3Key?: true
    s3Bucket?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    isPublic?: true
    etag?: true
    checksum?: true
    taskId?: true
    uploadedById?: true
  }

  export type TaskAttachmentMaxAggregateInputType = {
    id?: true
    fileName?: true
    originalName?: true
    s3Key?: true
    s3Bucket?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    isPublic?: true
    etag?: true
    checksum?: true
    taskId?: true
    uploadedById?: true
  }

  export type TaskAttachmentCountAggregateInputType = {
    id?: true
    fileName?: true
    originalName?: true
    s3Key?: true
    s3Bucket?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    isPublic?: true
    etag?: true
    checksum?: true
    taskId?: true
    uploadedById?: true
    _all?: true
  }

  export type TaskAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAttachment to aggregate.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAttachments
    **/
    _count?: true | TaskAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAttachmentMaxAggregateInputType
  }

  export type GetTaskAttachmentAggregateType<T extends TaskAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAttachment[P]>
      : GetScalarType<T[P], AggregateTaskAttachment[P]>
  }




  export type TaskAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithAggregationInput | TaskAttachmentOrderByWithAggregationInput[]
    by: TaskAttachmentScalarFieldEnum[] | TaskAttachmentScalarFieldEnum
    having?: TaskAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAttachmentCountAggregateInputType | true
    _avg?: TaskAttachmentAvgAggregateInputType
    _sum?: TaskAttachmentSumAggregateInputType
    _min?: TaskAttachmentMinAggregateInputType
    _max?: TaskAttachmentMaxAggregateInputType
  }

  export type TaskAttachmentGroupByOutputType = {
    id: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt: Date
    isPublic: boolean
    etag: string | null
    checksum: string | null
    taskId: string
    uploadedById: string
    _count: TaskAttachmentCountAggregateOutputType | null
    _avg: TaskAttachmentAvgAggregateOutputType | null
    _sum: TaskAttachmentSumAggregateOutputType | null
    _min: TaskAttachmentMinAggregateOutputType | null
    _max: TaskAttachmentMaxAggregateOutputType | null
  }

  type GetTaskAttachmentGroupByPayload<T extends TaskAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    originalName?: boolean
    s3Key?: boolean
    s3Bucket?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    isPublic?: boolean
    etag?: boolean
    checksum?: boolean
    taskId?: boolean
    uploadedById?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    originalName?: boolean
    s3Key?: boolean
    s3Bucket?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    isPublic?: boolean
    etag?: boolean
    checksum?: boolean
    taskId?: boolean
    uploadedById?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectScalar = {
    id?: boolean
    fileName?: boolean
    originalName?: boolean
    s3Key?: boolean
    s3Bucket?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    isPublic?: boolean
    etag?: boolean
    checksum?: boolean
    taskId?: boolean
    uploadedById?: boolean
  }

  export type TaskAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAttachment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      originalName: string
      s3Key: string
      s3Bucket: string
      fileSize: number
      mimeType: string
      uploadedAt: Date
      isPublic: boolean
      etag: string | null
      checksum: string | null
      taskId: string
      uploadedById: string
    }, ExtArgs["result"]["taskAttachment"]>
    composites: {}
  }

  type TaskAttachmentGetPayload<S extends boolean | null | undefined | TaskAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAttachmentPayload, S>

  type TaskAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskAttachmentCountAggregateInputType | true
    }

  export interface TaskAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAttachment'], meta: { name: 'TaskAttachment' } }
    /**
     * Find zero or one TaskAttachment that matches the filter.
     * @param {TaskAttachmentFindUniqueArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAttachmentFindUniqueArgs>(args: SelectSubset<T, TaskAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAttachmentFindFirstArgs>(args?: SelectSubset<T, TaskAttachmentFindFirstArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany()
     * 
     * // Get first 10 TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAttachmentFindManyArgs>(args?: SelectSubset<T, TaskAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskAttachment.
     * @param {TaskAttachmentCreateArgs} args - Arguments to create a TaskAttachment.
     * @example
     * // Create one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.create({
     *   data: {
     *     // ... data to create a TaskAttachment
     *   }
     * })
     * 
     */
    create<T extends TaskAttachmentCreateArgs>(args: SelectSubset<T, TaskAttachmentCreateArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskAttachments.
     * @param {TaskAttachmentCreateManyArgs} args - Arguments to create many TaskAttachments.
     * @example
     * // Create many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAttachmentCreateManyArgs>(args?: SelectSubset<T, TaskAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAttachments and returns the data saved in the database.
     * @param {TaskAttachmentCreateManyAndReturnArgs} args - Arguments to create many TaskAttachments.
     * @example
     * // Create many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAttachments and only return the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskAttachment.
     * @param {TaskAttachmentDeleteArgs} args - Arguments to delete one TaskAttachment.
     * @example
     * // Delete one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.delete({
     *   where: {
     *     // ... filter to delete one TaskAttachment
     *   }
     * })
     * 
     */
    delete<T extends TaskAttachmentDeleteArgs>(args: SelectSubset<T, TaskAttachmentDeleteArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskAttachment.
     * @param {TaskAttachmentUpdateArgs} args - Arguments to update one TaskAttachment.
     * @example
     * // Update one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAttachmentUpdateArgs>(args: SelectSubset<T, TaskAttachmentUpdateArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskAttachments.
     * @param {TaskAttachmentDeleteManyArgs} args - Arguments to filter TaskAttachments to delete.
     * @example
     * // Delete a few TaskAttachments
     * const { count } = await prisma.taskAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAttachmentDeleteManyArgs>(args?: SelectSubset<T, TaskAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAttachmentUpdateManyArgs>(args: SelectSubset<T, TaskAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskAttachment.
     * @param {TaskAttachmentUpsertArgs} args - Arguments to update or create a TaskAttachment.
     * @example
     * // Update or create a TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.upsert({
     *   create: {
     *     // ... data to create a TaskAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAttachmentUpsertArgs>(args: SelectSubset<T, TaskAttachmentUpsertArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentCountArgs} args - Arguments to filter TaskAttachments to count.
     * @example
     * // Count the number of TaskAttachments
     * const count = await prisma.taskAttachment.count({
     *   where: {
     *     // ... the filter for the TaskAttachments we want to count
     *   }
     * })
    **/
    count<T extends TaskAttachmentCountArgs>(
      args?: Subset<T, TaskAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAttachmentAggregateArgs>(args: Subset<T, TaskAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAttachmentAggregateType<T>>

    /**
     * Group by TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAttachment model
   */
  readonly fields: TaskAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAttachment model
   */ 
  interface TaskAttachmentFieldRefs {
    readonly id: FieldRef<"TaskAttachment", 'String'>
    readonly fileName: FieldRef<"TaskAttachment", 'String'>
    readonly originalName: FieldRef<"TaskAttachment", 'String'>
    readonly s3Key: FieldRef<"TaskAttachment", 'String'>
    readonly s3Bucket: FieldRef<"TaskAttachment", 'String'>
    readonly fileSize: FieldRef<"TaskAttachment", 'Int'>
    readonly mimeType: FieldRef<"TaskAttachment", 'String'>
    readonly uploadedAt: FieldRef<"TaskAttachment", 'DateTime'>
    readonly isPublic: FieldRef<"TaskAttachment", 'Boolean'>
    readonly etag: FieldRef<"TaskAttachment", 'String'>
    readonly checksum: FieldRef<"TaskAttachment", 'String'>
    readonly taskId: FieldRef<"TaskAttachment", 'String'>
    readonly uploadedById: FieldRef<"TaskAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskAttachment findUnique
   */
  export type TaskAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment findUniqueOrThrow
   */
  export type TaskAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment findFirst
   */
  export type TaskAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment findFirstOrThrow
   */
  export type TaskAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment findMany
   */
  export type TaskAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachments to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment create
   */
  export type TaskAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAttachment.
     */
    data: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>
  }

  /**
   * TaskAttachment createMany
   */
  export type TaskAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAttachments.
     */
    data: TaskAttachmentCreateManyInput | TaskAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAttachment createManyAndReturn
   */
  export type TaskAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskAttachments.
     */
    data: TaskAttachmentCreateManyInput | TaskAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAttachment update
   */
  export type TaskAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAttachment.
     */
    data: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAttachment to update.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment updateMany
   */
  export type TaskAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAttachments.
     */
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAttachments to update
     */
    where?: TaskAttachmentWhereInput
  }

  /**
   * TaskAttachment upsert
   */
  export type TaskAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAttachment to update in case it exists.
     */
    where: TaskAttachmentWhereUniqueInput
    /**
     * In case the TaskAttachment found by the `where` argument doesn't exist, create a new TaskAttachment with this data.
     */
    create: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>
    /**
     * In case the TaskAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>
  }

  /**
   * TaskAttachment delete
   */
  export type TaskAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAttachment to delete.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment deleteMany
   */
  export type TaskAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAttachments to delete
     */
    where?: TaskAttachmentWhereInput
  }

  /**
   * TaskAttachment without action
   */
  export type TaskAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TaskLabel
   */

  export type AggregateTaskLabel = {
    _count: TaskLabelCountAggregateOutputType | null
    _min: TaskLabelMinAggregateOutputType | null
    _max: TaskLabelMaxAggregateOutputType | null
  }

  export type TaskLabelMinAggregateOutputType = {
    taskId: string | null
    labelId: string | null
    assignedAt: Date | null
  }

  export type TaskLabelMaxAggregateOutputType = {
    taskId: string | null
    labelId: string | null
    assignedAt: Date | null
  }

  export type TaskLabelCountAggregateOutputType = {
    taskId: number
    labelId: number
    assignedAt: number
    _all: number
  }


  export type TaskLabelMinAggregateInputType = {
    taskId?: true
    labelId?: true
    assignedAt?: true
  }

  export type TaskLabelMaxAggregateInputType = {
    taskId?: true
    labelId?: true
    assignedAt?: true
  }

  export type TaskLabelCountAggregateInputType = {
    taskId?: true
    labelId?: true
    assignedAt?: true
    _all?: true
  }

  export type TaskLabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLabel to aggregate.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskLabels
    **/
    _count?: true | TaskLabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskLabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskLabelMaxAggregateInputType
  }

  export type GetTaskLabelAggregateType<T extends TaskLabelAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskLabel[P]>
      : GetScalarType<T[P], AggregateTaskLabel[P]>
  }




  export type TaskLabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithAggregationInput | TaskLabelOrderByWithAggregationInput[]
    by: TaskLabelScalarFieldEnum[] | TaskLabelScalarFieldEnum
    having?: TaskLabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskLabelCountAggregateInputType | true
    _min?: TaskLabelMinAggregateInputType
    _max?: TaskLabelMaxAggregateInputType
  }

  export type TaskLabelGroupByOutputType = {
    taskId: string
    labelId: string
    assignedAt: Date
    _count: TaskLabelCountAggregateOutputType | null
    _min: TaskLabelMinAggregateOutputType | null
    _max: TaskLabelMaxAggregateOutputType | null
  }

  type GetTaskLabelGroupByPayload<T extends TaskLabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskLabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskLabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskLabelGroupByOutputType[P]>
            : GetScalarType<T[P], TaskLabelGroupByOutputType[P]>
        }
      >
    >


  export type TaskLabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    labelId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLabel"]>

  export type TaskLabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    labelId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLabel"]>

  export type TaskLabelSelectScalar = {
    taskId?: boolean
    labelId?: boolean
    assignedAt?: boolean
  }

  export type TaskLabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }
  export type TaskLabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }

  export type $TaskLabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskLabel"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      label: Prisma.$LabelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: string
      labelId: string
      assignedAt: Date
    }, ExtArgs["result"]["taskLabel"]>
    composites: {}
  }

  type TaskLabelGetPayload<S extends boolean | null | undefined | TaskLabelDefaultArgs> = $Result.GetResult<Prisma.$TaskLabelPayload, S>

  type TaskLabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskLabelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskLabelCountAggregateInputType | true
    }

  export interface TaskLabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskLabel'], meta: { name: 'TaskLabel' } }
    /**
     * Find zero or one TaskLabel that matches the filter.
     * @param {TaskLabelFindUniqueArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskLabelFindUniqueArgs>(args: SelectSubset<T, TaskLabelFindUniqueArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskLabel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskLabelFindUniqueOrThrowArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskLabelFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskLabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskLabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindFirstArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskLabelFindFirstArgs>(args?: SelectSubset<T, TaskLabelFindFirstArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskLabel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindFirstOrThrowArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskLabelFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskLabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskLabels
     * const taskLabels = await prisma.taskLabel.findMany()
     * 
     * // Get first 10 TaskLabels
     * const taskLabels = await prisma.taskLabel.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskLabelWithTaskIdOnly = await prisma.taskLabel.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskLabelFindManyArgs>(args?: SelectSubset<T, TaskLabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskLabel.
     * @param {TaskLabelCreateArgs} args - Arguments to create a TaskLabel.
     * @example
     * // Create one TaskLabel
     * const TaskLabel = await prisma.taskLabel.create({
     *   data: {
     *     // ... data to create a TaskLabel
     *   }
     * })
     * 
     */
    create<T extends TaskLabelCreateArgs>(args: SelectSubset<T, TaskLabelCreateArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskLabels.
     * @param {TaskLabelCreateManyArgs} args - Arguments to create many TaskLabels.
     * @example
     * // Create many TaskLabels
     * const taskLabel = await prisma.taskLabel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskLabelCreateManyArgs>(args?: SelectSubset<T, TaskLabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskLabels and returns the data saved in the database.
     * @param {TaskLabelCreateManyAndReturnArgs} args - Arguments to create many TaskLabels.
     * @example
     * // Create many TaskLabels
     * const taskLabel = await prisma.taskLabel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskLabels and only return the `taskId`
     * const taskLabelWithTaskIdOnly = await prisma.taskLabel.createManyAndReturn({ 
     *   select: { taskId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskLabelCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskLabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskLabel.
     * @param {TaskLabelDeleteArgs} args - Arguments to delete one TaskLabel.
     * @example
     * // Delete one TaskLabel
     * const TaskLabel = await prisma.taskLabel.delete({
     *   where: {
     *     // ... filter to delete one TaskLabel
     *   }
     * })
     * 
     */
    delete<T extends TaskLabelDeleteArgs>(args: SelectSubset<T, TaskLabelDeleteArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskLabel.
     * @param {TaskLabelUpdateArgs} args - Arguments to update one TaskLabel.
     * @example
     * // Update one TaskLabel
     * const taskLabel = await prisma.taskLabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskLabelUpdateArgs>(args: SelectSubset<T, TaskLabelUpdateArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskLabels.
     * @param {TaskLabelDeleteManyArgs} args - Arguments to filter TaskLabels to delete.
     * @example
     * // Delete a few TaskLabels
     * const { count } = await prisma.taskLabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskLabelDeleteManyArgs>(args?: SelectSubset<T, TaskLabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskLabels
     * const taskLabel = await prisma.taskLabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskLabelUpdateManyArgs>(args: SelectSubset<T, TaskLabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskLabel.
     * @param {TaskLabelUpsertArgs} args - Arguments to update or create a TaskLabel.
     * @example
     * // Update or create a TaskLabel
     * const taskLabel = await prisma.taskLabel.upsert({
     *   create: {
     *     // ... data to create a TaskLabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskLabel we want to update
     *   }
     * })
     */
    upsert<T extends TaskLabelUpsertArgs>(args: SelectSubset<T, TaskLabelUpsertArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelCountArgs} args - Arguments to filter TaskLabels to count.
     * @example
     * // Count the number of TaskLabels
     * const count = await prisma.taskLabel.count({
     *   where: {
     *     // ... the filter for the TaskLabels we want to count
     *   }
     * })
    **/
    count<T extends TaskLabelCountArgs>(
      args?: Subset<T, TaskLabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskLabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskLabelAggregateArgs>(args: Subset<T, TaskLabelAggregateArgs>): Prisma.PrismaPromise<GetTaskLabelAggregateType<T>>

    /**
     * Group by TaskLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskLabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskLabelGroupByArgs['orderBy'] }
        : { orderBy?: TaskLabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskLabel model
   */
  readonly fields: TaskLabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskLabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskLabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    label<T extends LabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabelDefaultArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskLabel model
   */ 
  interface TaskLabelFieldRefs {
    readonly taskId: FieldRef<"TaskLabel", 'String'>
    readonly labelId: FieldRef<"TaskLabel", 'String'>
    readonly assignedAt: FieldRef<"TaskLabel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskLabel findUnique
   */
  export type TaskLabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel findUniqueOrThrow
   */
  export type TaskLabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel findFirst
   */
  export type TaskLabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLabels.
     */
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel findFirstOrThrow
   */
  export type TaskLabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLabels.
     */
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel findMany
   */
  export type TaskLabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabels to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel create
   */
  export type TaskLabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskLabel.
     */
    data: XOR<TaskLabelCreateInput, TaskLabelUncheckedCreateInput>
  }

  /**
   * TaskLabel createMany
   */
  export type TaskLabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskLabels.
     */
    data: TaskLabelCreateManyInput | TaskLabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskLabel createManyAndReturn
   */
  export type TaskLabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskLabels.
     */
    data: TaskLabelCreateManyInput | TaskLabelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskLabel update
   */
  export type TaskLabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskLabel.
     */
    data: XOR<TaskLabelUpdateInput, TaskLabelUncheckedUpdateInput>
    /**
     * Choose, which TaskLabel to update.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel updateMany
   */
  export type TaskLabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskLabels.
     */
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyInput>
    /**
     * Filter which TaskLabels to update
     */
    where?: TaskLabelWhereInput
  }

  /**
   * TaskLabel upsert
   */
  export type TaskLabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskLabel to update in case it exists.
     */
    where: TaskLabelWhereUniqueInput
    /**
     * In case the TaskLabel found by the `where` argument doesn't exist, create a new TaskLabel with this data.
     */
    create: XOR<TaskLabelCreateInput, TaskLabelUncheckedCreateInput>
    /**
     * In case the TaskLabel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskLabelUpdateInput, TaskLabelUncheckedUpdateInput>
  }

  /**
   * TaskLabel delete
   */
  export type TaskLabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter which TaskLabel to delete.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel deleteMany
   */
  export type TaskLabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLabels to delete
     */
    where?: TaskLabelWhereInput
  }

  /**
   * TaskLabel without action
   */
  export type TaskLabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
  }


  /**
   * Model Label
   */

  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    colour: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type LabelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    colour: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    colour: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type LabelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    colour?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    colour?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    colour?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type LabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Label to aggregate.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithAggregationInput | LabelOrderByWithAggregationInput[]
    by: LabelScalarFieldEnum[] | LabelScalarFieldEnum
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }

  export type LabelGroupByOutputType = {
    id: string
    name: string
    description: string | null
    colour: string
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: LabelCountAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    colour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    taskLabels?: boolean | Label$taskLabelsArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    colour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    colour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type LabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    taskLabels?: boolean | Label$taskLabelsArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Label"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      taskLabels: Prisma.$TaskLabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      colour: string
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["label"]>
    composites: {}
  }

  type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> = $Result.GetResult<Prisma.$LabelPayload, S>

  type LabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabelCountAggregateInputType | true
    }

  export interface LabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Label'], meta: { name: 'Label' } }
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabelFindUniqueArgs>(args: SelectSubset<T, LabelFindUniqueArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Label that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(args: SelectSubset<T, LabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabelFindFirstArgs>(args?: SelectSubset<T, LabelFindFirstArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Label that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(args?: SelectSubset<T, LabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabelFindManyArgs>(args?: SelectSubset<T, LabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
     */
    create<T extends LabelCreateArgs>(args: SelectSubset<T, LabelCreateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Labels.
     * @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabelCreateManyArgs>(args?: SelectSubset<T, LabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labels and returns the data saved in the database.
     * @param {LabelCreateManyAndReturnArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labels and only return the `id`
     * const labelWithIdOnly = await prisma.label.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabelCreateManyAndReturnArgs>(args?: SelectSubset<T, LabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
     */
    delete<T extends LabelDeleteArgs>(args: SelectSubset<T, LabelDeleteArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabelUpdateArgs>(args: SelectSubset<T, LabelUpdateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabelDeleteManyArgs>(args?: SelectSubset<T, LabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabelUpdateManyArgs>(args: SelectSubset<T, LabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
     */
    upsert<T extends LabelUpsertArgs>(args: SelectSubset<T, LabelUpsertArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): Prisma.PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Label model
   */
  readonly fields: LabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    taskLabels<T extends Label$taskLabelsArgs<ExtArgs> = {}>(args?: Subset<T, Label$taskLabelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Label model
   */ 
  interface LabelFieldRefs {
    readonly id: FieldRef<"Label", 'String'>
    readonly name: FieldRef<"Label", 'String'>
    readonly description: FieldRef<"Label", 'String'>
    readonly colour: FieldRef<"Label", 'String'>
    readonly createdAt: FieldRef<"Label", 'DateTime'>
    readonly updatedAt: FieldRef<"Label", 'DateTime'>
    readonly createdById: FieldRef<"Label", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Label findUnique
   */
  export type LabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findUniqueOrThrow
   */
  export type LabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findFirst
   */
  export type LabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findFirstOrThrow
   */
  export type LabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findMany
   */
  export type LabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Labels to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label create
   */
  export type LabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to create a Label.
     */
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }

  /**
   * Label createMany
   */
  export type LabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Label createManyAndReturn
   */
  export type LabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Label update
   */
  export type LabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to update a Label.
     */
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
  }

  /**
   * Label upsert
   */
  export type LabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The filter to search for the Label to update in case it exists.
     */
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     */
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }

  /**
   * Label delete
   */
  export type LabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter which Label to delete.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labels to delete
     */
    where?: LabelWhereInput
  }

  /**
   * Label.taskLabels
   */
  export type Label$taskLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    cursor?: TaskLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * Label without action
   */
  export type LabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    injured: $Enums.WereYouInjured | null
    email: string | null
    phone: string | null
    password: string | null
    phone2: string | null
    gender: string | null
    dateOfBirth: Date | null
    isUnder18: boolean | null
    fatherFirstName: string | null
    fatherLastName: string | null
    motherFirstName: string | null
    motherLastName: string | null
    mailingAddress1: string | null
    mailingAddress2: string | null
    mailingCity: string | null
    mailingState: string | null
    mailingZipCode: string | null
    isPOBoxOrDifferentAddress: boolean | null
    physicalAddress1: string | null
    physicalAddress2: string | null
    physicalCity: string | null
    physicalState: string | null
    physicalZipCode: string | null
    maritalStatus: string | null
    spouseFirstName: string | null
    spouseLastName: string | null
    spousePhone: string | null
    employmentStatus: string | null
    employerName: string | null
    employerTitle: string | null
    employmentType: string | null
    pay: string | null
    schoolName: string | null
    expectedGraduationYear: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    verificationCode: string | null
    sourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    claimlistId: string | null
    accountSync: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    injured: $Enums.WereYouInjured | null
    email: string | null
    phone: string | null
    password: string | null
    phone2: string | null
    gender: string | null
    dateOfBirth: Date | null
    isUnder18: boolean | null
    fatherFirstName: string | null
    fatherLastName: string | null
    motherFirstName: string | null
    motherLastName: string | null
    mailingAddress1: string | null
    mailingAddress2: string | null
    mailingCity: string | null
    mailingState: string | null
    mailingZipCode: string | null
    isPOBoxOrDifferentAddress: boolean | null
    physicalAddress1: string | null
    physicalAddress2: string | null
    physicalCity: string | null
    physicalState: string | null
    physicalZipCode: string | null
    maritalStatus: string | null
    spouseFirstName: string | null
    spouseLastName: string | null
    spousePhone: string | null
    employmentStatus: string | null
    employerName: string | null
    employerTitle: string | null
    employmentType: string | null
    pay: string | null
    schoolName: string | null
    expectedGraduationYear: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    verificationCode: string | null
    sourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    claimlistId: string | null
    accountSync: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    injured: number
    email: number
    phone: number
    password: number
    phone2: number
    gender: number
    dateOfBirth: number
    isUnder18: number
    fatherFirstName: number
    fatherLastName: number
    motherFirstName: number
    motherLastName: number
    mailingAddress1: number
    mailingAddress2: number
    mailingCity: number
    mailingState: number
    mailingZipCode: number
    isPOBoxOrDifferentAddress: number
    physicalAddress1: number
    physicalAddress2: number
    physicalCity: number
    physicalState: number
    physicalZipCode: number
    maritalStatus: number
    spouseFirstName: number
    spouseLastName: number
    spousePhone: number
    employmentStatus: number
    employerName: number
    employerTitle: number
    employmentType: number
    pay: number
    schoolName: number
    expectedGraduationYear: number
    role: number
    isVerified: number
    verificationCode: number
    sourceId: number
    createdAt: number
    updatedAt: number
    claimlistId: number
    accountSync: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    injured?: true
    email?: true
    phone?: true
    password?: true
    phone2?: true
    gender?: true
    dateOfBirth?: true
    isUnder18?: true
    fatherFirstName?: true
    fatherLastName?: true
    motherFirstName?: true
    motherLastName?: true
    mailingAddress1?: true
    mailingAddress2?: true
    mailingCity?: true
    mailingState?: true
    mailingZipCode?: true
    isPOBoxOrDifferentAddress?: true
    physicalAddress1?: true
    physicalAddress2?: true
    physicalCity?: true
    physicalState?: true
    physicalZipCode?: true
    maritalStatus?: true
    spouseFirstName?: true
    spouseLastName?: true
    spousePhone?: true
    employmentStatus?: true
    employerName?: true
    employerTitle?: true
    employmentType?: true
    pay?: true
    schoolName?: true
    expectedGraduationYear?: true
    role?: true
    isVerified?: true
    verificationCode?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
    claimlistId?: true
    accountSync?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    injured?: true
    email?: true
    phone?: true
    password?: true
    phone2?: true
    gender?: true
    dateOfBirth?: true
    isUnder18?: true
    fatherFirstName?: true
    fatherLastName?: true
    motherFirstName?: true
    motherLastName?: true
    mailingAddress1?: true
    mailingAddress2?: true
    mailingCity?: true
    mailingState?: true
    mailingZipCode?: true
    isPOBoxOrDifferentAddress?: true
    physicalAddress1?: true
    physicalAddress2?: true
    physicalCity?: true
    physicalState?: true
    physicalZipCode?: true
    maritalStatus?: true
    spouseFirstName?: true
    spouseLastName?: true
    spousePhone?: true
    employmentStatus?: true
    employerName?: true
    employerTitle?: true
    employmentType?: true
    pay?: true
    schoolName?: true
    expectedGraduationYear?: true
    role?: true
    isVerified?: true
    verificationCode?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
    claimlistId?: true
    accountSync?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    injured?: true
    email?: true
    phone?: true
    password?: true
    phone2?: true
    gender?: true
    dateOfBirth?: true
    isUnder18?: true
    fatherFirstName?: true
    fatherLastName?: true
    motherFirstName?: true
    motherLastName?: true
    mailingAddress1?: true
    mailingAddress2?: true
    mailingCity?: true
    mailingState?: true
    mailingZipCode?: true
    isPOBoxOrDifferentAddress?: true
    physicalAddress1?: true
    physicalAddress2?: true
    physicalCity?: true
    physicalState?: true
    physicalZipCode?: true
    maritalStatus?: true
    spouseFirstName?: true
    spouseLastName?: true
    spousePhone?: true
    employmentStatus?: true
    employerName?: true
    employerTitle?: true
    employmentType?: true
    pay?: true
    schoolName?: true
    expectedGraduationYear?: true
    role?: true
    isVerified?: true
    verificationCode?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
    claimlistId?: true
    accountSync?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    middleName: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2: string | null
    gender: string | null
    dateOfBirth: Date | null
    isUnder18: boolean
    fatherFirstName: string | null
    fatherLastName: string | null
    motherFirstName: string | null
    motherLastName: string | null
    mailingAddress1: string | null
    mailingAddress2: string | null
    mailingCity: string | null
    mailingState: string | null
    mailingZipCode: string | null
    isPOBoxOrDifferentAddress: boolean | null
    physicalAddress1: string | null
    physicalAddress2: string | null
    physicalCity: string | null
    physicalState: string | null
    physicalZipCode: string | null
    maritalStatus: string | null
    spouseFirstName: string | null
    spouseLastName: string | null
    spousePhone: string | null
    employmentStatus: string | null
    employerName: string | null
    employerTitle: string | null
    employmentType: string | null
    pay: string | null
    schoolName: string | null
    expectedGraduationYear: string | null
    role: $Enums.UserRole
    isVerified: boolean
    verificationCode: string | null
    sourceId: string | null
    createdAt: Date
    updatedAt: Date
    claimlistId: string
    accountSync: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    injured?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    phone2?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    isUnder18?: boolean
    fatherFirstName?: boolean
    fatherLastName?: boolean
    motherFirstName?: boolean
    motherLastName?: boolean
    mailingAddress1?: boolean
    mailingAddress2?: boolean
    mailingCity?: boolean
    mailingState?: boolean
    mailingZipCode?: boolean
    isPOBoxOrDifferentAddress?: boolean
    physicalAddress1?: boolean
    physicalAddress2?: boolean
    physicalCity?: boolean
    physicalState?: boolean
    physicalZipCode?: boolean
    maritalStatus?: boolean
    spouseFirstName?: boolean
    spouseLastName?: boolean
    spousePhone?: boolean
    employmentStatus?: boolean
    employerName?: boolean
    employerTitle?: boolean
    employmentType?: boolean
    pay?: boolean
    schoolName?: boolean
    expectedGraduationYear?: boolean
    role?: boolean
    isVerified?: boolean
    verificationCode?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claimlistId?: boolean
    accountSync?: boolean
    source?: boolean | User$sourceArgs<ExtArgs>
    claims?: boolean | User$claimsArgs<ExtArgs>
    verify?: boolean | User$verifyArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
    projectsOwned?: boolean | User$projectsOwnedArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    taskAssignments?: boolean | User$taskAssignmentsArgs<ExtArgs>
    projectAssignments?: boolean | User$projectAssignmentsArgs<ExtArgs>
    taskComments?: boolean | User$taskCommentsArgs<ExtArgs>
    labelsCreated?: boolean | User$labelsCreatedArgs<ExtArgs>
    taskAttachments?: boolean | User$taskAttachmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    injured?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    phone2?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    isUnder18?: boolean
    fatherFirstName?: boolean
    fatherLastName?: boolean
    motherFirstName?: boolean
    motherLastName?: boolean
    mailingAddress1?: boolean
    mailingAddress2?: boolean
    mailingCity?: boolean
    mailingState?: boolean
    mailingZipCode?: boolean
    isPOBoxOrDifferentAddress?: boolean
    physicalAddress1?: boolean
    physicalAddress2?: boolean
    physicalCity?: boolean
    physicalState?: boolean
    physicalZipCode?: boolean
    maritalStatus?: boolean
    spouseFirstName?: boolean
    spouseLastName?: boolean
    spousePhone?: boolean
    employmentStatus?: boolean
    employerName?: boolean
    employerTitle?: boolean
    employmentType?: boolean
    pay?: boolean
    schoolName?: boolean
    expectedGraduationYear?: boolean
    role?: boolean
    isVerified?: boolean
    verificationCode?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claimlistId?: boolean
    accountSync?: boolean
    source?: boolean | User$sourceArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    injured?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    phone2?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    isUnder18?: boolean
    fatherFirstName?: boolean
    fatherLastName?: boolean
    motherFirstName?: boolean
    motherLastName?: boolean
    mailingAddress1?: boolean
    mailingAddress2?: boolean
    mailingCity?: boolean
    mailingState?: boolean
    mailingZipCode?: boolean
    isPOBoxOrDifferentAddress?: boolean
    physicalAddress1?: boolean
    physicalAddress2?: boolean
    physicalCity?: boolean
    physicalState?: boolean
    physicalZipCode?: boolean
    maritalStatus?: boolean
    spouseFirstName?: boolean
    spouseLastName?: boolean
    spousePhone?: boolean
    employmentStatus?: boolean
    employerName?: boolean
    employerTitle?: boolean
    employmentType?: boolean
    pay?: boolean
    schoolName?: boolean
    expectedGraduationYear?: boolean
    role?: boolean
    isVerified?: boolean
    verificationCode?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claimlistId?: boolean
    accountSync?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | User$sourceArgs<ExtArgs>
    claims?: boolean | User$claimsArgs<ExtArgs>
    verify?: boolean | User$verifyArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
    projectsOwned?: boolean | User$projectsOwnedArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    taskAssignments?: boolean | User$taskAssignmentsArgs<ExtArgs>
    projectAssignments?: boolean | User$projectAssignmentsArgs<ExtArgs>
    taskComments?: boolean | User$taskCommentsArgs<ExtArgs>
    labelsCreated?: boolean | User$labelsCreatedArgs<ExtArgs>
    taskAttachments?: boolean | User$taskAttachmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | User$sourceArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      source: Prisma.$SourcePayload<ExtArgs> | null
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      verify: Prisma.$VerifyPayload<ExtArgs> | null
      claimlist: Prisma.$ClaimListPayload<ExtArgs>
      projectsOwned: Prisma.$ProjectPayload<ExtArgs>[]
      tasksCreated: Prisma.$TaskPayload<ExtArgs>[]
      taskAssignments: Prisma.$TaskAssigneePayload<ExtArgs>[]
      projectAssignments: Prisma.$ProjectUserPayload<ExtArgs>[]
      taskComments: Prisma.$TaskCommentPayload<ExtArgs>[]
      labelsCreated: Prisma.$LabelPayload<ExtArgs>[]
      taskAttachments: Prisma.$TaskAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      middleName: string | null
      lastName: string
      injured: $Enums.WereYouInjured
      email: string
      phone: string
      password: string
      phone2: string | null
      gender: string | null
      dateOfBirth: Date | null
      isUnder18: boolean
      fatherFirstName: string | null
      fatherLastName: string | null
      motherFirstName: string | null
      motherLastName: string | null
      mailingAddress1: string | null
      mailingAddress2: string | null
      mailingCity: string | null
      mailingState: string | null
      mailingZipCode: string | null
      isPOBoxOrDifferentAddress: boolean | null
      physicalAddress1: string | null
      physicalAddress2: string | null
      physicalCity: string | null
      physicalState: string | null
      physicalZipCode: string | null
      maritalStatus: string | null
      spouseFirstName: string | null
      spouseLastName: string | null
      spousePhone: string | null
      employmentStatus: string | null
      employerName: string | null
      employerTitle: string | null
      employmentType: string | null
      pay: string | null
      schoolName: string | null
      expectedGraduationYear: string | null
      role: $Enums.UserRole
      isVerified: boolean
      verificationCode: string | null
      sourceId: string | null
      createdAt: Date
      updatedAt: Date
      claimlistId: string
      accountSync: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends User$sourceArgs<ExtArgs> = {}>(args?: Subset<T, User$sourceArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    claims<T extends User$claimsArgs<ExtArgs> = {}>(args?: Subset<T, User$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    verify<T extends User$verifyArgs<ExtArgs> = {}>(args?: Subset<T, User$verifyArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    claimlist<T extends ClaimListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimListDefaultArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projectsOwned<T extends User$projectsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    tasksCreated<T extends User$tasksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    taskAssignments<T extends User$taskAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany"> | Null>
    projectAssignments<T extends User$projectAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findMany"> | Null>
    taskComments<T extends User$taskCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany"> | Null>
    labelsCreated<T extends User$labelsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$labelsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany"> | Null>
    taskAttachments<T extends User$taskAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly middleName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly injured: FieldRef<"User", 'WereYouInjured'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone2: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly isUnder18: FieldRef<"User", 'Boolean'>
    readonly fatherFirstName: FieldRef<"User", 'String'>
    readonly fatherLastName: FieldRef<"User", 'String'>
    readonly motherFirstName: FieldRef<"User", 'String'>
    readonly motherLastName: FieldRef<"User", 'String'>
    readonly mailingAddress1: FieldRef<"User", 'String'>
    readonly mailingAddress2: FieldRef<"User", 'String'>
    readonly mailingCity: FieldRef<"User", 'String'>
    readonly mailingState: FieldRef<"User", 'String'>
    readonly mailingZipCode: FieldRef<"User", 'String'>
    readonly isPOBoxOrDifferentAddress: FieldRef<"User", 'Boolean'>
    readonly physicalAddress1: FieldRef<"User", 'String'>
    readonly physicalAddress2: FieldRef<"User", 'String'>
    readonly physicalCity: FieldRef<"User", 'String'>
    readonly physicalState: FieldRef<"User", 'String'>
    readonly physicalZipCode: FieldRef<"User", 'String'>
    readonly maritalStatus: FieldRef<"User", 'String'>
    readonly spouseFirstName: FieldRef<"User", 'String'>
    readonly spouseLastName: FieldRef<"User", 'String'>
    readonly spousePhone: FieldRef<"User", 'String'>
    readonly employmentStatus: FieldRef<"User", 'String'>
    readonly employerName: FieldRef<"User", 'String'>
    readonly employerTitle: FieldRef<"User", 'String'>
    readonly employmentType: FieldRef<"User", 'String'>
    readonly pay: FieldRef<"User", 'String'>
    readonly schoolName: FieldRef<"User", 'String'>
    readonly expectedGraduationYear: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly verificationCode: FieldRef<"User", 'String'>
    readonly sourceId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly claimlistId: FieldRef<"User", 'String'>
    readonly accountSync: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.source
   */
  export type User$sourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    where?: SourceWhereInput
  }

  /**
   * User.claims
   */
  export type User$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * User.verify
   */
  export type User$verifyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    where?: VerifyWhereInput
  }

  /**
   * User.projectsOwned
   */
  export type User$projectsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.tasksCreated
   */
  export type User$tasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.taskAssignments
   */
  export type User$taskAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    cursor?: TaskAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * User.projectAssignments
   */
  export type User$projectAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    where?: ProjectUserWhereInput
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    cursor?: ProjectUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * User.taskComments
   */
  export type User$taskCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    cursor?: TaskCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * User.labelsCreated
   */
  export type User$labelsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    cursor?: LabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * User.taskAttachments
   */
  export type User$taskAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    cursor?: TaskAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Verify
   */

  export type AggregateVerify = {
    _count: VerifyCountAggregateOutputType | null
    _min: VerifyMinAggregateOutputType | null
    _max: VerifyMaxAggregateOutputType | null
  }

  export type VerifyMinAggregateOutputType = {
    id: string | null
    token: string | null
    url: string | null
    status: string | null
    sessionId: string | null
    errorCode: string | null
    errorMessage: string | null
    updatedAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type VerifyMaxAggregateOutputType = {
    id: string | null
    token: string | null
    url: string | null
    status: string | null
    sessionId: string | null
    errorCode: string | null
    errorMessage: string | null
    updatedAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type VerifyCountAggregateOutputType = {
    id: number
    token: number
    url: number
    status: number
    sessionId: number
    errorCode: number
    errorMessage: number
    updatedAt: number
    createdAt: number
    userId: number
    _all: number
  }


  export type VerifyMinAggregateInputType = {
    id?: true
    token?: true
    url?: true
    status?: true
    sessionId?: true
    errorCode?: true
    errorMessage?: true
    updatedAt?: true
    createdAt?: true
    userId?: true
  }

  export type VerifyMaxAggregateInputType = {
    id?: true
    token?: true
    url?: true
    status?: true
    sessionId?: true
    errorCode?: true
    errorMessage?: true
    updatedAt?: true
    createdAt?: true
    userId?: true
  }

  export type VerifyCountAggregateInputType = {
    id?: true
    token?: true
    url?: true
    status?: true
    sessionId?: true
    errorCode?: true
    errorMessage?: true
    updatedAt?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type VerifyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verify to aggregate.
     */
    where?: VerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifies to fetch.
     */
    orderBy?: VerifyOrderByWithRelationInput | VerifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifies
    **/
    _count?: true | VerifyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerifyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerifyMaxAggregateInputType
  }

  export type GetVerifyAggregateType<T extends VerifyAggregateArgs> = {
        [P in keyof T & keyof AggregateVerify]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerify[P]>
      : GetScalarType<T[P], AggregateVerify[P]>
  }




  export type VerifyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerifyWhereInput
    orderBy?: VerifyOrderByWithAggregationInput | VerifyOrderByWithAggregationInput[]
    by: VerifyScalarFieldEnum[] | VerifyScalarFieldEnum
    having?: VerifyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerifyCountAggregateInputType | true
    _min?: VerifyMinAggregateInputType
    _max?: VerifyMaxAggregateInputType
  }

  export type VerifyGroupByOutputType = {
    id: string
    token: string
    url: string
    status: string
    sessionId: string | null
    errorCode: string | null
    errorMessage: string | null
    updatedAt: Date
    createdAt: Date
    userId: string
    _count: VerifyCountAggregateOutputType | null
    _min: VerifyMinAggregateOutputType | null
    _max: VerifyMaxAggregateOutputType | null
  }

  type GetVerifyGroupByPayload<T extends VerifyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerifyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerifyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerifyGroupByOutputType[P]>
            : GetScalarType<T[P], VerifyGroupByOutputType[P]>
        }
      >
    >


  export type VerifySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    url?: boolean
    status?: boolean
    sessionId?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verify"]>

  export type VerifySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    url?: boolean
    status?: boolean
    sessionId?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verify"]>

  export type VerifySelectScalar = {
    id?: boolean
    token?: boolean
    url?: boolean
    status?: boolean
    sessionId?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type VerifyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerifyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerifyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verify"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      url: string
      status: string
      sessionId: string | null
      errorCode: string | null
      errorMessage: string | null
      updatedAt: Date
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["verify"]>
    composites: {}
  }

  type VerifyGetPayload<S extends boolean | null | undefined | VerifyDefaultArgs> = $Result.GetResult<Prisma.$VerifyPayload, S>

  type VerifyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerifyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerifyCountAggregateInputType | true
    }

  export interface VerifyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verify'], meta: { name: 'Verify' } }
    /**
     * Find zero or one Verify that matches the filter.
     * @param {VerifyFindUniqueArgs} args - Arguments to find a Verify
     * @example
     * // Get one Verify
     * const verify = await prisma.verify.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerifyFindUniqueArgs>(args: SelectSubset<T, VerifyFindUniqueArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Verify that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerifyFindUniqueOrThrowArgs} args - Arguments to find a Verify
     * @example
     * // Get one Verify
     * const verify = await prisma.verify.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerifyFindUniqueOrThrowArgs>(args: SelectSubset<T, VerifyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Verify that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyFindFirstArgs} args - Arguments to find a Verify
     * @example
     * // Get one Verify
     * const verify = await prisma.verify.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerifyFindFirstArgs>(args?: SelectSubset<T, VerifyFindFirstArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Verify that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyFindFirstOrThrowArgs} args - Arguments to find a Verify
     * @example
     * // Get one Verify
     * const verify = await prisma.verify.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerifyFindFirstOrThrowArgs>(args?: SelectSubset<T, VerifyFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Verifies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifies
     * const verifies = await prisma.verify.findMany()
     * 
     * // Get first 10 Verifies
     * const verifies = await prisma.verify.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verifyWithIdOnly = await prisma.verify.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerifyFindManyArgs>(args?: SelectSubset<T, VerifyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Verify.
     * @param {VerifyCreateArgs} args - Arguments to create a Verify.
     * @example
     * // Create one Verify
     * const Verify = await prisma.verify.create({
     *   data: {
     *     // ... data to create a Verify
     *   }
     * })
     * 
     */
    create<T extends VerifyCreateArgs>(args: SelectSubset<T, VerifyCreateArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Verifies.
     * @param {VerifyCreateManyArgs} args - Arguments to create many Verifies.
     * @example
     * // Create many Verifies
     * const verify = await prisma.verify.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerifyCreateManyArgs>(args?: SelectSubset<T, VerifyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifies and returns the data saved in the database.
     * @param {VerifyCreateManyAndReturnArgs} args - Arguments to create many Verifies.
     * @example
     * // Create many Verifies
     * const verify = await prisma.verify.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifies and only return the `id`
     * const verifyWithIdOnly = await prisma.verify.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerifyCreateManyAndReturnArgs>(args?: SelectSubset<T, VerifyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Verify.
     * @param {VerifyDeleteArgs} args - Arguments to delete one Verify.
     * @example
     * // Delete one Verify
     * const Verify = await prisma.verify.delete({
     *   where: {
     *     // ... filter to delete one Verify
     *   }
     * })
     * 
     */
    delete<T extends VerifyDeleteArgs>(args: SelectSubset<T, VerifyDeleteArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Verify.
     * @param {VerifyUpdateArgs} args - Arguments to update one Verify.
     * @example
     * // Update one Verify
     * const verify = await prisma.verify.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerifyUpdateArgs>(args: SelectSubset<T, VerifyUpdateArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Verifies.
     * @param {VerifyDeleteManyArgs} args - Arguments to filter Verifies to delete.
     * @example
     * // Delete a few Verifies
     * const { count } = await prisma.verify.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerifyDeleteManyArgs>(args?: SelectSubset<T, VerifyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifies
     * const verify = await prisma.verify.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerifyUpdateManyArgs>(args: SelectSubset<T, VerifyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verify.
     * @param {VerifyUpsertArgs} args - Arguments to update or create a Verify.
     * @example
     * // Update or create a Verify
     * const verify = await prisma.verify.upsert({
     *   create: {
     *     // ... data to create a Verify
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verify we want to update
     *   }
     * })
     */
    upsert<T extends VerifyUpsertArgs>(args: SelectSubset<T, VerifyUpsertArgs<ExtArgs>>): Prisma__VerifyClient<$Result.GetResult<Prisma.$VerifyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Verifies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyCountArgs} args - Arguments to filter Verifies to count.
     * @example
     * // Count the number of Verifies
     * const count = await prisma.verify.count({
     *   where: {
     *     // ... the filter for the Verifies we want to count
     *   }
     * })
    **/
    count<T extends VerifyCountArgs>(
      args?: Subset<T, VerifyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerifyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerifyAggregateArgs>(args: Subset<T, VerifyAggregateArgs>): Prisma.PrismaPromise<GetVerifyAggregateType<T>>

    /**
     * Group by Verify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerifyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerifyGroupByArgs['orderBy'] }
        : { orderBy?: VerifyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerifyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerifyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verify model
   */
  readonly fields: VerifyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verify.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerifyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verify model
   */ 
  interface VerifyFieldRefs {
    readonly id: FieldRef<"Verify", 'String'>
    readonly token: FieldRef<"Verify", 'String'>
    readonly url: FieldRef<"Verify", 'String'>
    readonly status: FieldRef<"Verify", 'String'>
    readonly sessionId: FieldRef<"Verify", 'String'>
    readonly errorCode: FieldRef<"Verify", 'String'>
    readonly errorMessage: FieldRef<"Verify", 'String'>
    readonly updatedAt: FieldRef<"Verify", 'DateTime'>
    readonly createdAt: FieldRef<"Verify", 'DateTime'>
    readonly userId: FieldRef<"Verify", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Verify findUnique
   */
  export type VerifyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * Filter, which Verify to fetch.
     */
    where: VerifyWhereUniqueInput
  }

  /**
   * Verify findUniqueOrThrow
   */
  export type VerifyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * Filter, which Verify to fetch.
     */
    where: VerifyWhereUniqueInput
  }

  /**
   * Verify findFirst
   */
  export type VerifyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * Filter, which Verify to fetch.
     */
    where?: VerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifies to fetch.
     */
    orderBy?: VerifyOrderByWithRelationInput | VerifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifies.
     */
    cursor?: VerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifies.
     */
    distinct?: VerifyScalarFieldEnum | VerifyScalarFieldEnum[]
  }

  /**
   * Verify findFirstOrThrow
   */
  export type VerifyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * Filter, which Verify to fetch.
     */
    where?: VerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifies to fetch.
     */
    orderBy?: VerifyOrderByWithRelationInput | VerifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifies.
     */
    cursor?: VerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifies.
     */
    distinct?: VerifyScalarFieldEnum | VerifyScalarFieldEnum[]
  }

  /**
   * Verify findMany
   */
  export type VerifyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * Filter, which Verifies to fetch.
     */
    where?: VerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifies to fetch.
     */
    orderBy?: VerifyOrderByWithRelationInput | VerifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifies.
     */
    cursor?: VerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifies.
     */
    skip?: number
    distinct?: VerifyScalarFieldEnum | VerifyScalarFieldEnum[]
  }

  /**
   * Verify create
   */
  export type VerifyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * The data needed to create a Verify.
     */
    data: XOR<VerifyCreateInput, VerifyUncheckedCreateInput>
  }

  /**
   * Verify createMany
   */
  export type VerifyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifies.
     */
    data: VerifyCreateManyInput | VerifyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verify createManyAndReturn
   */
  export type VerifyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Verifies.
     */
    data: VerifyCreateManyInput | VerifyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verify update
   */
  export type VerifyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * The data needed to update a Verify.
     */
    data: XOR<VerifyUpdateInput, VerifyUncheckedUpdateInput>
    /**
     * Choose, which Verify to update.
     */
    where: VerifyWhereUniqueInput
  }

  /**
   * Verify updateMany
   */
  export type VerifyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifies.
     */
    data: XOR<VerifyUpdateManyMutationInput, VerifyUncheckedUpdateManyInput>
    /**
     * Filter which Verifies to update
     */
    where?: VerifyWhereInput
  }

  /**
   * Verify upsert
   */
  export type VerifyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * The filter to search for the Verify to update in case it exists.
     */
    where: VerifyWhereUniqueInput
    /**
     * In case the Verify found by the `where` argument doesn't exist, create a new Verify with this data.
     */
    create: XOR<VerifyCreateInput, VerifyUncheckedCreateInput>
    /**
     * In case the Verify was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerifyUpdateInput, VerifyUncheckedUpdateInput>
  }

  /**
   * Verify delete
   */
  export type VerifyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
    /**
     * Filter which Verify to delete.
     */
    where: VerifyWhereUniqueInput
  }

  /**
   * Verify deleteMany
   */
  export type VerifyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifies to delete
     */
    where?: VerifyWhereInput
  }

  /**
   * Verify without action
   */
  export type VerifyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verify
     */
    select?: VerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifyInclude<ExtArgs> | null
  }


  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    status: $Enums.ClaimStatus | null
    injured: boolean | null
    relationship: $Enums.Relationship | null
    otherRelationship: string | null
    healthInsurance: boolean | null
    healthInsuranceNumber: string | null
    isOver65: boolean | null
    assignedCaseManager: string | null
    userId: string | null
    clientRoleId: string | null
    injuredPartyRoleId: string | null
    incidentId: string | null
    healthInsuranceProviderId: string | null
    claimlistId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ClaimStatus | null
    injured: boolean | null
    relationship: $Enums.Relationship | null
    otherRelationship: string | null
    healthInsurance: boolean | null
    healthInsuranceNumber: string | null
    isOver65: boolean | null
    assignedCaseManager: string | null
    userId: string | null
    clientRoleId: string | null
    injuredPartyRoleId: string | null
    incidentId: string | null
    healthInsuranceProviderId: string | null
    claimlistId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    status: number
    injured: number
    relationship: number
    otherRelationship: number
    healthInsurance: number
    healthInsuranceNumber: number
    isOver65: number
    receiveMedicare: number
    assignedCaseManager: number
    userId: number
    clientRoleId: number
    injuredPartyRoleId: number
    incidentId: number
    healthInsuranceProviderId: number
    claimlistId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClaimMinAggregateInputType = {
    id?: true
    status?: true
    injured?: true
    relationship?: true
    otherRelationship?: true
    healthInsurance?: true
    healthInsuranceNumber?: true
    isOver65?: true
    assignedCaseManager?: true
    userId?: true
    clientRoleId?: true
    injuredPartyRoleId?: true
    incidentId?: true
    healthInsuranceProviderId?: true
    claimlistId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    status?: true
    injured?: true
    relationship?: true
    otherRelationship?: true
    healthInsurance?: true
    healthInsuranceNumber?: true
    isOver65?: true
    assignedCaseManager?: true
    userId?: true
    clientRoleId?: true
    injuredPartyRoleId?: true
    incidentId?: true
    healthInsuranceProviderId?: true
    claimlistId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    status?: true
    injured?: true
    relationship?: true
    otherRelationship?: true
    healthInsurance?: true
    healthInsuranceNumber?: true
    isOver65?: true
    receiveMedicare?: true
    assignedCaseManager?: true
    userId?: true
    clientRoleId?: true
    injuredPartyRoleId?: true
    incidentId?: true
    healthInsuranceProviderId?: true
    claimlistId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: string
    status: $Enums.ClaimStatus | null
    injured: boolean | null
    relationship: $Enums.Relationship | null
    otherRelationship: string | null
    healthInsurance: boolean | null
    healthInsuranceNumber: string | null
    isOver65: boolean | null
    receiveMedicare: string[]
    assignedCaseManager: string | null
    userId: string
    clientRoleId: string | null
    injuredPartyRoleId: string | null
    incidentId: string | null
    healthInsuranceProviderId: string | null
    claimlistId: string
    createdAt: Date
    updatedAt: Date
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    injured?: boolean
    relationship?: boolean
    otherRelationship?: boolean
    healthInsurance?: boolean
    healthInsuranceNumber?: boolean
    isOver65?: boolean
    receiveMedicare?: boolean
    assignedCaseManager?: boolean
    userId?: boolean
    clientRoleId?: boolean
    injuredPartyRoleId?: boolean
    incidentId?: boolean
    healthInsuranceProviderId?: boolean
    claimlistId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clientRole?: boolean | Claim$clientRoleArgs<ExtArgs>
    injuredPartyRole?: boolean | Claim$injuredPartyRoleArgs<ExtArgs>
    incident?: boolean | Claim$incidentArgs<ExtArgs>
    healthInsuranceProvider?: boolean | Claim$healthInsuranceProviderArgs<ExtArgs>
    witness?: boolean | Claim$witnessArgs<ExtArgs>
    defendant?: boolean | Claim$defendantArgs<ExtArgs>
    treatmentsAndInjuries?: boolean | Claim$treatmentsAndInjuriesArgs<ExtArgs>
    questionnaire?: boolean | Claim$questionnaireArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
    envelop?: boolean | Claim$envelopArgs<ExtArgs>
    media?: boolean | Claim$mediaArgs<ExtArgs>
    tasks?: boolean | Claim$tasksArgs<ExtArgs>
    projectClaims?: boolean | Claim$projectClaimsArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    injured?: boolean
    relationship?: boolean
    otherRelationship?: boolean
    healthInsurance?: boolean
    healthInsuranceNumber?: boolean
    isOver65?: boolean
    receiveMedicare?: boolean
    assignedCaseManager?: boolean
    userId?: boolean
    clientRoleId?: boolean
    injuredPartyRoleId?: boolean
    incidentId?: boolean
    healthInsuranceProviderId?: boolean
    claimlistId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clientRole?: boolean | Claim$clientRoleArgs<ExtArgs>
    injuredPartyRole?: boolean | Claim$injuredPartyRoleArgs<ExtArgs>
    incident?: boolean | Claim$incidentArgs<ExtArgs>
    healthInsuranceProvider?: boolean | Claim$healthInsuranceProviderArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    status?: boolean
    injured?: boolean
    relationship?: boolean
    otherRelationship?: boolean
    healthInsurance?: boolean
    healthInsuranceNumber?: boolean
    isOver65?: boolean
    receiveMedicare?: boolean
    assignedCaseManager?: boolean
    userId?: boolean
    clientRoleId?: boolean
    injuredPartyRoleId?: boolean
    incidentId?: boolean
    healthInsuranceProviderId?: boolean
    claimlistId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clientRole?: boolean | Claim$clientRoleArgs<ExtArgs>
    injuredPartyRole?: boolean | Claim$injuredPartyRoleArgs<ExtArgs>
    incident?: boolean | Claim$incidentArgs<ExtArgs>
    healthInsuranceProvider?: boolean | Claim$healthInsuranceProviderArgs<ExtArgs>
    witness?: boolean | Claim$witnessArgs<ExtArgs>
    defendant?: boolean | Claim$defendantArgs<ExtArgs>
    treatmentsAndInjuries?: boolean | Claim$treatmentsAndInjuriesArgs<ExtArgs>
    questionnaire?: boolean | Claim$questionnaireArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
    envelop?: boolean | Claim$envelopArgs<ExtArgs>
    media?: boolean | Claim$mediaArgs<ExtArgs>
    tasks?: boolean | Claim$tasksArgs<ExtArgs>
    projectClaims?: boolean | Claim$projectClaimsArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clientRole?: boolean | Claim$clientRoleArgs<ExtArgs>
    injuredPartyRole?: boolean | Claim$injuredPartyRoleArgs<ExtArgs>
    incident?: boolean | Claim$incidentArgs<ExtArgs>
    healthInsuranceProvider?: boolean | Claim$healthInsuranceProviderArgs<ExtArgs>
    claimlist?: boolean | ClaimListDefaultArgs<ExtArgs>
  }

  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clientRole: Prisma.$RolePayload<ExtArgs> | null
      injuredPartyRole: Prisma.$RolePayload<ExtArgs> | null
      incident: Prisma.$IncidentPayload<ExtArgs> | null
      healthInsuranceProvider: Prisma.$RolePayload<ExtArgs> | null
      witness: Prisma.$WitnessPayload<ExtArgs> | null
      defendant: Prisma.$DefendantPayload<ExtArgs> | null
      treatmentsAndInjuries: Prisma.$TreatmentAndInjuryPayload<ExtArgs> | null
      questionnaire: Prisma.$QuestionnairePayload<ExtArgs> | null
      claimlist: Prisma.$ClaimListPayload<ExtArgs>
      envelop: Prisma.$EnvelopPayload<ExtArgs>[]
      media: Prisma.$AccidentMediaPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      projectClaims: Prisma.$ProjectClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.ClaimStatus | null
      injured: boolean | null
      relationship: $Enums.Relationship | null
      otherRelationship: string | null
      healthInsurance: boolean | null
      healthInsuranceNumber: string | null
      isOver65: boolean | null
      receiveMedicare: string[]
      assignedCaseManager: string | null
      userId: string
      clientRoleId: string | null
      injuredPartyRoleId: string | null
      incidentId: string | null
      healthInsuranceProviderId: string | null
      claimlistId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }

  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimFindUniqueArgs>(args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Claim that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimFindFirstArgs>(args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimFindManyArgs>(args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
     */
    create<T extends ClaimCreateArgs>(args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Claims.
     * @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimCreateManyArgs>(args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claims and returns the data saved in the database.
     * @param {ClaimCreateManyAndReturnArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
     */
    delete<T extends ClaimDeleteArgs>(args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimUpdateArgs>(args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimDeleteManyArgs>(args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimUpdateManyArgs>(args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
     */
    upsert<T extends ClaimUpsertArgs>(args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clientRole<T extends Claim$clientRoleArgs<ExtArgs> = {}>(args?: Subset<T, Claim$clientRoleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    injuredPartyRole<T extends Claim$injuredPartyRoleArgs<ExtArgs> = {}>(args?: Subset<T, Claim$injuredPartyRoleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    incident<T extends Claim$incidentArgs<ExtArgs> = {}>(args?: Subset<T, Claim$incidentArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    healthInsuranceProvider<T extends Claim$healthInsuranceProviderArgs<ExtArgs> = {}>(args?: Subset<T, Claim$healthInsuranceProviderArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    witness<T extends Claim$witnessArgs<ExtArgs> = {}>(args?: Subset<T, Claim$witnessArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    defendant<T extends Claim$defendantArgs<ExtArgs> = {}>(args?: Subset<T, Claim$defendantArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    treatmentsAndInjuries<T extends Claim$treatmentsAndInjuriesArgs<ExtArgs> = {}>(args?: Subset<T, Claim$treatmentsAndInjuriesArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    questionnaire<T extends Claim$questionnaireArgs<ExtArgs> = {}>(args?: Subset<T, Claim$questionnaireArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    claimlist<T extends ClaimListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimListDefaultArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    envelop<T extends Claim$envelopArgs<ExtArgs> = {}>(args?: Subset<T, Claim$envelopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "findMany"> | Null>
    media<T extends Claim$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Claim$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Claim$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Claim$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    projectClaims<T extends Claim$projectClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Claim$projectClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Claim model
   */ 
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'String'>
    readonly status: FieldRef<"Claim", 'ClaimStatus'>
    readonly injured: FieldRef<"Claim", 'Boolean'>
    readonly relationship: FieldRef<"Claim", 'Relationship'>
    readonly otherRelationship: FieldRef<"Claim", 'String'>
    readonly healthInsurance: FieldRef<"Claim", 'Boolean'>
    readonly healthInsuranceNumber: FieldRef<"Claim", 'String'>
    readonly isOver65: FieldRef<"Claim", 'Boolean'>
    readonly receiveMedicare: FieldRef<"Claim", 'String[]'>
    readonly assignedCaseManager: FieldRef<"Claim", 'String'>
    readonly userId: FieldRef<"Claim", 'String'>
    readonly clientRoleId: FieldRef<"Claim", 'String'>
    readonly injuredPartyRoleId: FieldRef<"Claim", 'String'>
    readonly incidentId: FieldRef<"Claim", 'String'>
    readonly healthInsuranceProviderId: FieldRef<"Claim", 'String'>
    readonly claimlistId: FieldRef<"Claim", 'String'>
    readonly createdAt: FieldRef<"Claim", 'DateTime'>
    readonly updatedAt: FieldRef<"Claim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }

  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Claim createManyAndReturn
   */
  export type ClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
  }

  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }

  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
  }

  /**
   * Claim.clientRole
   */
  export type Claim$clientRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Claim.injuredPartyRole
   */
  export type Claim$injuredPartyRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Claim.incident
   */
  export type Claim$incidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
  }

  /**
   * Claim.healthInsuranceProvider
   */
  export type Claim$healthInsuranceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Claim.witness
   */
  export type Claim$witnessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    where?: WitnessWhereInput
  }

  /**
   * Claim.defendant
   */
  export type Claim$defendantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    where?: DefendantWhereInput
  }

  /**
   * Claim.treatmentsAndInjuries
   */
  export type Claim$treatmentsAndInjuriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    where?: TreatmentAndInjuryWhereInput
  }

  /**
   * Claim.questionnaire
   */
  export type Claim$questionnaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    where?: QuestionnaireWhereInput
  }

  /**
   * Claim.envelop
   */
  export type Claim$envelopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    where?: EnvelopWhereInput
    orderBy?: EnvelopOrderByWithRelationInput | EnvelopOrderByWithRelationInput[]
    cursor?: EnvelopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvelopScalarFieldEnum | EnvelopScalarFieldEnum[]
  }

  /**
   * Claim.media
   */
  export type Claim$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    where?: AccidentMediaWhereInput
    orderBy?: AccidentMediaOrderByWithRelationInput | AccidentMediaOrderByWithRelationInput[]
    cursor?: AccidentMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccidentMediaScalarFieldEnum | AccidentMediaScalarFieldEnum[]
  }

  /**
   * Claim.tasks
   */
  export type Claim$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Claim.projectClaims
   */
  export type Claim$projectClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    where?: ProjectClaimWhereInput
    orderBy?: ProjectClaimOrderByWithRelationInput | ProjectClaimOrderByWithRelationInput[]
    cursor?: ProjectClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectClaimScalarFieldEnum | ProjectClaimScalarFieldEnum[]
  }

  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
  }


  /**
   * Model ProjectClaim
   */

  export type AggregateProjectClaim = {
    _count: ProjectClaimCountAggregateOutputType | null
    _min: ProjectClaimMinAggregateOutputType | null
    _max: ProjectClaimMaxAggregateOutputType | null
  }

  export type ProjectClaimMinAggregateOutputType = {
    projectId: string | null
    claimId: string | null
    assignedAt: Date | null
  }

  export type ProjectClaimMaxAggregateOutputType = {
    projectId: string | null
    claimId: string | null
    assignedAt: Date | null
  }

  export type ProjectClaimCountAggregateOutputType = {
    projectId: number
    claimId: number
    assignedAt: number
    _all: number
  }


  export type ProjectClaimMinAggregateInputType = {
    projectId?: true
    claimId?: true
    assignedAt?: true
  }

  export type ProjectClaimMaxAggregateInputType = {
    projectId?: true
    claimId?: true
    assignedAt?: true
  }

  export type ProjectClaimCountAggregateInputType = {
    projectId?: true
    claimId?: true
    assignedAt?: true
    _all?: true
  }

  export type ProjectClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectClaim to aggregate.
     */
    where?: ProjectClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectClaims to fetch.
     */
    orderBy?: ProjectClaimOrderByWithRelationInput | ProjectClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectClaims
    **/
    _count?: true | ProjectClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectClaimMaxAggregateInputType
  }

  export type GetProjectClaimAggregateType<T extends ProjectClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectClaim[P]>
      : GetScalarType<T[P], AggregateProjectClaim[P]>
  }




  export type ProjectClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectClaimWhereInput
    orderBy?: ProjectClaimOrderByWithAggregationInput | ProjectClaimOrderByWithAggregationInput[]
    by: ProjectClaimScalarFieldEnum[] | ProjectClaimScalarFieldEnum
    having?: ProjectClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectClaimCountAggregateInputType | true
    _min?: ProjectClaimMinAggregateInputType
    _max?: ProjectClaimMaxAggregateInputType
  }

  export type ProjectClaimGroupByOutputType = {
    projectId: string
    claimId: string
    assignedAt: Date
    _count: ProjectClaimCountAggregateOutputType | null
    _min: ProjectClaimMinAggregateOutputType | null
    _max: ProjectClaimMaxAggregateOutputType | null
  }

  type GetProjectClaimGroupByPayload<T extends ProjectClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectClaimGroupByOutputType[P]>
        }
      >
    >


  export type ProjectClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    claimId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectClaim"]>

  export type ProjectClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    claimId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectClaim"]>

  export type ProjectClaimSelectScalar = {
    projectId?: boolean
    claimId?: boolean
    assignedAt?: boolean
  }

  export type ProjectClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type ProjectClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $ProjectClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectClaim"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      claim: Prisma.$ClaimPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: string
      claimId: string
      assignedAt: Date
    }, ExtArgs["result"]["projectClaim"]>
    composites: {}
  }

  type ProjectClaimGetPayload<S extends boolean | null | undefined | ProjectClaimDefaultArgs> = $Result.GetResult<Prisma.$ProjectClaimPayload, S>

  type ProjectClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectClaimFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectClaimCountAggregateInputType | true
    }

  export interface ProjectClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectClaim'], meta: { name: 'ProjectClaim' } }
    /**
     * Find zero or one ProjectClaim that matches the filter.
     * @param {ProjectClaimFindUniqueArgs} args - Arguments to find a ProjectClaim
     * @example
     * // Get one ProjectClaim
     * const projectClaim = await prisma.projectClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectClaimFindUniqueArgs>(args: SelectSubset<T, ProjectClaimFindUniqueArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectClaim that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectClaimFindUniqueOrThrowArgs} args - Arguments to find a ProjectClaim
     * @example
     * // Get one ProjectClaim
     * const projectClaim = await prisma.projectClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectClaimFindFirstArgs} args - Arguments to find a ProjectClaim
     * @example
     * // Get one ProjectClaim
     * const projectClaim = await prisma.projectClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectClaimFindFirstArgs>(args?: SelectSubset<T, ProjectClaimFindFirstArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectClaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectClaimFindFirstOrThrowArgs} args - Arguments to find a ProjectClaim
     * @example
     * // Get one ProjectClaim
     * const projectClaim = await prisma.projectClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectClaims
     * const projectClaims = await prisma.projectClaim.findMany()
     * 
     * // Get first 10 ProjectClaims
     * const projectClaims = await prisma.projectClaim.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectClaimWithProjectIdOnly = await prisma.projectClaim.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectClaimFindManyArgs>(args?: SelectSubset<T, ProjectClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectClaim.
     * @param {ProjectClaimCreateArgs} args - Arguments to create a ProjectClaim.
     * @example
     * // Create one ProjectClaim
     * const ProjectClaim = await prisma.projectClaim.create({
     *   data: {
     *     // ... data to create a ProjectClaim
     *   }
     * })
     * 
     */
    create<T extends ProjectClaimCreateArgs>(args: SelectSubset<T, ProjectClaimCreateArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectClaims.
     * @param {ProjectClaimCreateManyArgs} args - Arguments to create many ProjectClaims.
     * @example
     * // Create many ProjectClaims
     * const projectClaim = await prisma.projectClaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectClaimCreateManyArgs>(args?: SelectSubset<T, ProjectClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectClaims and returns the data saved in the database.
     * @param {ProjectClaimCreateManyAndReturnArgs} args - Arguments to create many ProjectClaims.
     * @example
     * // Create many ProjectClaims
     * const projectClaim = await prisma.projectClaim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectClaims and only return the `projectId`
     * const projectClaimWithProjectIdOnly = await prisma.projectClaim.createManyAndReturn({ 
     *   select: { projectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectClaim.
     * @param {ProjectClaimDeleteArgs} args - Arguments to delete one ProjectClaim.
     * @example
     * // Delete one ProjectClaim
     * const ProjectClaim = await prisma.projectClaim.delete({
     *   where: {
     *     // ... filter to delete one ProjectClaim
     *   }
     * })
     * 
     */
    delete<T extends ProjectClaimDeleteArgs>(args: SelectSubset<T, ProjectClaimDeleteArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectClaim.
     * @param {ProjectClaimUpdateArgs} args - Arguments to update one ProjectClaim.
     * @example
     * // Update one ProjectClaim
     * const projectClaim = await prisma.projectClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectClaimUpdateArgs>(args: SelectSubset<T, ProjectClaimUpdateArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectClaims.
     * @param {ProjectClaimDeleteManyArgs} args - Arguments to filter ProjectClaims to delete.
     * @example
     * // Delete a few ProjectClaims
     * const { count } = await prisma.projectClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectClaimDeleteManyArgs>(args?: SelectSubset<T, ProjectClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectClaims
     * const projectClaim = await prisma.projectClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectClaimUpdateManyArgs>(args: SelectSubset<T, ProjectClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectClaim.
     * @param {ProjectClaimUpsertArgs} args - Arguments to update or create a ProjectClaim.
     * @example
     * // Update or create a ProjectClaim
     * const projectClaim = await prisma.projectClaim.upsert({
     *   create: {
     *     // ... data to create a ProjectClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectClaim we want to update
     *   }
     * })
     */
    upsert<T extends ProjectClaimUpsertArgs>(args: SelectSubset<T, ProjectClaimUpsertArgs<ExtArgs>>): Prisma__ProjectClaimClient<$Result.GetResult<Prisma.$ProjectClaimPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectClaimCountArgs} args - Arguments to filter ProjectClaims to count.
     * @example
     * // Count the number of ProjectClaims
     * const count = await prisma.projectClaim.count({
     *   where: {
     *     // ... the filter for the ProjectClaims we want to count
     *   }
     * })
    **/
    count<T extends ProjectClaimCountArgs>(
      args?: Subset<T, ProjectClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectClaimAggregateArgs>(args: Subset<T, ProjectClaimAggregateArgs>): Prisma.PrismaPromise<GetProjectClaimAggregateType<T>>

    /**
     * Group by ProjectClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectClaimGroupByArgs['orderBy'] }
        : { orderBy?: ProjectClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectClaim model
   */
  readonly fields: ProjectClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectClaim model
   */ 
  interface ProjectClaimFieldRefs {
    readonly projectId: FieldRef<"ProjectClaim", 'String'>
    readonly claimId: FieldRef<"ProjectClaim", 'String'>
    readonly assignedAt: FieldRef<"ProjectClaim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectClaim findUnique
   */
  export type ProjectClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * Filter, which ProjectClaim to fetch.
     */
    where: ProjectClaimWhereUniqueInput
  }

  /**
   * ProjectClaim findUniqueOrThrow
   */
  export type ProjectClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * Filter, which ProjectClaim to fetch.
     */
    where: ProjectClaimWhereUniqueInput
  }

  /**
   * ProjectClaim findFirst
   */
  export type ProjectClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * Filter, which ProjectClaim to fetch.
     */
    where?: ProjectClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectClaims to fetch.
     */
    orderBy?: ProjectClaimOrderByWithRelationInput | ProjectClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectClaims.
     */
    cursor?: ProjectClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectClaims.
     */
    distinct?: ProjectClaimScalarFieldEnum | ProjectClaimScalarFieldEnum[]
  }

  /**
   * ProjectClaim findFirstOrThrow
   */
  export type ProjectClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * Filter, which ProjectClaim to fetch.
     */
    where?: ProjectClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectClaims to fetch.
     */
    orderBy?: ProjectClaimOrderByWithRelationInput | ProjectClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectClaims.
     */
    cursor?: ProjectClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectClaims.
     */
    distinct?: ProjectClaimScalarFieldEnum | ProjectClaimScalarFieldEnum[]
  }

  /**
   * ProjectClaim findMany
   */
  export type ProjectClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * Filter, which ProjectClaims to fetch.
     */
    where?: ProjectClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectClaims to fetch.
     */
    orderBy?: ProjectClaimOrderByWithRelationInput | ProjectClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectClaims.
     */
    cursor?: ProjectClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectClaims.
     */
    skip?: number
    distinct?: ProjectClaimScalarFieldEnum | ProjectClaimScalarFieldEnum[]
  }

  /**
   * ProjectClaim create
   */
  export type ProjectClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectClaim.
     */
    data: XOR<ProjectClaimCreateInput, ProjectClaimUncheckedCreateInput>
  }

  /**
   * ProjectClaim createMany
   */
  export type ProjectClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectClaims.
     */
    data: ProjectClaimCreateManyInput | ProjectClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectClaim createManyAndReturn
   */
  export type ProjectClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectClaims.
     */
    data: ProjectClaimCreateManyInput | ProjectClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectClaim update
   */
  export type ProjectClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectClaim.
     */
    data: XOR<ProjectClaimUpdateInput, ProjectClaimUncheckedUpdateInput>
    /**
     * Choose, which ProjectClaim to update.
     */
    where: ProjectClaimWhereUniqueInput
  }

  /**
   * ProjectClaim updateMany
   */
  export type ProjectClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectClaims.
     */
    data: XOR<ProjectClaimUpdateManyMutationInput, ProjectClaimUncheckedUpdateManyInput>
    /**
     * Filter which ProjectClaims to update
     */
    where?: ProjectClaimWhereInput
  }

  /**
   * ProjectClaim upsert
   */
  export type ProjectClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectClaim to update in case it exists.
     */
    where: ProjectClaimWhereUniqueInput
    /**
     * In case the ProjectClaim found by the `where` argument doesn't exist, create a new ProjectClaim with this data.
     */
    create: XOR<ProjectClaimCreateInput, ProjectClaimUncheckedCreateInput>
    /**
     * In case the ProjectClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectClaimUpdateInput, ProjectClaimUncheckedUpdateInput>
  }

  /**
   * ProjectClaim delete
   */
  export type ProjectClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
    /**
     * Filter which ProjectClaim to delete.
     */
    where: ProjectClaimWhereUniqueInput
  }

  /**
   * ProjectClaim deleteMany
   */
  export type ProjectClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectClaims to delete
     */
    where?: ProjectClaimWhereInput
  }

  /**
   * ProjectClaim without action
   */
  export type ProjectClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectClaim
     */
    select?: ProjectClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectClaimInclude<ExtArgs> | null
  }


  /**
   * Model Envelop
   */

  export type AggregateEnvelop = {
    _count: EnvelopCountAggregateOutputType | null
    _avg: EnvelopAvgAggregateOutputType | null
    _sum: EnvelopSumAggregateOutputType | null
    _min: EnvelopMinAggregateOutputType | null
    _max: EnvelopMaxAggregateOutputType | null
  }

  export type EnvelopAvgAggregateOutputType = {
    submitterId: number | null
  }

  export type EnvelopSumAggregateOutputType = {
    submitterId: number | null
  }

  export type EnvelopMinAggregateOutputType = {
    id: string | null
    status: boolean | null
    claimId: string | null
    submitterUrl: string | null
    submitterId: number | null
    submittedUrl: string | null
    createdAt: Date | null
  }

  export type EnvelopMaxAggregateOutputType = {
    id: string | null
    status: boolean | null
    claimId: string | null
    submitterUrl: string | null
    submitterId: number | null
    submittedUrl: string | null
    createdAt: Date | null
  }

  export type EnvelopCountAggregateOutputType = {
    id: number
    status: number
    claimId: number
    submitterUrl: number
    submitterId: number
    submittedUrl: number
    createdAt: number
    _all: number
  }


  export type EnvelopAvgAggregateInputType = {
    submitterId?: true
  }

  export type EnvelopSumAggregateInputType = {
    submitterId?: true
  }

  export type EnvelopMinAggregateInputType = {
    id?: true
    status?: true
    claimId?: true
    submitterUrl?: true
    submitterId?: true
    submittedUrl?: true
    createdAt?: true
  }

  export type EnvelopMaxAggregateInputType = {
    id?: true
    status?: true
    claimId?: true
    submitterUrl?: true
    submitterId?: true
    submittedUrl?: true
    createdAt?: true
  }

  export type EnvelopCountAggregateInputType = {
    id?: true
    status?: true
    claimId?: true
    submitterUrl?: true
    submitterId?: true
    submittedUrl?: true
    createdAt?: true
    _all?: true
  }

  export type EnvelopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Envelop to aggregate.
     */
    where?: EnvelopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelops to fetch.
     */
    orderBy?: EnvelopOrderByWithRelationInput | EnvelopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvelopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Envelops
    **/
    _count?: true | EnvelopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvelopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvelopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvelopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvelopMaxAggregateInputType
  }

  export type GetEnvelopAggregateType<T extends EnvelopAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvelop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvelop[P]>
      : GetScalarType<T[P], AggregateEnvelop[P]>
  }




  export type EnvelopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvelopWhereInput
    orderBy?: EnvelopOrderByWithAggregationInput | EnvelopOrderByWithAggregationInput[]
    by: EnvelopScalarFieldEnum[] | EnvelopScalarFieldEnum
    having?: EnvelopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvelopCountAggregateInputType | true
    _avg?: EnvelopAvgAggregateInputType
    _sum?: EnvelopSumAggregateInputType
    _min?: EnvelopMinAggregateInputType
    _max?: EnvelopMaxAggregateInputType
  }

  export type EnvelopGroupByOutputType = {
    id: string
    status: boolean
    claimId: string
    submitterUrl: string | null
    submitterId: number | null
    submittedUrl: string | null
    createdAt: Date
    _count: EnvelopCountAggregateOutputType | null
    _avg: EnvelopAvgAggregateOutputType | null
    _sum: EnvelopSumAggregateOutputType | null
    _min: EnvelopMinAggregateOutputType | null
    _max: EnvelopMaxAggregateOutputType | null
  }

  type GetEnvelopGroupByPayload<T extends EnvelopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvelopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvelopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvelopGroupByOutputType[P]>
            : GetScalarType<T[P], EnvelopGroupByOutputType[P]>
        }
      >
    >


  export type EnvelopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    claimId?: boolean
    submitterUrl?: boolean
    submitterId?: boolean
    submittedUrl?: boolean
    createdAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envelop"]>

  export type EnvelopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    claimId?: boolean
    submitterUrl?: boolean
    submitterId?: boolean
    submittedUrl?: boolean
    createdAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envelop"]>

  export type EnvelopSelectScalar = {
    id?: boolean
    status?: boolean
    claimId?: boolean
    submitterUrl?: boolean
    submitterId?: boolean
    submittedUrl?: boolean
    createdAt?: boolean
  }

  export type EnvelopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type EnvelopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $EnvelopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Envelop"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: boolean
      claimId: string
      submitterUrl: string | null
      submitterId: number | null
      submittedUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["envelop"]>
    composites: {}
  }

  type EnvelopGetPayload<S extends boolean | null | undefined | EnvelopDefaultArgs> = $Result.GetResult<Prisma.$EnvelopPayload, S>

  type EnvelopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnvelopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnvelopCountAggregateInputType | true
    }

  export interface EnvelopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Envelop'], meta: { name: 'Envelop' } }
    /**
     * Find zero or one Envelop that matches the filter.
     * @param {EnvelopFindUniqueArgs} args - Arguments to find a Envelop
     * @example
     * // Get one Envelop
     * const envelop = await prisma.envelop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvelopFindUniqueArgs>(args: SelectSubset<T, EnvelopFindUniqueArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Envelop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnvelopFindUniqueOrThrowArgs} args - Arguments to find a Envelop
     * @example
     * // Get one Envelop
     * const envelop = await prisma.envelop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvelopFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvelopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Envelop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopFindFirstArgs} args - Arguments to find a Envelop
     * @example
     * // Get one Envelop
     * const envelop = await prisma.envelop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvelopFindFirstArgs>(args?: SelectSubset<T, EnvelopFindFirstArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Envelop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopFindFirstOrThrowArgs} args - Arguments to find a Envelop
     * @example
     * // Get one Envelop
     * const envelop = await prisma.envelop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvelopFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvelopFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Envelops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Envelops
     * const envelops = await prisma.envelop.findMany()
     * 
     * // Get first 10 Envelops
     * const envelops = await prisma.envelop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const envelopWithIdOnly = await prisma.envelop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnvelopFindManyArgs>(args?: SelectSubset<T, EnvelopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Envelop.
     * @param {EnvelopCreateArgs} args - Arguments to create a Envelop.
     * @example
     * // Create one Envelop
     * const Envelop = await prisma.envelop.create({
     *   data: {
     *     // ... data to create a Envelop
     *   }
     * })
     * 
     */
    create<T extends EnvelopCreateArgs>(args: SelectSubset<T, EnvelopCreateArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Envelops.
     * @param {EnvelopCreateManyArgs} args - Arguments to create many Envelops.
     * @example
     * // Create many Envelops
     * const envelop = await prisma.envelop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvelopCreateManyArgs>(args?: SelectSubset<T, EnvelopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Envelops and returns the data saved in the database.
     * @param {EnvelopCreateManyAndReturnArgs} args - Arguments to create many Envelops.
     * @example
     * // Create many Envelops
     * const envelop = await prisma.envelop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Envelops and only return the `id`
     * const envelopWithIdOnly = await prisma.envelop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvelopCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvelopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Envelop.
     * @param {EnvelopDeleteArgs} args - Arguments to delete one Envelop.
     * @example
     * // Delete one Envelop
     * const Envelop = await prisma.envelop.delete({
     *   where: {
     *     // ... filter to delete one Envelop
     *   }
     * })
     * 
     */
    delete<T extends EnvelopDeleteArgs>(args: SelectSubset<T, EnvelopDeleteArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Envelop.
     * @param {EnvelopUpdateArgs} args - Arguments to update one Envelop.
     * @example
     * // Update one Envelop
     * const envelop = await prisma.envelop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvelopUpdateArgs>(args: SelectSubset<T, EnvelopUpdateArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Envelops.
     * @param {EnvelopDeleteManyArgs} args - Arguments to filter Envelops to delete.
     * @example
     * // Delete a few Envelops
     * const { count } = await prisma.envelop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvelopDeleteManyArgs>(args?: SelectSubset<T, EnvelopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Envelops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Envelops
     * const envelop = await prisma.envelop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvelopUpdateManyArgs>(args: SelectSubset<T, EnvelopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Envelop.
     * @param {EnvelopUpsertArgs} args - Arguments to update or create a Envelop.
     * @example
     * // Update or create a Envelop
     * const envelop = await prisma.envelop.upsert({
     *   create: {
     *     // ... data to create a Envelop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Envelop we want to update
     *   }
     * })
     */
    upsert<T extends EnvelopUpsertArgs>(args: SelectSubset<T, EnvelopUpsertArgs<ExtArgs>>): Prisma__EnvelopClient<$Result.GetResult<Prisma.$EnvelopPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Envelops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopCountArgs} args - Arguments to filter Envelops to count.
     * @example
     * // Count the number of Envelops
     * const count = await prisma.envelop.count({
     *   where: {
     *     // ... the filter for the Envelops we want to count
     *   }
     * })
    **/
    count<T extends EnvelopCountArgs>(
      args?: Subset<T, EnvelopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvelopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Envelop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvelopAggregateArgs>(args: Subset<T, EnvelopAggregateArgs>): Prisma.PrismaPromise<GetEnvelopAggregateType<T>>

    /**
     * Group by Envelop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvelopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvelopGroupByArgs['orderBy'] }
        : { orderBy?: EnvelopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvelopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvelopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Envelop model
   */
  readonly fields: EnvelopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Envelop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvelopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Envelop model
   */ 
  interface EnvelopFieldRefs {
    readonly id: FieldRef<"Envelop", 'String'>
    readonly status: FieldRef<"Envelop", 'Boolean'>
    readonly claimId: FieldRef<"Envelop", 'String'>
    readonly submitterUrl: FieldRef<"Envelop", 'String'>
    readonly submitterId: FieldRef<"Envelop", 'Int'>
    readonly submittedUrl: FieldRef<"Envelop", 'String'>
    readonly createdAt: FieldRef<"Envelop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Envelop findUnique
   */
  export type EnvelopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * Filter, which Envelop to fetch.
     */
    where: EnvelopWhereUniqueInput
  }

  /**
   * Envelop findUniqueOrThrow
   */
  export type EnvelopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * Filter, which Envelop to fetch.
     */
    where: EnvelopWhereUniqueInput
  }

  /**
   * Envelop findFirst
   */
  export type EnvelopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * Filter, which Envelop to fetch.
     */
    where?: EnvelopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelops to fetch.
     */
    orderBy?: EnvelopOrderByWithRelationInput | EnvelopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Envelops.
     */
    cursor?: EnvelopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Envelops.
     */
    distinct?: EnvelopScalarFieldEnum | EnvelopScalarFieldEnum[]
  }

  /**
   * Envelop findFirstOrThrow
   */
  export type EnvelopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * Filter, which Envelop to fetch.
     */
    where?: EnvelopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelops to fetch.
     */
    orderBy?: EnvelopOrderByWithRelationInput | EnvelopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Envelops.
     */
    cursor?: EnvelopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Envelops.
     */
    distinct?: EnvelopScalarFieldEnum | EnvelopScalarFieldEnum[]
  }

  /**
   * Envelop findMany
   */
  export type EnvelopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * Filter, which Envelops to fetch.
     */
    where?: EnvelopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelops to fetch.
     */
    orderBy?: EnvelopOrderByWithRelationInput | EnvelopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Envelops.
     */
    cursor?: EnvelopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelops.
     */
    skip?: number
    distinct?: EnvelopScalarFieldEnum | EnvelopScalarFieldEnum[]
  }

  /**
   * Envelop create
   */
  export type EnvelopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * The data needed to create a Envelop.
     */
    data: XOR<EnvelopCreateInput, EnvelopUncheckedCreateInput>
  }

  /**
   * Envelop createMany
   */
  export type EnvelopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Envelops.
     */
    data: EnvelopCreateManyInput | EnvelopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Envelop createManyAndReturn
   */
  export type EnvelopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Envelops.
     */
    data: EnvelopCreateManyInput | EnvelopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Envelop update
   */
  export type EnvelopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * The data needed to update a Envelop.
     */
    data: XOR<EnvelopUpdateInput, EnvelopUncheckedUpdateInput>
    /**
     * Choose, which Envelop to update.
     */
    where: EnvelopWhereUniqueInput
  }

  /**
   * Envelop updateMany
   */
  export type EnvelopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Envelops.
     */
    data: XOR<EnvelopUpdateManyMutationInput, EnvelopUncheckedUpdateManyInput>
    /**
     * Filter which Envelops to update
     */
    where?: EnvelopWhereInput
  }

  /**
   * Envelop upsert
   */
  export type EnvelopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * The filter to search for the Envelop to update in case it exists.
     */
    where: EnvelopWhereUniqueInput
    /**
     * In case the Envelop found by the `where` argument doesn't exist, create a new Envelop with this data.
     */
    create: XOR<EnvelopCreateInput, EnvelopUncheckedCreateInput>
    /**
     * In case the Envelop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvelopUpdateInput, EnvelopUncheckedUpdateInput>
  }

  /**
   * Envelop delete
   */
  export type EnvelopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
    /**
     * Filter which Envelop to delete.
     */
    where: EnvelopWhereUniqueInput
  }

  /**
   * Envelop deleteMany
   */
  export type EnvelopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Envelops to delete
     */
    where?: EnvelopWhereInput
  }

  /**
   * Envelop without action
   */
  export type EnvelopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelop
     */
    select?: EnvelopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopInclude<ExtArgs> | null
  }


  /**
   * Model ClaimList
   */

  export type AggregateClaimList = {
    _count: ClaimListCountAggregateOutputType | null
    _min: ClaimListMinAggregateOutputType | null
    _max: ClaimListMaxAggregateOutputType | null
  }

  export type ClaimListMinAggregateOutputType = {
    id: string | null
    name: string | null
    enable: boolean | null
    questionId: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ClaimListMaxAggregateOutputType = {
    id: string | null
    name: string | null
    enable: boolean | null
    questionId: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ClaimListCountAggregateOutputType = {
    id: number
    name: number
    enable: number
    questionId: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type ClaimListMinAggregateInputType = {
    id?: true
    name?: true
    enable?: true
    questionId?: true
    createdAt?: true
    createdBy?: true
  }

  export type ClaimListMaxAggregateInputType = {
    id?: true
    name?: true
    enable?: true
    questionId?: true
    createdAt?: true
    createdBy?: true
  }

  export type ClaimListCountAggregateInputType = {
    id?: true
    name?: true
    enable?: true
    questionId?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type ClaimListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimList to aggregate.
     */
    where?: ClaimListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimLists to fetch.
     */
    orderBy?: ClaimListOrderByWithRelationInput | ClaimListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClaimLists
    **/
    _count?: true | ClaimListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimListMaxAggregateInputType
  }

  export type GetClaimListAggregateType<T extends ClaimListAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimList[P]>
      : GetScalarType<T[P], AggregateClaimList[P]>
  }




  export type ClaimListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimListWhereInput
    orderBy?: ClaimListOrderByWithAggregationInput | ClaimListOrderByWithAggregationInput[]
    by: ClaimListScalarFieldEnum[] | ClaimListScalarFieldEnum
    having?: ClaimListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimListCountAggregateInputType | true
    _min?: ClaimListMinAggregateInputType
    _max?: ClaimListMaxAggregateInputType
  }

  export type ClaimListGroupByOutputType = {
    id: string
    name: string
    enable: boolean | null
    questionId: string | null
    createdAt: Date
    createdBy: string | null
    _count: ClaimListCountAggregateOutputType | null
    _min: ClaimListMinAggregateOutputType | null
    _max: ClaimListMaxAggregateOutputType | null
  }

  type GetClaimListGroupByPayload<T extends ClaimListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimListGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimListGroupByOutputType[P]>
        }
      >
    >


  export type ClaimListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    enable?: boolean
    questionId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    claim?: boolean | ClaimList$claimArgs<ExtArgs>
    user?: boolean | ClaimList$userArgs<ExtArgs>
    question?: boolean | ClaimList$questionArgs<ExtArgs>
    _count?: boolean | ClaimListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimList"]>

  export type ClaimListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    enable?: boolean
    questionId?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["claimList"]>

  export type ClaimListSelectScalar = {
    id?: boolean
    name?: boolean
    enable?: boolean
    questionId?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type ClaimListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimList$claimArgs<ExtArgs>
    user?: boolean | ClaimList$userArgs<ExtArgs>
    question?: boolean | ClaimList$questionArgs<ExtArgs>
    _count?: boolean | ClaimListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClaimListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClaimListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClaimList"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>[]
      question: Prisma.$QuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      enable: boolean | null
      questionId: string | null
      createdAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["claimList"]>
    composites: {}
  }

  type ClaimListGetPayload<S extends boolean | null | undefined | ClaimListDefaultArgs> = $Result.GetResult<Prisma.$ClaimListPayload, S>

  type ClaimListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClaimListCountAggregateInputType | true
    }

  export interface ClaimListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClaimList'], meta: { name: 'ClaimList' } }
    /**
     * Find zero or one ClaimList that matches the filter.
     * @param {ClaimListFindUniqueArgs} args - Arguments to find a ClaimList
     * @example
     * // Get one ClaimList
     * const claimList = await prisma.claimList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimListFindUniqueArgs>(args: SelectSubset<T, ClaimListFindUniqueArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClaimList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClaimListFindUniqueOrThrowArgs} args - Arguments to find a ClaimList
     * @example
     * // Get one ClaimList
     * const claimList = await prisma.claimList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimListFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClaimList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimListFindFirstArgs} args - Arguments to find a ClaimList
     * @example
     * // Get one ClaimList
     * const claimList = await prisma.claimList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimListFindFirstArgs>(args?: SelectSubset<T, ClaimListFindFirstArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClaimList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimListFindFirstOrThrowArgs} args - Arguments to find a ClaimList
     * @example
     * // Get one ClaimList
     * const claimList = await prisma.claimList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimListFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClaimLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClaimLists
     * const claimLists = await prisma.claimList.findMany()
     * 
     * // Get first 10 ClaimLists
     * const claimLists = await prisma.claimList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimListWithIdOnly = await prisma.claimList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimListFindManyArgs>(args?: SelectSubset<T, ClaimListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClaimList.
     * @param {ClaimListCreateArgs} args - Arguments to create a ClaimList.
     * @example
     * // Create one ClaimList
     * const ClaimList = await prisma.claimList.create({
     *   data: {
     *     // ... data to create a ClaimList
     *   }
     * })
     * 
     */
    create<T extends ClaimListCreateArgs>(args: SelectSubset<T, ClaimListCreateArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClaimLists.
     * @param {ClaimListCreateManyArgs} args - Arguments to create many ClaimLists.
     * @example
     * // Create many ClaimLists
     * const claimList = await prisma.claimList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimListCreateManyArgs>(args?: SelectSubset<T, ClaimListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClaimLists and returns the data saved in the database.
     * @param {ClaimListCreateManyAndReturnArgs} args - Arguments to create many ClaimLists.
     * @example
     * // Create many ClaimLists
     * const claimList = await prisma.claimList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClaimLists and only return the `id`
     * const claimListWithIdOnly = await prisma.claimList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaimListCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaimListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClaimList.
     * @param {ClaimListDeleteArgs} args - Arguments to delete one ClaimList.
     * @example
     * // Delete one ClaimList
     * const ClaimList = await prisma.claimList.delete({
     *   where: {
     *     // ... filter to delete one ClaimList
     *   }
     * })
     * 
     */
    delete<T extends ClaimListDeleteArgs>(args: SelectSubset<T, ClaimListDeleteArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClaimList.
     * @param {ClaimListUpdateArgs} args - Arguments to update one ClaimList.
     * @example
     * // Update one ClaimList
     * const claimList = await prisma.claimList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimListUpdateArgs>(args: SelectSubset<T, ClaimListUpdateArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClaimLists.
     * @param {ClaimListDeleteManyArgs} args - Arguments to filter ClaimLists to delete.
     * @example
     * // Delete a few ClaimLists
     * const { count } = await prisma.claimList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimListDeleteManyArgs>(args?: SelectSubset<T, ClaimListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClaimLists
     * const claimList = await prisma.claimList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimListUpdateManyArgs>(args: SelectSubset<T, ClaimListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClaimList.
     * @param {ClaimListUpsertArgs} args - Arguments to update or create a ClaimList.
     * @example
     * // Update or create a ClaimList
     * const claimList = await prisma.claimList.upsert({
     *   create: {
     *     // ... data to create a ClaimList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClaimList we want to update
     *   }
     * })
     */
    upsert<T extends ClaimListUpsertArgs>(args: SelectSubset<T, ClaimListUpsertArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClaimLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimListCountArgs} args - Arguments to filter ClaimLists to count.
     * @example
     * // Count the number of ClaimLists
     * const count = await prisma.claimList.count({
     *   where: {
     *     // ... the filter for the ClaimLists we want to count
     *   }
     * })
    **/
    count<T extends ClaimListCountArgs>(
      args?: Subset<T, ClaimListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClaimList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimListAggregateArgs>(args: Subset<T, ClaimListAggregateArgs>): Prisma.PrismaPromise<GetClaimListAggregateType<T>>

    /**
     * Group by ClaimList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimListGroupByArgs['orderBy'] }
        : { orderBy?: ClaimListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClaimList model
   */
  readonly fields: ClaimListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClaimList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimList$claimArgs<ExtArgs> = {}>(args?: Subset<T, ClaimList$claimArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends ClaimList$userArgs<ExtArgs> = {}>(args?: Subset<T, ClaimList$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    question<T extends ClaimList$questionArgs<ExtArgs> = {}>(args?: Subset<T, ClaimList$questionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClaimList model
   */ 
  interface ClaimListFieldRefs {
    readonly id: FieldRef<"ClaimList", 'String'>
    readonly name: FieldRef<"ClaimList", 'String'>
    readonly enable: FieldRef<"ClaimList", 'Boolean'>
    readonly questionId: FieldRef<"ClaimList", 'String'>
    readonly createdAt: FieldRef<"ClaimList", 'DateTime'>
    readonly createdBy: FieldRef<"ClaimList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClaimList findUnique
   */
  export type ClaimListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * Filter, which ClaimList to fetch.
     */
    where: ClaimListWhereUniqueInput
  }

  /**
   * ClaimList findUniqueOrThrow
   */
  export type ClaimListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * Filter, which ClaimList to fetch.
     */
    where: ClaimListWhereUniqueInput
  }

  /**
   * ClaimList findFirst
   */
  export type ClaimListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * Filter, which ClaimList to fetch.
     */
    where?: ClaimListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimLists to fetch.
     */
    orderBy?: ClaimListOrderByWithRelationInput | ClaimListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimLists.
     */
    cursor?: ClaimListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimLists.
     */
    distinct?: ClaimListScalarFieldEnum | ClaimListScalarFieldEnum[]
  }

  /**
   * ClaimList findFirstOrThrow
   */
  export type ClaimListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * Filter, which ClaimList to fetch.
     */
    where?: ClaimListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimLists to fetch.
     */
    orderBy?: ClaimListOrderByWithRelationInput | ClaimListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimLists.
     */
    cursor?: ClaimListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimLists.
     */
    distinct?: ClaimListScalarFieldEnum | ClaimListScalarFieldEnum[]
  }

  /**
   * ClaimList findMany
   */
  export type ClaimListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * Filter, which ClaimLists to fetch.
     */
    where?: ClaimListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimLists to fetch.
     */
    orderBy?: ClaimListOrderByWithRelationInput | ClaimListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClaimLists.
     */
    cursor?: ClaimListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimLists.
     */
    skip?: number
    distinct?: ClaimListScalarFieldEnum | ClaimListScalarFieldEnum[]
  }

  /**
   * ClaimList create
   */
  export type ClaimListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * The data needed to create a ClaimList.
     */
    data: XOR<ClaimListCreateInput, ClaimListUncheckedCreateInput>
  }

  /**
   * ClaimList createMany
   */
  export type ClaimListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClaimLists.
     */
    data: ClaimListCreateManyInput | ClaimListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClaimList createManyAndReturn
   */
  export type ClaimListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClaimLists.
     */
    data: ClaimListCreateManyInput | ClaimListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClaimList update
   */
  export type ClaimListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * The data needed to update a ClaimList.
     */
    data: XOR<ClaimListUpdateInput, ClaimListUncheckedUpdateInput>
    /**
     * Choose, which ClaimList to update.
     */
    where: ClaimListWhereUniqueInput
  }

  /**
   * ClaimList updateMany
   */
  export type ClaimListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClaimLists.
     */
    data: XOR<ClaimListUpdateManyMutationInput, ClaimListUncheckedUpdateManyInput>
    /**
     * Filter which ClaimLists to update
     */
    where?: ClaimListWhereInput
  }

  /**
   * ClaimList upsert
   */
  export type ClaimListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * The filter to search for the ClaimList to update in case it exists.
     */
    where: ClaimListWhereUniqueInput
    /**
     * In case the ClaimList found by the `where` argument doesn't exist, create a new ClaimList with this data.
     */
    create: XOR<ClaimListCreateInput, ClaimListUncheckedCreateInput>
    /**
     * In case the ClaimList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimListUpdateInput, ClaimListUncheckedUpdateInput>
  }

  /**
   * ClaimList delete
   */
  export type ClaimListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    /**
     * Filter which ClaimList to delete.
     */
    where: ClaimListWhereUniqueInput
  }

  /**
   * ClaimList deleteMany
   */
  export type ClaimListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimLists to delete
     */
    where?: ClaimListWhereInput
  }

  /**
   * ClaimList.claim
   */
  export type ClaimList$claimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * ClaimList.user
   */
  export type ClaimList$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * ClaimList.question
   */
  export type ClaimList$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * ClaimList without action
   */
  export type ClaimListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
  }


  /**
   * Model Source
   */

  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    enable: boolean | null
  }

  export type SourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    enable: boolean | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    createdBy: number
    enable: number
    _all: number
  }


  export type SourceMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    enable?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    enable?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    enable?: true
    _all?: true
  }

  export type SourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Source to aggregate.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithAggregationInput | SourceOrderByWithAggregationInput[]
    by: SourceScalarFieldEnum[] | SourceScalarFieldEnum
    having?: SourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }

  export type SourceGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    createdBy: string | null
    enable: boolean | null
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type SourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    enable?: boolean
    user?: boolean | Source$userArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    enable?: boolean
  }, ExtArgs["result"]["source"]>

  export type SourceSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    enable?: boolean
  }

  export type SourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Source$userArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Source"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      createdBy: string | null
      enable: boolean | null
    }, ExtArgs["result"]["source"]>
    composites: {}
  }

  type SourceGetPayload<S extends boolean | null | undefined | SourceDefaultArgs> = $Result.GetResult<Prisma.$SourcePayload, S>

  type SourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SourceCountAggregateInputType | true
    }

  export interface SourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Source'], meta: { name: 'Source' } }
    /**
     * Find zero or one Source that matches the filter.
     * @param {SourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceFindUniqueArgs>(args: SelectSubset<T, SourceFindUniqueArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Source that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SourceFindUniqueOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceFindFirstArgs>(args?: SelectSubset<T, SourceFindFirstArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceFindManyArgs>(args?: SelectSubset<T, SourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Source.
     * @param {SourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
     */
    create<T extends SourceCreateArgs>(args: SelectSubset<T, SourceCreateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sources.
     * @param {SourceCreateManyArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceCreateManyArgs>(args?: SelectSubset<T, SourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sources and returns the data saved in the database.
     * @param {SourceCreateManyAndReturnArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Source.
     * @param {SourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
     */
    delete<T extends SourceDeleteArgs>(args: SelectSubset<T, SourceDeleteArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Source.
     * @param {SourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceUpdateArgs>(args: SelectSubset<T, SourceUpdateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sources.
     * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceDeleteManyArgs>(args?: SelectSubset<T, SourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceUpdateManyArgs>(args: SelectSubset<T, SourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Source.
     * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
     */
    upsert<T extends SourceUpsertArgs>(args: SelectSubset<T, SourceUpsertArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourceCountArgs>(
      args?: Subset<T, SourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): Prisma.PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Source model
   */
  readonly fields: SourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Source$userArgs<ExtArgs> = {}>(args?: Subset<T, Source$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Source model
   */ 
  interface SourceFieldRefs {
    readonly id: FieldRef<"Source", 'String'>
    readonly name: FieldRef<"Source", 'String'>
    readonly createdAt: FieldRef<"Source", 'DateTime'>
    readonly createdBy: FieldRef<"Source", 'String'>
    readonly enable: FieldRef<"Source", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Source findUnique
   */
  export type SourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findUniqueOrThrow
   */
  export type SourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findFirst
   */
  export type SourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findFirstOrThrow
   */
  export type SourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findMany
   */
  export type SourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source create
   */
  export type SourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Source.
     */
    data: XOR<SourceCreateInput, SourceUncheckedCreateInput>
  }

  /**
   * Source createMany
   */
  export type SourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source createManyAndReturn
   */
  export type SourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source update
   */
  export type SourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Source.
     */
    data: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
    /**
     * Choose, which Source to update.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source updateMany
   */
  export type SourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
  }

  /**
   * Source upsert
   */
  export type SourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Source to update in case it exists.
     */
    where: SourceWhereUniqueInput
    /**
     * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
     */
    create: XOR<SourceCreateInput, SourceUncheckedCreateInput>
    /**
     * In case the Source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
  }

  /**
   * Source delete
   */
  export type SourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter which Source to delete.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source deleteMany
   */
  export type SourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to delete
     */
    where?: SourceWhereInput
  }

  /**
   * Source.user
   */
  export type Source$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Source without action
   */
  export type SourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
  }


  /**
   * Model Questionnaire
   */

  export type AggregateQuestionnaire = {
    _count: QuestionnaireCountAggregateOutputType | null
    _min: QuestionnaireMinAggregateOutputType | null
    _max: QuestionnaireMaxAggregateOutputType | null
  }

  export type QuestionnaireMinAggregateOutputType = {
    id: string | null
    claimId: string | null
  }

  export type QuestionnaireMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
  }

  export type QuestionnaireCountAggregateOutputType = {
    id: number
    claimId: number
    _all: number
  }


  export type QuestionnaireMinAggregateInputType = {
    id?: true
    claimId?: true
  }

  export type QuestionnaireMaxAggregateInputType = {
    id?: true
    claimId?: true
  }

  export type QuestionnaireCountAggregateInputType = {
    id?: true
    claimId?: true
    _all?: true
  }

  export type QuestionnaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questionnaire to aggregate.
     */
    where?: QuestionnaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questionnaires to fetch.
     */
    orderBy?: QuestionnaireOrderByWithRelationInput | QuestionnaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionnaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questionnaires
    **/
    _count?: true | QuestionnaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnaireMaxAggregateInputType
  }

  export type GetQuestionnaireAggregateType<T extends QuestionnaireAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaire[P]>
      : GetScalarType<T[P], AggregateQuestionnaire[P]>
  }




  export type QuestionnaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireWhereInput
    orderBy?: QuestionnaireOrderByWithAggregationInput | QuestionnaireOrderByWithAggregationInput[]
    by: QuestionnaireScalarFieldEnum[] | QuestionnaireScalarFieldEnum
    having?: QuestionnaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnaireCountAggregateInputType | true
    _min?: QuestionnaireMinAggregateInputType
    _max?: QuestionnaireMaxAggregateInputType
  }

  export type QuestionnaireGroupByOutputType = {
    id: string
    claimId: string
    _count: QuestionnaireCountAggregateOutputType | null
    _min: QuestionnaireMinAggregateOutputType | null
    _max: QuestionnaireMaxAggregateOutputType | null
  }

  type GetQuestionnaireGroupByPayload<T extends QuestionnaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnaireGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnaireGroupByOutputType[P]>
        }
      >
    >


  export type QuestionnaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    question?: boolean | Questionnaire$questionArgs<ExtArgs>
    _count?: boolean | QuestionnaireCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaire"]>

  export type QuestionnaireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaire"]>

  export type QuestionnaireSelectScalar = {
    id?: boolean
    claimId?: boolean
  }

  export type QuestionnaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    question?: boolean | Questionnaire$questionArgs<ExtArgs>
    _count?: boolean | QuestionnaireCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionnaireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $QuestionnairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Questionnaire"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
      question: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
    }, ExtArgs["result"]["questionnaire"]>
    composites: {}
  }

  type QuestionnaireGetPayload<S extends boolean | null | undefined | QuestionnaireDefaultArgs> = $Result.GetResult<Prisma.$QuestionnairePayload, S>

  type QuestionnaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionnaireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionnaireCountAggregateInputType | true
    }

  export interface QuestionnaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Questionnaire'], meta: { name: 'Questionnaire' } }
    /**
     * Find zero or one Questionnaire that matches the filter.
     * @param {QuestionnaireFindUniqueArgs} args - Arguments to find a Questionnaire
     * @example
     * // Get one Questionnaire
     * const questionnaire = await prisma.questionnaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionnaireFindUniqueArgs>(args: SelectSubset<T, QuestionnaireFindUniqueArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questionnaire that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionnaireFindUniqueOrThrowArgs} args - Arguments to find a Questionnaire
     * @example
     * // Get one Questionnaire
     * const questionnaire = await prisma.questionnaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionnaireFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionnaireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questionnaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireFindFirstArgs} args - Arguments to find a Questionnaire
     * @example
     * // Get one Questionnaire
     * const questionnaire = await prisma.questionnaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionnaireFindFirstArgs>(args?: SelectSubset<T, QuestionnaireFindFirstArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questionnaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireFindFirstOrThrowArgs} args - Arguments to find a Questionnaire
     * @example
     * // Get one Questionnaire
     * const questionnaire = await prisma.questionnaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionnaireFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionnaireFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questionnaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questionnaires
     * const questionnaires = await prisma.questionnaire.findMany()
     * 
     * // Get first 10 Questionnaires
     * const questionnaires = await prisma.questionnaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnaireWithIdOnly = await prisma.questionnaire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionnaireFindManyArgs>(args?: SelectSubset<T, QuestionnaireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questionnaire.
     * @param {QuestionnaireCreateArgs} args - Arguments to create a Questionnaire.
     * @example
     * // Create one Questionnaire
     * const Questionnaire = await prisma.questionnaire.create({
     *   data: {
     *     // ... data to create a Questionnaire
     *   }
     * })
     * 
     */
    create<T extends QuestionnaireCreateArgs>(args: SelectSubset<T, QuestionnaireCreateArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questionnaires.
     * @param {QuestionnaireCreateManyArgs} args - Arguments to create many Questionnaires.
     * @example
     * // Create many Questionnaires
     * const questionnaire = await prisma.questionnaire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionnaireCreateManyArgs>(args?: SelectSubset<T, QuestionnaireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questionnaires and returns the data saved in the database.
     * @param {QuestionnaireCreateManyAndReturnArgs} args - Arguments to create many Questionnaires.
     * @example
     * // Create many Questionnaires
     * const questionnaire = await prisma.questionnaire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questionnaires and only return the `id`
     * const questionnaireWithIdOnly = await prisma.questionnaire.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionnaireCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionnaireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Questionnaire.
     * @param {QuestionnaireDeleteArgs} args - Arguments to delete one Questionnaire.
     * @example
     * // Delete one Questionnaire
     * const Questionnaire = await prisma.questionnaire.delete({
     *   where: {
     *     // ... filter to delete one Questionnaire
     *   }
     * })
     * 
     */
    delete<T extends QuestionnaireDeleteArgs>(args: SelectSubset<T, QuestionnaireDeleteArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questionnaire.
     * @param {QuestionnaireUpdateArgs} args - Arguments to update one Questionnaire.
     * @example
     * // Update one Questionnaire
     * const questionnaire = await prisma.questionnaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionnaireUpdateArgs>(args: SelectSubset<T, QuestionnaireUpdateArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questionnaires.
     * @param {QuestionnaireDeleteManyArgs} args - Arguments to filter Questionnaires to delete.
     * @example
     * // Delete a few Questionnaires
     * const { count } = await prisma.questionnaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionnaireDeleteManyArgs>(args?: SelectSubset<T, QuestionnaireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questionnaires
     * const questionnaire = await prisma.questionnaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionnaireUpdateManyArgs>(args: SelectSubset<T, QuestionnaireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questionnaire.
     * @param {QuestionnaireUpsertArgs} args - Arguments to update or create a Questionnaire.
     * @example
     * // Update or create a Questionnaire
     * const questionnaire = await prisma.questionnaire.upsert({
     *   create: {
     *     // ... data to create a Questionnaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questionnaire we want to update
     *   }
     * })
     */
    upsert<T extends QuestionnaireUpsertArgs>(args: SelectSubset<T, QuestionnaireUpsertArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireCountArgs} args - Arguments to filter Questionnaires to count.
     * @example
     * // Count the number of Questionnaires
     * const count = await prisma.questionnaire.count({
     *   where: {
     *     // ... the filter for the Questionnaires we want to count
     *   }
     * })
    **/
    count<T extends QuestionnaireCountArgs>(
      args?: Subset<T, QuestionnaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questionnaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnaireAggregateArgs>(args: Subset<T, QuestionnaireAggregateArgs>): Prisma.PrismaPromise<GetQuestionnaireAggregateType<T>>

    /**
     * Group by Questionnaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionnaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionnaireGroupByArgs['orderBy'] }
        : { orderBy?: QuestionnaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionnaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Questionnaire model
   */
  readonly fields: QuestionnaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Questionnaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionnaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question<T extends Questionnaire$questionArgs<ExtArgs> = {}>(args?: Subset<T, Questionnaire$questionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Questionnaire model
   */ 
  interface QuestionnaireFieldRefs {
    readonly id: FieldRef<"Questionnaire", 'String'>
    readonly claimId: FieldRef<"Questionnaire", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Questionnaire findUnique
   */
  export type QuestionnaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * Filter, which Questionnaire to fetch.
     */
    where: QuestionnaireWhereUniqueInput
  }

  /**
   * Questionnaire findUniqueOrThrow
   */
  export type QuestionnaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * Filter, which Questionnaire to fetch.
     */
    where: QuestionnaireWhereUniqueInput
  }

  /**
   * Questionnaire findFirst
   */
  export type QuestionnaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * Filter, which Questionnaire to fetch.
     */
    where?: QuestionnaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questionnaires to fetch.
     */
    orderBy?: QuestionnaireOrderByWithRelationInput | QuestionnaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questionnaires.
     */
    cursor?: QuestionnaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questionnaires.
     */
    distinct?: QuestionnaireScalarFieldEnum | QuestionnaireScalarFieldEnum[]
  }

  /**
   * Questionnaire findFirstOrThrow
   */
  export type QuestionnaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * Filter, which Questionnaire to fetch.
     */
    where?: QuestionnaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questionnaires to fetch.
     */
    orderBy?: QuestionnaireOrderByWithRelationInput | QuestionnaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questionnaires.
     */
    cursor?: QuestionnaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questionnaires.
     */
    distinct?: QuestionnaireScalarFieldEnum | QuestionnaireScalarFieldEnum[]
  }

  /**
   * Questionnaire findMany
   */
  export type QuestionnaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * Filter, which Questionnaires to fetch.
     */
    where?: QuestionnaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questionnaires to fetch.
     */
    orderBy?: QuestionnaireOrderByWithRelationInput | QuestionnaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questionnaires.
     */
    cursor?: QuestionnaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questionnaires.
     */
    skip?: number
    distinct?: QuestionnaireScalarFieldEnum | QuestionnaireScalarFieldEnum[]
  }

  /**
   * Questionnaire create
   */
  export type QuestionnaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * The data needed to create a Questionnaire.
     */
    data: XOR<QuestionnaireCreateInput, QuestionnaireUncheckedCreateInput>
  }

  /**
   * Questionnaire createMany
   */
  export type QuestionnaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questionnaires.
     */
    data: QuestionnaireCreateManyInput | QuestionnaireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Questionnaire createManyAndReturn
   */
  export type QuestionnaireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Questionnaires.
     */
    data: QuestionnaireCreateManyInput | QuestionnaireCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Questionnaire update
   */
  export type QuestionnaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * The data needed to update a Questionnaire.
     */
    data: XOR<QuestionnaireUpdateInput, QuestionnaireUncheckedUpdateInput>
    /**
     * Choose, which Questionnaire to update.
     */
    where: QuestionnaireWhereUniqueInput
  }

  /**
   * Questionnaire updateMany
   */
  export type QuestionnaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questionnaires.
     */
    data: XOR<QuestionnaireUpdateManyMutationInput, QuestionnaireUncheckedUpdateManyInput>
    /**
     * Filter which Questionnaires to update
     */
    where?: QuestionnaireWhereInput
  }

  /**
   * Questionnaire upsert
   */
  export type QuestionnaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * The filter to search for the Questionnaire to update in case it exists.
     */
    where: QuestionnaireWhereUniqueInput
    /**
     * In case the Questionnaire found by the `where` argument doesn't exist, create a new Questionnaire with this data.
     */
    create: XOR<QuestionnaireCreateInput, QuestionnaireUncheckedCreateInput>
    /**
     * In case the Questionnaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionnaireUpdateInput, QuestionnaireUncheckedUpdateInput>
  }

  /**
   * Questionnaire delete
   */
  export type QuestionnaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    /**
     * Filter which Questionnaire to delete.
     */
    where: QuestionnaireWhereUniqueInput
  }

  /**
   * Questionnaire deleteMany
   */
  export type QuestionnaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questionnaires to delete
     */
    where?: QuestionnaireWhereInput
  }

  /**
   * Questionnaire.question
   */
  export type Questionnaire$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * Questionnaire without action
   */
  export type QuestionnaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
  }


  /**
   * Model QuestionAnswer
   */

  export type AggregateQuestionAnswer = {
    _count: QuestionAnswerCountAggregateOutputType | null
    _min: QuestionAnswerMinAggregateOutputType | null
    _max: QuestionAnswerMaxAggregateOutputType | null
  }

  export type QuestionAnswerMinAggregateOutputType = {
    id: string | null
    questionnaireId: string | null
    questionId: string | null
    answer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionAnswerMaxAggregateOutputType = {
    id: string | null
    questionnaireId: string | null
    questionId: string | null
    answer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionAnswerCountAggregateOutputType = {
    id: number
    questionnaireId: number
    questionId: number
    answer: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionAnswerMinAggregateInputType = {
    id?: true
    questionnaireId?: true
    questionId?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionAnswerMaxAggregateInputType = {
    id?: true
    questionnaireId?: true
    questionId?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionAnswerCountAggregateInputType = {
    id?: true
    questionnaireId?: true
    questionId?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnswer to aggregate.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionAnswers
    **/
    _count?: true | QuestionAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionAnswerMaxAggregateInputType
  }

  export type GetQuestionAnswerAggregateType<T extends QuestionAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionAnswer[P]>
      : GetScalarType<T[P], AggregateQuestionAnswer[P]>
  }




  export type QuestionAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithAggregationInput | QuestionAnswerOrderByWithAggregationInput[]
    by: QuestionAnswerScalarFieldEnum[] | QuestionAnswerScalarFieldEnum
    having?: QuestionAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionAnswerCountAggregateInputType | true
    _min?: QuestionAnswerMinAggregateInputType
    _max?: QuestionAnswerMaxAggregateInputType
  }

  export type QuestionAnswerGroupByOutputType = {
    id: string
    questionnaireId: string | null
    questionId: string
    answer: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionAnswerCountAggregateOutputType | null
    _min: QuestionAnswerMinAggregateOutputType | null
    _max: QuestionAnswerMaxAggregateOutputType | null
  }

  type GetQuestionAnswerGroupByPayload<T extends QuestionAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuestionAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionnaireId?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Questionnaire?: boolean | QuestionAnswer$QuestionnaireArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAnswer"]>

  export type QuestionAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionnaireId?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Questionnaire?: boolean | QuestionAnswer$QuestionnaireArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAnswer"]>

  export type QuestionAnswerSelectScalar = {
    id?: boolean
    questionnaireId?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questionnaire?: boolean | QuestionAnswer$QuestionnaireArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type QuestionAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questionnaire?: boolean | QuestionAnswer$QuestionnaireArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $QuestionAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionAnswer"
    objects: {
      Questionnaire: Prisma.$QuestionnairePayload<ExtArgs> | null
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionnaireId: string | null
      questionId: string
      answer: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionAnswer"]>
    composites: {}
  }

  type QuestionAnswerGetPayload<S extends boolean | null | undefined | QuestionAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuestionAnswerPayload, S>

  type QuestionAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionAnswerCountAggregateInputType | true
    }

  export interface QuestionAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionAnswer'], meta: { name: 'QuestionAnswer' } }
    /**
     * Find zero or one QuestionAnswer that matches the filter.
     * @param {QuestionAnswerFindUniqueArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionAnswerFindUniqueArgs>(args: SelectSubset<T, QuestionAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindFirstArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionAnswerFindFirstArgs>(args?: SelectSubset<T, QuestionAnswerFindFirstArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindFirstOrThrowArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionAnswers
     * const questionAnswers = await prisma.questionAnswer.findMany()
     * 
     * // Get first 10 QuestionAnswers
     * const questionAnswers = await prisma.questionAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionAnswerWithIdOnly = await prisma.questionAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionAnswerFindManyArgs>(args?: SelectSubset<T, QuestionAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionAnswer.
     * @param {QuestionAnswerCreateArgs} args - Arguments to create a QuestionAnswer.
     * @example
     * // Create one QuestionAnswer
     * const QuestionAnswer = await prisma.questionAnswer.create({
     *   data: {
     *     // ... data to create a QuestionAnswer
     *   }
     * })
     * 
     */
    create<T extends QuestionAnswerCreateArgs>(args: SelectSubset<T, QuestionAnswerCreateArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionAnswers.
     * @param {QuestionAnswerCreateManyArgs} args - Arguments to create many QuestionAnswers.
     * @example
     * // Create many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionAnswerCreateManyArgs>(args?: SelectSubset<T, QuestionAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionAnswers and returns the data saved in the database.
     * @param {QuestionAnswerCreateManyAndReturnArgs} args - Arguments to create many QuestionAnswers.
     * @example
     * // Create many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionAnswers and only return the `id`
     * const questionAnswerWithIdOnly = await prisma.questionAnswer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionAnswer.
     * @param {QuestionAnswerDeleteArgs} args - Arguments to delete one QuestionAnswer.
     * @example
     * // Delete one QuestionAnswer
     * const QuestionAnswer = await prisma.questionAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuestionAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuestionAnswerDeleteArgs>(args: SelectSubset<T, QuestionAnswerDeleteArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionAnswer.
     * @param {QuestionAnswerUpdateArgs} args - Arguments to update one QuestionAnswer.
     * @example
     * // Update one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionAnswerUpdateArgs>(args: SelectSubset<T, QuestionAnswerUpdateArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionAnswers.
     * @param {QuestionAnswerDeleteManyArgs} args - Arguments to filter QuestionAnswers to delete.
     * @example
     * // Delete a few QuestionAnswers
     * const { count } = await prisma.questionAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionAnswerDeleteManyArgs>(args?: SelectSubset<T, QuestionAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionAnswerUpdateManyArgs>(args: SelectSubset<T, QuestionAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionAnswer.
     * @param {QuestionAnswerUpsertArgs} args - Arguments to update or create a QuestionAnswer.
     * @example
     * // Update or create a QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.upsert({
     *   create: {
     *     // ... data to create a QuestionAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuestionAnswerUpsertArgs>(args: SelectSubset<T, QuestionAnswerUpsertArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerCountArgs} args - Arguments to filter QuestionAnswers to count.
     * @example
     * // Count the number of QuestionAnswers
     * const count = await prisma.questionAnswer.count({
     *   where: {
     *     // ... the filter for the QuestionAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuestionAnswerCountArgs>(
      args?: Subset<T, QuestionAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAnswerAggregateArgs>(args: Subset<T, QuestionAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuestionAnswerAggregateType<T>>

    /**
     * Group by QuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuestionAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionAnswer model
   */
  readonly fields: QuestionAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questionnaire<T extends QuestionAnswer$QuestionnaireArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$QuestionnaireArgs<ExtArgs>>): Prisma__QuestionnaireClient<$Result.GetResult<Prisma.$QuestionnairePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionAnswer model
   */ 
  interface QuestionAnswerFieldRefs {
    readonly id: FieldRef<"QuestionAnswer", 'String'>
    readonly questionnaireId: FieldRef<"QuestionAnswer", 'String'>
    readonly questionId: FieldRef<"QuestionAnswer", 'String'>
    readonly answer: FieldRef<"QuestionAnswer", 'String'>
    readonly createdAt: FieldRef<"QuestionAnswer", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionAnswer findUnique
   */
  export type QuestionAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer findUniqueOrThrow
   */
  export type QuestionAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer findFirst
   */
  export type QuestionAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnswers.
     */
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer findFirstOrThrow
   */
  export type QuestionAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnswers.
     */
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer findMany
   */
  export type QuestionAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswers to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer create
   */
  export type QuestionAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionAnswer.
     */
    data: XOR<QuestionAnswerCreateInput, QuestionAnswerUncheckedCreateInput>
  }

  /**
   * QuestionAnswer createMany
   */
  export type QuestionAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionAnswers.
     */
    data: QuestionAnswerCreateManyInput | QuestionAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionAnswer createManyAndReturn
   */
  export type QuestionAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionAnswers.
     */
    data: QuestionAnswerCreateManyInput | QuestionAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionAnswer update
   */
  export type QuestionAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionAnswer.
     */
    data: XOR<QuestionAnswerUpdateInput, QuestionAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuestionAnswer to update.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer updateMany
   */
  export type QuestionAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionAnswers.
     */
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAnswers to update
     */
    where?: QuestionAnswerWhereInput
  }

  /**
   * QuestionAnswer upsert
   */
  export type QuestionAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionAnswer to update in case it exists.
     */
    where: QuestionAnswerWhereUniqueInput
    /**
     * In case the QuestionAnswer found by the `where` argument doesn't exist, create a new QuestionAnswer with this data.
     */
    create: XOR<QuestionAnswerCreateInput, QuestionAnswerUncheckedCreateInput>
    /**
     * In case the QuestionAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionAnswerUpdateInput, QuestionAnswerUncheckedUpdateInput>
  }

  /**
   * QuestionAnswer delete
   */
  export type QuestionAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuestionAnswer to delete.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer deleteMany
   */
  export type QuestionAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnswers to delete
     */
    where?: QuestionAnswerWhereInput
  }

  /**
   * QuestionAnswer.Questionnaire
   */
  export type QuestionAnswer$QuestionnaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questionnaire
     */
    select?: QuestionnaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireInclude<ExtArgs> | null
    where?: QuestionnaireWhereInput
  }

  /**
   * QuestionAnswer without action
   */
  export type QuestionAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    question: string | null
    claimListId: string | null
    type: $Enums.QuestionType | null
    enable: boolean | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    question: string | null
    claimListId: string | null
    type: $Enums.QuestionType | null
    enable: boolean | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    question: number
    claimListId: number
    type: number
    enable: number
    _all: number
  }


  export type QuestionMinAggregateInputType = {
    id?: true
    question?: true
    claimListId?: true
    type?: true
    enable?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    question?: true
    claimListId?: true
    type?: true
    enable?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    question?: true
    claimListId?: true
    type?: true
    enable?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    question: string
    claimListId: string | null
    type: $Enums.QuestionType
    enable: boolean
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    claimListId?: boolean
    type?: boolean
    enable?: boolean
    claimList?: boolean | Question$claimListArgs<ExtArgs>
    choices?: boolean | Question$choicesArgs<ExtArgs>
    QuestionAnswer?: boolean | Question$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    claimListId?: boolean
    type?: boolean
    enable?: boolean
    claimList?: boolean | Question$claimListArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    question?: boolean
    claimListId?: boolean
    type?: boolean
    enable?: boolean
  }

  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimList?: boolean | Question$claimListArgs<ExtArgs>
    choices?: boolean | Question$choicesArgs<ExtArgs>
    QuestionAnswer?: boolean | Question$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimList?: boolean | Question$claimListArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      claimList: Prisma.$ClaimListPayload<ExtArgs> | null
      choices: Prisma.$ChoicePayload<ExtArgs>[]
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      claimListId: string | null
      type: $Enums.QuestionType
      enable: boolean
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claimList<T extends Question$claimListArgs<ExtArgs> = {}>(args?: Subset<T, Question$claimListArgs<ExtArgs>>): Prisma__ClaimListClient<$Result.GetResult<Prisma.$ClaimListPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    choices<T extends Question$choicesArgs<ExtArgs> = {}>(args?: Subset<T, Question$choicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findMany"> | Null>
    QuestionAnswer<T extends Question$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, Question$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */ 
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly question: FieldRef<"Question", 'String'>
    readonly claimListId: FieldRef<"Question", 'String'>
    readonly type: FieldRef<"Question", 'QuestionType'>
    readonly enable: FieldRef<"Question", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }

  /**
   * Question.claimList
   */
  export type Question$claimListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimList
     */
    select?: ClaimListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimListInclude<ExtArgs> | null
    where?: ClaimListWhereInput
  }

  /**
   * Question.choices
   */
  export type Question$choicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    where?: ChoiceWhereInput
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    cursor?: ChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Question.QuestionAnswer
   */
  export type Question$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Choice
   */

  export type AggregateChoice = {
    _count: ChoiceCountAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  export type ChoiceMinAggregateOutputType = {
    id: string | null
    text: string | null
    questionId: string | null
  }

  export type ChoiceMaxAggregateOutputType = {
    id: string | null
    text: string | null
    questionId: string | null
  }

  export type ChoiceCountAggregateOutputType = {
    id: number
    text: number
    questionId: number
    _all: number
  }


  export type ChoiceMinAggregateInputType = {
    id?: true
    text?: true
    questionId?: true
  }

  export type ChoiceMaxAggregateInputType = {
    id?: true
    text?: true
    questionId?: true
  }

  export type ChoiceCountAggregateInputType = {
    id?: true
    text?: true
    questionId?: true
    _all?: true
  }

  export type ChoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choice to aggregate.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Choices
    **/
    _count?: true | ChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoiceMaxAggregateInputType
  }

  export type GetChoiceAggregateType<T extends ChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoice[P]>
      : GetScalarType<T[P], AggregateChoice[P]>
  }




  export type ChoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceWhereInput
    orderBy?: ChoiceOrderByWithAggregationInput | ChoiceOrderByWithAggregationInput[]
    by: ChoiceScalarFieldEnum[] | ChoiceScalarFieldEnum
    having?: ChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoiceCountAggregateInputType | true
    _min?: ChoiceMinAggregateInputType
    _max?: ChoiceMaxAggregateInputType
  }

  export type ChoiceGroupByOutputType = {
    id: string
    text: string
    questionId: string
    _count: ChoiceCountAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  type GetChoiceGroupByPayload<T extends ChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
        }
      >
    >


  export type ChoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    questionId?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choice"]>

  export type ChoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    questionId?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choice"]>

  export type ChoiceSelectScalar = {
    id?: boolean
    text?: boolean
    questionId?: boolean
  }

  export type ChoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type ChoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $ChoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Choice"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      questionId: string
    }, ExtArgs["result"]["choice"]>
    composites: {}
  }

  type ChoiceGetPayload<S extends boolean | null | undefined | ChoiceDefaultArgs> = $Result.GetResult<Prisma.$ChoicePayload, S>

  type ChoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoiceCountAggregateInputType | true
    }

  export interface ChoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Choice'], meta: { name: 'Choice' } }
    /**
     * Find zero or one Choice that matches the filter.
     * @param {ChoiceFindUniqueArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoiceFindUniqueArgs>(args: SelectSubset<T, ChoiceFindUniqueArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Choice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoiceFindUniqueOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Choice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoiceFindFirstArgs>(args?: SelectSubset<T, ChoiceFindFirstArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Choice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Choices
     * const choices = await prisma.choice.findMany()
     * 
     * // Get first 10 Choices
     * const choices = await prisma.choice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choiceWithIdOnly = await prisma.choice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoiceFindManyArgs>(args?: SelectSubset<T, ChoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Choice.
     * @param {ChoiceCreateArgs} args - Arguments to create a Choice.
     * @example
     * // Create one Choice
     * const Choice = await prisma.choice.create({
     *   data: {
     *     // ... data to create a Choice
     *   }
     * })
     * 
     */
    create<T extends ChoiceCreateArgs>(args: SelectSubset<T, ChoiceCreateArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Choices.
     * @param {ChoiceCreateManyArgs} args - Arguments to create many Choices.
     * @example
     * // Create many Choices
     * const choice = await prisma.choice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoiceCreateManyArgs>(args?: SelectSubset<T, ChoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Choices and returns the data saved in the database.
     * @param {ChoiceCreateManyAndReturnArgs} args - Arguments to create many Choices.
     * @example
     * // Create many Choices
     * const choice = await prisma.choice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Choices and only return the `id`
     * const choiceWithIdOnly = await prisma.choice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ChoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Choice.
     * @param {ChoiceDeleteArgs} args - Arguments to delete one Choice.
     * @example
     * // Delete one Choice
     * const Choice = await prisma.choice.delete({
     *   where: {
     *     // ... filter to delete one Choice
     *   }
     * })
     * 
     */
    delete<T extends ChoiceDeleteArgs>(args: SelectSubset<T, ChoiceDeleteArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Choice.
     * @param {ChoiceUpdateArgs} args - Arguments to update one Choice.
     * @example
     * // Update one Choice
     * const choice = await prisma.choice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoiceUpdateArgs>(args: SelectSubset<T, ChoiceUpdateArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Choices.
     * @param {ChoiceDeleteManyArgs} args - Arguments to filter Choices to delete.
     * @example
     * // Delete a few Choices
     * const { count } = await prisma.choice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoiceDeleteManyArgs>(args?: SelectSubset<T, ChoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Choices
     * const choice = await prisma.choice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoiceUpdateManyArgs>(args: SelectSubset<T, ChoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Choice.
     * @param {ChoiceUpsertArgs} args - Arguments to update or create a Choice.
     * @example
     * // Update or create a Choice
     * const choice = await prisma.choice.upsert({
     *   create: {
     *     // ... data to create a Choice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Choice we want to update
     *   }
     * })
     */
    upsert<T extends ChoiceUpsertArgs>(args: SelectSubset<T, ChoiceUpsertArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceCountArgs} args - Arguments to filter Choices to count.
     * @example
     * // Count the number of Choices
     * const count = await prisma.choice.count({
     *   where: {
     *     // ... the filter for the Choices we want to count
     *   }
     * })
    **/
    count<T extends ChoiceCountArgs>(
      args?: Subset<T, ChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoiceAggregateArgs>(args: Subset<T, ChoiceAggregateArgs>): Prisma.PrismaPromise<GetChoiceAggregateType<T>>

    /**
     * Group by Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoiceGroupByArgs['orderBy'] }
        : { orderBy?: ChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Choice model
   */
  readonly fields: ChoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Choice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Choice model
   */ 
  interface ChoiceFieldRefs {
    readonly id: FieldRef<"Choice", 'String'>
    readonly text: FieldRef<"Choice", 'String'>
    readonly questionId: FieldRef<"Choice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Choice findUnique
   */
  export type ChoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice findUniqueOrThrow
   */
  export type ChoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice findFirst
   */
  export type ChoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Choice findFirstOrThrow
   */
  export type ChoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Choice findMany
   */
  export type ChoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choices to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Choice create
   */
  export type ChoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Choice.
     */
    data: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
  }

  /**
   * Choice createMany
   */
  export type ChoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Choices.
     */
    data: ChoiceCreateManyInput | ChoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Choice createManyAndReturn
   */
  export type ChoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Choices.
     */
    data: ChoiceCreateManyInput | ChoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Choice update
   */
  export type ChoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Choice.
     */
    data: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
    /**
     * Choose, which Choice to update.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice updateMany
   */
  export type ChoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Choices.
     */
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyInput>
    /**
     * Filter which Choices to update
     */
    where?: ChoiceWhereInput
  }

  /**
   * Choice upsert
   */
  export type ChoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Choice to update in case it exists.
     */
    where: ChoiceWhereUniqueInput
    /**
     * In case the Choice found by the `where` argument doesn't exist, create a new Choice with this data.
     */
    create: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
    /**
     * In case the Choice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
  }

  /**
   * Choice delete
   */
  export type ChoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter which Choice to delete.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice deleteMany
   */
  export type ChoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choices to delete
     */
    where?: ChoiceWhereInput
  }

  /**
   * Choice without action
   */
  export type ChoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
  }


  /**
   * Model Defendant
   */

  export type AggregateDefendant = {
    _count: DefendantCountAggregateOutputType | null
    _min: DefendantMinAggregateOutputType | null
    _max: DefendantMaxAggregateOutputType | null
  }

  export type DefendantMinAggregateOutputType = {
    id: string | null
    claimId: string | null
  }

  export type DefendantMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
  }

  export type DefendantCountAggregateOutputType = {
    id: number
    claimId: number
    _all: number
  }


  export type DefendantMinAggregateInputType = {
    id?: true
    claimId?: true
  }

  export type DefendantMaxAggregateInputType = {
    id?: true
    claimId?: true
  }

  export type DefendantCountAggregateInputType = {
    id?: true
    claimId?: true
    _all?: true
  }

  export type DefendantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defendant to aggregate.
     */
    where?: DefendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defendants to fetch.
     */
    orderBy?: DefendantOrderByWithRelationInput | DefendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Defendants
    **/
    _count?: true | DefendantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefendantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefendantMaxAggregateInputType
  }

  export type GetDefendantAggregateType<T extends DefendantAggregateArgs> = {
        [P in keyof T & keyof AggregateDefendant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefendant[P]>
      : GetScalarType<T[P], AggregateDefendant[P]>
  }




  export type DefendantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefendantWhereInput
    orderBy?: DefendantOrderByWithAggregationInput | DefendantOrderByWithAggregationInput[]
    by: DefendantScalarFieldEnum[] | DefendantScalarFieldEnum
    having?: DefendantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefendantCountAggregateInputType | true
    _min?: DefendantMinAggregateInputType
    _max?: DefendantMaxAggregateInputType
  }

  export type DefendantGroupByOutputType = {
    id: string
    claimId: string
    _count: DefendantCountAggregateOutputType | null
    _min: DefendantMinAggregateOutputType | null
    _max: DefendantMaxAggregateOutputType | null
  }

  type GetDefendantGroupByPayload<T extends DefendantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefendantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefendantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefendantGroupByOutputType[P]>
            : GetScalarType<T[P], DefendantGroupByOutputType[P]>
        }
      >
    >


  export type DefendantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    defendantDetails?: boolean | Defendant$defendantDetailsArgs<ExtArgs>
    _count?: boolean | DefendantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defendant"]>

  export type DefendantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defendant"]>

  export type DefendantSelectScalar = {
    id?: boolean
    claimId?: boolean
  }

  export type DefendantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    defendantDetails?: boolean | Defendant$defendantDetailsArgs<ExtArgs>
    _count?: boolean | DefendantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DefendantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $DefendantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Defendant"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
      defendantDetails: Prisma.$DefendantDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
    }, ExtArgs["result"]["defendant"]>
    composites: {}
  }

  type DefendantGetPayload<S extends boolean | null | undefined | DefendantDefaultArgs> = $Result.GetResult<Prisma.$DefendantPayload, S>

  type DefendantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefendantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DefendantCountAggregateInputType | true
    }

  export interface DefendantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Defendant'], meta: { name: 'Defendant' } }
    /**
     * Find zero or one Defendant that matches the filter.
     * @param {DefendantFindUniqueArgs} args - Arguments to find a Defendant
     * @example
     * // Get one Defendant
     * const defendant = await prisma.defendant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefendantFindUniqueArgs>(args: SelectSubset<T, DefendantFindUniqueArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Defendant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DefendantFindUniqueOrThrowArgs} args - Arguments to find a Defendant
     * @example
     * // Get one Defendant
     * const defendant = await prisma.defendant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefendantFindUniqueOrThrowArgs>(args: SelectSubset<T, DefendantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Defendant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantFindFirstArgs} args - Arguments to find a Defendant
     * @example
     * // Get one Defendant
     * const defendant = await prisma.defendant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefendantFindFirstArgs>(args?: SelectSubset<T, DefendantFindFirstArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Defendant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantFindFirstOrThrowArgs} args - Arguments to find a Defendant
     * @example
     * // Get one Defendant
     * const defendant = await prisma.defendant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefendantFindFirstOrThrowArgs>(args?: SelectSubset<T, DefendantFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Defendants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defendants
     * const defendants = await prisma.defendant.findMany()
     * 
     * // Get first 10 Defendants
     * const defendants = await prisma.defendant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defendantWithIdOnly = await prisma.defendant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefendantFindManyArgs>(args?: SelectSubset<T, DefendantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Defendant.
     * @param {DefendantCreateArgs} args - Arguments to create a Defendant.
     * @example
     * // Create one Defendant
     * const Defendant = await prisma.defendant.create({
     *   data: {
     *     // ... data to create a Defendant
     *   }
     * })
     * 
     */
    create<T extends DefendantCreateArgs>(args: SelectSubset<T, DefendantCreateArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Defendants.
     * @param {DefendantCreateManyArgs} args - Arguments to create many Defendants.
     * @example
     * // Create many Defendants
     * const defendant = await prisma.defendant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefendantCreateManyArgs>(args?: SelectSubset<T, DefendantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Defendants and returns the data saved in the database.
     * @param {DefendantCreateManyAndReturnArgs} args - Arguments to create many Defendants.
     * @example
     * // Create many Defendants
     * const defendant = await prisma.defendant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Defendants and only return the `id`
     * const defendantWithIdOnly = await prisma.defendant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefendantCreateManyAndReturnArgs>(args?: SelectSubset<T, DefendantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Defendant.
     * @param {DefendantDeleteArgs} args - Arguments to delete one Defendant.
     * @example
     * // Delete one Defendant
     * const Defendant = await prisma.defendant.delete({
     *   where: {
     *     // ... filter to delete one Defendant
     *   }
     * })
     * 
     */
    delete<T extends DefendantDeleteArgs>(args: SelectSubset<T, DefendantDeleteArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Defendant.
     * @param {DefendantUpdateArgs} args - Arguments to update one Defendant.
     * @example
     * // Update one Defendant
     * const defendant = await prisma.defendant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefendantUpdateArgs>(args: SelectSubset<T, DefendantUpdateArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Defendants.
     * @param {DefendantDeleteManyArgs} args - Arguments to filter Defendants to delete.
     * @example
     * // Delete a few Defendants
     * const { count } = await prisma.defendant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefendantDeleteManyArgs>(args?: SelectSubset<T, DefendantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defendants
     * const defendant = await prisma.defendant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefendantUpdateManyArgs>(args: SelectSubset<T, DefendantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Defendant.
     * @param {DefendantUpsertArgs} args - Arguments to update or create a Defendant.
     * @example
     * // Update or create a Defendant
     * const defendant = await prisma.defendant.upsert({
     *   create: {
     *     // ... data to create a Defendant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defendant we want to update
     *   }
     * })
     */
    upsert<T extends DefendantUpsertArgs>(args: SelectSubset<T, DefendantUpsertArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Defendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantCountArgs} args - Arguments to filter Defendants to count.
     * @example
     * // Count the number of Defendants
     * const count = await prisma.defendant.count({
     *   where: {
     *     // ... the filter for the Defendants we want to count
     *   }
     * })
    **/
    count<T extends DefendantCountArgs>(
      args?: Subset<T, DefendantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefendantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defendant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefendantAggregateArgs>(args: Subset<T, DefendantAggregateArgs>): Prisma.PrismaPromise<GetDefendantAggregateType<T>>

    /**
     * Group by Defendant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefendantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefendantGroupByArgs['orderBy'] }
        : { orderBy?: DefendantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefendantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefendantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Defendant model
   */
  readonly fields: DefendantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Defendant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefendantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    defendantDetails<T extends Defendant$defendantDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Defendant$defendantDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Defendant model
   */ 
  interface DefendantFieldRefs {
    readonly id: FieldRef<"Defendant", 'String'>
    readonly claimId: FieldRef<"Defendant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Defendant findUnique
   */
  export type DefendantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * Filter, which Defendant to fetch.
     */
    where: DefendantWhereUniqueInput
  }

  /**
   * Defendant findUniqueOrThrow
   */
  export type DefendantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * Filter, which Defendant to fetch.
     */
    where: DefendantWhereUniqueInput
  }

  /**
   * Defendant findFirst
   */
  export type DefendantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * Filter, which Defendant to fetch.
     */
    where?: DefendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defendants to fetch.
     */
    orderBy?: DefendantOrderByWithRelationInput | DefendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defendants.
     */
    cursor?: DefendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defendants.
     */
    distinct?: DefendantScalarFieldEnum | DefendantScalarFieldEnum[]
  }

  /**
   * Defendant findFirstOrThrow
   */
  export type DefendantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * Filter, which Defendant to fetch.
     */
    where?: DefendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defendants to fetch.
     */
    orderBy?: DefendantOrderByWithRelationInput | DefendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defendants.
     */
    cursor?: DefendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defendants.
     */
    distinct?: DefendantScalarFieldEnum | DefendantScalarFieldEnum[]
  }

  /**
   * Defendant findMany
   */
  export type DefendantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * Filter, which Defendants to fetch.
     */
    where?: DefendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defendants to fetch.
     */
    orderBy?: DefendantOrderByWithRelationInput | DefendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Defendants.
     */
    cursor?: DefendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defendants.
     */
    skip?: number
    distinct?: DefendantScalarFieldEnum | DefendantScalarFieldEnum[]
  }

  /**
   * Defendant create
   */
  export type DefendantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * The data needed to create a Defendant.
     */
    data: XOR<DefendantCreateInput, DefendantUncheckedCreateInput>
  }

  /**
   * Defendant createMany
   */
  export type DefendantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Defendants.
     */
    data: DefendantCreateManyInput | DefendantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Defendant createManyAndReturn
   */
  export type DefendantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Defendants.
     */
    data: DefendantCreateManyInput | DefendantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Defendant update
   */
  export type DefendantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * The data needed to update a Defendant.
     */
    data: XOR<DefendantUpdateInput, DefendantUncheckedUpdateInput>
    /**
     * Choose, which Defendant to update.
     */
    where: DefendantWhereUniqueInput
  }

  /**
   * Defendant updateMany
   */
  export type DefendantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Defendants.
     */
    data: XOR<DefendantUpdateManyMutationInput, DefendantUncheckedUpdateManyInput>
    /**
     * Filter which Defendants to update
     */
    where?: DefendantWhereInput
  }

  /**
   * Defendant upsert
   */
  export type DefendantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * The filter to search for the Defendant to update in case it exists.
     */
    where: DefendantWhereUniqueInput
    /**
     * In case the Defendant found by the `where` argument doesn't exist, create a new Defendant with this data.
     */
    create: XOR<DefendantCreateInput, DefendantUncheckedCreateInput>
    /**
     * In case the Defendant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefendantUpdateInput, DefendantUncheckedUpdateInput>
  }

  /**
   * Defendant delete
   */
  export type DefendantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
    /**
     * Filter which Defendant to delete.
     */
    where: DefendantWhereUniqueInput
  }

  /**
   * Defendant deleteMany
   */
  export type DefendantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defendants to delete
     */
    where?: DefendantWhereInput
  }

  /**
   * Defendant.defendantDetails
   */
  export type Defendant$defendantDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    where?: DefendantDetailsWhereInput
    orderBy?: DefendantDetailsOrderByWithRelationInput | DefendantDetailsOrderByWithRelationInput[]
    cursor?: DefendantDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefendantDetailsScalarFieldEnum | DefendantDetailsScalarFieldEnum[]
  }

  /**
   * Defendant without action
   */
  export type DefendantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defendant
     */
    select?: DefendantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantInclude<ExtArgs> | null
  }


  /**
   * Model DefendantDetails
   */

  export type AggregateDefendantDetails = {
    _count: DefendantDetailsCountAggregateOutputType | null
    _avg: DefendantDetailsAvgAggregateOutputType | null
    _sum: DefendantDetailsSumAggregateOutputType | null
    _min: DefendantDetailsMinAggregateOutputType | null
    _max: DefendantDetailsMaxAggregateOutputType | null
  }

  export type DefendantDetailsAvgAggregateOutputType = {
    sort: number | null
  }

  export type DefendantDetailsSumAggregateOutputType = {
    sort: number | null
  }

  export type DefendantDetailsMinAggregateOutputType = {
    id: string | null
    defendantRole: $Enums.DefendantRole | null
    defendantAccountId: string | null
    defendantInsuranceCarrierId: string | null
    insurancePolicyNumber: string | null
    driverLicenseNumber: string | null
    driverLicenseState: string | null
    vehicleMake: string | null
    vehicleModel: string | null
    vehicleYear: string | null
    vehicleColor: string | null
    vehiclePlate: string | null
    vehiclePosition: string | null
    vehicleRegisteredState: string | null
    collisionType: $Enums.CollisionType | null
    supervisorName: string | null
    supervisorContact: string | null
    client: boolean | null
    groupId: string | null
    sort: number | null
    defendantId: string | null
  }

  export type DefendantDetailsMaxAggregateOutputType = {
    id: string | null
    defendantRole: $Enums.DefendantRole | null
    defendantAccountId: string | null
    defendantInsuranceCarrierId: string | null
    insurancePolicyNumber: string | null
    driverLicenseNumber: string | null
    driverLicenseState: string | null
    vehicleMake: string | null
    vehicleModel: string | null
    vehicleYear: string | null
    vehicleColor: string | null
    vehiclePlate: string | null
    vehiclePosition: string | null
    vehicleRegisteredState: string | null
    collisionType: $Enums.CollisionType | null
    supervisorName: string | null
    supervisorContact: string | null
    client: boolean | null
    groupId: string | null
    sort: number | null
    defendantId: string | null
  }

  export type DefendantDetailsCountAggregateOutputType = {
    id: number
    defendantRole: number
    defendantAccountId: number
    defendantInsuranceCarrierId: number
    insurancePolicyNumber: number
    driverLicenseNumber: number
    driverLicenseState: number
    vehicleMake: number
    vehicleModel: number
    vehicleYear: number
    vehicleColor: number
    vehiclePlate: number
    vehiclePosition: number
    vehicleRegisteredState: number
    collisionType: number
    supervisorName: number
    supervisorContact: number
    client: number
    groupId: number
    sort: number
    defendantId: number
    _all: number
  }


  export type DefendantDetailsAvgAggregateInputType = {
    sort?: true
  }

  export type DefendantDetailsSumAggregateInputType = {
    sort?: true
  }

  export type DefendantDetailsMinAggregateInputType = {
    id?: true
    defendantRole?: true
    defendantAccountId?: true
    defendantInsuranceCarrierId?: true
    insurancePolicyNumber?: true
    driverLicenseNumber?: true
    driverLicenseState?: true
    vehicleMake?: true
    vehicleModel?: true
    vehicleYear?: true
    vehicleColor?: true
    vehiclePlate?: true
    vehiclePosition?: true
    vehicleRegisteredState?: true
    collisionType?: true
    supervisorName?: true
    supervisorContact?: true
    client?: true
    groupId?: true
    sort?: true
    defendantId?: true
  }

  export type DefendantDetailsMaxAggregateInputType = {
    id?: true
    defendantRole?: true
    defendantAccountId?: true
    defendantInsuranceCarrierId?: true
    insurancePolicyNumber?: true
    driverLicenseNumber?: true
    driverLicenseState?: true
    vehicleMake?: true
    vehicleModel?: true
    vehicleYear?: true
    vehicleColor?: true
    vehiclePlate?: true
    vehiclePosition?: true
    vehicleRegisteredState?: true
    collisionType?: true
    supervisorName?: true
    supervisorContact?: true
    client?: true
    groupId?: true
    sort?: true
    defendantId?: true
  }

  export type DefendantDetailsCountAggregateInputType = {
    id?: true
    defendantRole?: true
    defendantAccountId?: true
    defendantInsuranceCarrierId?: true
    insurancePolicyNumber?: true
    driverLicenseNumber?: true
    driverLicenseState?: true
    vehicleMake?: true
    vehicleModel?: true
    vehicleYear?: true
    vehicleColor?: true
    vehiclePlate?: true
    vehiclePosition?: true
    vehicleRegisteredState?: true
    collisionType?: true
    supervisorName?: true
    supervisorContact?: true
    client?: true
    groupId?: true
    sort?: true
    defendantId?: true
    _all?: true
  }

  export type DefendantDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefendantDetails to aggregate.
     */
    where?: DefendantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefendantDetails to fetch.
     */
    orderBy?: DefendantDetailsOrderByWithRelationInput | DefendantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefendantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefendantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefendantDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefendantDetails
    **/
    _count?: true | DefendantDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefendantDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefendantDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefendantDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefendantDetailsMaxAggregateInputType
  }

  export type GetDefendantDetailsAggregateType<T extends DefendantDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateDefendantDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefendantDetails[P]>
      : GetScalarType<T[P], AggregateDefendantDetails[P]>
  }




  export type DefendantDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefendantDetailsWhereInput
    orderBy?: DefendantDetailsOrderByWithAggregationInput | DefendantDetailsOrderByWithAggregationInput[]
    by: DefendantDetailsScalarFieldEnum[] | DefendantDetailsScalarFieldEnum
    having?: DefendantDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefendantDetailsCountAggregateInputType | true
    _avg?: DefendantDetailsAvgAggregateInputType
    _sum?: DefendantDetailsSumAggregateInputType
    _min?: DefendantDetailsMinAggregateInputType
    _max?: DefendantDetailsMaxAggregateInputType
  }

  export type DefendantDetailsGroupByOutputType = {
    id: string
    defendantRole: $Enums.DefendantRole
    defendantAccountId: string
    defendantInsuranceCarrierId: string | null
    insurancePolicyNumber: string | null
    driverLicenseNumber: string | null
    driverLicenseState: string | null
    vehicleMake: string | null
    vehicleModel: string | null
    vehicleYear: string | null
    vehicleColor: string | null
    vehiclePlate: string | null
    vehiclePosition: string | null
    vehicleRegisteredState: string | null
    collisionType: $Enums.CollisionType | null
    supervisorName: string | null
    supervisorContact: string | null
    client: boolean
    groupId: string | null
    sort: number
    defendantId: string
    _count: DefendantDetailsCountAggregateOutputType | null
    _avg: DefendantDetailsAvgAggregateOutputType | null
    _sum: DefendantDetailsSumAggregateOutputType | null
    _min: DefendantDetailsMinAggregateOutputType | null
    _max: DefendantDetailsMaxAggregateOutputType | null
  }

  type GetDefendantDetailsGroupByPayload<T extends DefendantDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefendantDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefendantDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefendantDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], DefendantDetailsGroupByOutputType[P]>
        }
      >
    >


  export type DefendantDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defendantRole?: boolean
    defendantAccountId?: boolean
    defendantInsuranceCarrierId?: boolean
    insurancePolicyNumber?: boolean
    driverLicenseNumber?: boolean
    driverLicenseState?: boolean
    vehicleMake?: boolean
    vehicleModel?: boolean
    vehicleYear?: boolean
    vehicleColor?: boolean
    vehiclePlate?: boolean
    vehiclePosition?: boolean
    vehicleRegisteredState?: boolean
    collisionType?: boolean
    supervisorName?: boolean
    supervisorContact?: boolean
    client?: boolean
    groupId?: boolean
    sort?: boolean
    defendantId?: boolean
    defendantAccount?: boolean | RoleDefaultArgs<ExtArgs>
    defendantInsuranceCarrier?: boolean | DefendantDetails$defendantInsuranceCarrierArgs<ExtArgs>
    defendant?: boolean | DefendantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defendantDetails"]>

  export type DefendantDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defendantRole?: boolean
    defendantAccountId?: boolean
    defendantInsuranceCarrierId?: boolean
    insurancePolicyNumber?: boolean
    driverLicenseNumber?: boolean
    driverLicenseState?: boolean
    vehicleMake?: boolean
    vehicleModel?: boolean
    vehicleYear?: boolean
    vehicleColor?: boolean
    vehiclePlate?: boolean
    vehiclePosition?: boolean
    vehicleRegisteredState?: boolean
    collisionType?: boolean
    supervisorName?: boolean
    supervisorContact?: boolean
    client?: boolean
    groupId?: boolean
    sort?: boolean
    defendantId?: boolean
    defendantAccount?: boolean | RoleDefaultArgs<ExtArgs>
    defendantInsuranceCarrier?: boolean | DefendantDetails$defendantInsuranceCarrierArgs<ExtArgs>
    defendant?: boolean | DefendantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defendantDetails"]>

  export type DefendantDetailsSelectScalar = {
    id?: boolean
    defendantRole?: boolean
    defendantAccountId?: boolean
    defendantInsuranceCarrierId?: boolean
    insurancePolicyNumber?: boolean
    driverLicenseNumber?: boolean
    driverLicenseState?: boolean
    vehicleMake?: boolean
    vehicleModel?: boolean
    vehicleYear?: boolean
    vehicleColor?: boolean
    vehiclePlate?: boolean
    vehiclePosition?: boolean
    vehicleRegisteredState?: boolean
    collisionType?: boolean
    supervisorName?: boolean
    supervisorContact?: boolean
    client?: boolean
    groupId?: boolean
    sort?: boolean
    defendantId?: boolean
  }

  export type DefendantDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defendantAccount?: boolean | RoleDefaultArgs<ExtArgs>
    defendantInsuranceCarrier?: boolean | DefendantDetails$defendantInsuranceCarrierArgs<ExtArgs>
    defendant?: boolean | DefendantDefaultArgs<ExtArgs>
  }
  export type DefendantDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defendantAccount?: boolean | RoleDefaultArgs<ExtArgs>
    defendantInsuranceCarrier?: boolean | DefendantDetails$defendantInsuranceCarrierArgs<ExtArgs>
    defendant?: boolean | DefendantDefaultArgs<ExtArgs>
  }

  export type $DefendantDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefendantDetails"
    objects: {
      defendantAccount: Prisma.$RolePayload<ExtArgs>
      defendantInsuranceCarrier: Prisma.$RolePayload<ExtArgs> | null
      defendant: Prisma.$DefendantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      defendantRole: $Enums.DefendantRole
      defendantAccountId: string
      defendantInsuranceCarrierId: string | null
      insurancePolicyNumber: string | null
      driverLicenseNumber: string | null
      driverLicenseState: string | null
      vehicleMake: string | null
      vehicleModel: string | null
      vehicleYear: string | null
      vehicleColor: string | null
      vehiclePlate: string | null
      vehiclePosition: string | null
      vehicleRegisteredState: string | null
      collisionType: $Enums.CollisionType | null
      supervisorName: string | null
      supervisorContact: string | null
      client: boolean
      groupId: string | null
      sort: number
      defendantId: string
    }, ExtArgs["result"]["defendantDetails"]>
    composites: {}
  }

  type DefendantDetailsGetPayload<S extends boolean | null | undefined | DefendantDetailsDefaultArgs> = $Result.GetResult<Prisma.$DefendantDetailsPayload, S>

  type DefendantDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefendantDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DefendantDetailsCountAggregateInputType | true
    }

  export interface DefendantDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefendantDetails'], meta: { name: 'DefendantDetails' } }
    /**
     * Find zero or one DefendantDetails that matches the filter.
     * @param {DefendantDetailsFindUniqueArgs} args - Arguments to find a DefendantDetails
     * @example
     * // Get one DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefendantDetailsFindUniqueArgs>(args: SelectSubset<T, DefendantDetailsFindUniqueArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DefendantDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DefendantDetailsFindUniqueOrThrowArgs} args - Arguments to find a DefendantDetails
     * @example
     * // Get one DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefendantDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, DefendantDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DefendantDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantDetailsFindFirstArgs} args - Arguments to find a DefendantDetails
     * @example
     * // Get one DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefendantDetailsFindFirstArgs>(args?: SelectSubset<T, DefendantDetailsFindFirstArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DefendantDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantDetailsFindFirstOrThrowArgs} args - Arguments to find a DefendantDetails
     * @example
     * // Get one DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefendantDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, DefendantDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DefendantDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.findMany()
     * 
     * // Get first 10 DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defendantDetailsWithIdOnly = await prisma.defendantDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefendantDetailsFindManyArgs>(args?: SelectSubset<T, DefendantDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DefendantDetails.
     * @param {DefendantDetailsCreateArgs} args - Arguments to create a DefendantDetails.
     * @example
     * // Create one DefendantDetails
     * const DefendantDetails = await prisma.defendantDetails.create({
     *   data: {
     *     // ... data to create a DefendantDetails
     *   }
     * })
     * 
     */
    create<T extends DefendantDetailsCreateArgs>(args: SelectSubset<T, DefendantDetailsCreateArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DefendantDetails.
     * @param {DefendantDetailsCreateManyArgs} args - Arguments to create many DefendantDetails.
     * @example
     * // Create many DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefendantDetailsCreateManyArgs>(args?: SelectSubset<T, DefendantDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DefendantDetails and returns the data saved in the database.
     * @param {DefendantDetailsCreateManyAndReturnArgs} args - Arguments to create many DefendantDetails.
     * @example
     * // Create many DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DefendantDetails and only return the `id`
     * const defendantDetailsWithIdOnly = await prisma.defendantDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefendantDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, DefendantDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DefendantDetails.
     * @param {DefendantDetailsDeleteArgs} args - Arguments to delete one DefendantDetails.
     * @example
     * // Delete one DefendantDetails
     * const DefendantDetails = await prisma.defendantDetails.delete({
     *   where: {
     *     // ... filter to delete one DefendantDetails
     *   }
     * })
     * 
     */
    delete<T extends DefendantDetailsDeleteArgs>(args: SelectSubset<T, DefendantDetailsDeleteArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DefendantDetails.
     * @param {DefendantDetailsUpdateArgs} args - Arguments to update one DefendantDetails.
     * @example
     * // Update one DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefendantDetailsUpdateArgs>(args: SelectSubset<T, DefendantDetailsUpdateArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DefendantDetails.
     * @param {DefendantDetailsDeleteManyArgs} args - Arguments to filter DefendantDetails to delete.
     * @example
     * // Delete a few DefendantDetails
     * const { count } = await prisma.defendantDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefendantDetailsDeleteManyArgs>(args?: SelectSubset<T, DefendantDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefendantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefendantDetailsUpdateManyArgs>(args: SelectSubset<T, DefendantDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DefendantDetails.
     * @param {DefendantDetailsUpsertArgs} args - Arguments to update or create a DefendantDetails.
     * @example
     * // Update or create a DefendantDetails
     * const defendantDetails = await prisma.defendantDetails.upsert({
     *   create: {
     *     // ... data to create a DefendantDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefendantDetails we want to update
     *   }
     * })
     */
    upsert<T extends DefendantDetailsUpsertArgs>(args: SelectSubset<T, DefendantDetailsUpsertArgs<ExtArgs>>): Prisma__DefendantDetailsClient<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DefendantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantDetailsCountArgs} args - Arguments to filter DefendantDetails to count.
     * @example
     * // Count the number of DefendantDetails
     * const count = await prisma.defendantDetails.count({
     *   where: {
     *     // ... the filter for the DefendantDetails we want to count
     *   }
     * })
    **/
    count<T extends DefendantDetailsCountArgs>(
      args?: Subset<T, DefendantDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefendantDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefendantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefendantDetailsAggregateArgs>(args: Subset<T, DefendantDetailsAggregateArgs>): Prisma.PrismaPromise<GetDefendantDetailsAggregateType<T>>

    /**
     * Group by DefendantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefendantDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefendantDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefendantDetailsGroupByArgs['orderBy'] }
        : { orderBy?: DefendantDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefendantDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefendantDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefendantDetails model
   */
  readonly fields: DefendantDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefendantDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefendantDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defendantAccount<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    defendantInsuranceCarrier<T extends DefendantDetails$defendantInsuranceCarrierArgs<ExtArgs> = {}>(args?: Subset<T, DefendantDetails$defendantInsuranceCarrierArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    defendant<T extends DefendantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DefendantDefaultArgs<ExtArgs>>): Prisma__DefendantClient<$Result.GetResult<Prisma.$DefendantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefendantDetails model
   */ 
  interface DefendantDetailsFieldRefs {
    readonly id: FieldRef<"DefendantDetails", 'String'>
    readonly defendantRole: FieldRef<"DefendantDetails", 'DefendantRole'>
    readonly defendantAccountId: FieldRef<"DefendantDetails", 'String'>
    readonly defendantInsuranceCarrierId: FieldRef<"DefendantDetails", 'String'>
    readonly insurancePolicyNumber: FieldRef<"DefendantDetails", 'String'>
    readonly driverLicenseNumber: FieldRef<"DefendantDetails", 'String'>
    readonly driverLicenseState: FieldRef<"DefendantDetails", 'String'>
    readonly vehicleMake: FieldRef<"DefendantDetails", 'String'>
    readonly vehicleModel: FieldRef<"DefendantDetails", 'String'>
    readonly vehicleYear: FieldRef<"DefendantDetails", 'String'>
    readonly vehicleColor: FieldRef<"DefendantDetails", 'String'>
    readonly vehiclePlate: FieldRef<"DefendantDetails", 'String'>
    readonly vehiclePosition: FieldRef<"DefendantDetails", 'String'>
    readonly vehicleRegisteredState: FieldRef<"DefendantDetails", 'String'>
    readonly collisionType: FieldRef<"DefendantDetails", 'CollisionType'>
    readonly supervisorName: FieldRef<"DefendantDetails", 'String'>
    readonly supervisorContact: FieldRef<"DefendantDetails", 'String'>
    readonly client: FieldRef<"DefendantDetails", 'Boolean'>
    readonly groupId: FieldRef<"DefendantDetails", 'String'>
    readonly sort: FieldRef<"DefendantDetails", 'Int'>
    readonly defendantId: FieldRef<"DefendantDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DefendantDetails findUnique
   */
  export type DefendantDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which DefendantDetails to fetch.
     */
    where: DefendantDetailsWhereUniqueInput
  }

  /**
   * DefendantDetails findUniqueOrThrow
   */
  export type DefendantDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which DefendantDetails to fetch.
     */
    where: DefendantDetailsWhereUniqueInput
  }

  /**
   * DefendantDetails findFirst
   */
  export type DefendantDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which DefendantDetails to fetch.
     */
    where?: DefendantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefendantDetails to fetch.
     */
    orderBy?: DefendantDetailsOrderByWithRelationInput | DefendantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefendantDetails.
     */
    cursor?: DefendantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefendantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefendantDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefendantDetails.
     */
    distinct?: DefendantDetailsScalarFieldEnum | DefendantDetailsScalarFieldEnum[]
  }

  /**
   * DefendantDetails findFirstOrThrow
   */
  export type DefendantDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which DefendantDetails to fetch.
     */
    where?: DefendantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefendantDetails to fetch.
     */
    orderBy?: DefendantDetailsOrderByWithRelationInput | DefendantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefendantDetails.
     */
    cursor?: DefendantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefendantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefendantDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefendantDetails.
     */
    distinct?: DefendantDetailsScalarFieldEnum | DefendantDetailsScalarFieldEnum[]
  }

  /**
   * DefendantDetails findMany
   */
  export type DefendantDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which DefendantDetails to fetch.
     */
    where?: DefendantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefendantDetails to fetch.
     */
    orderBy?: DefendantDetailsOrderByWithRelationInput | DefendantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefendantDetails.
     */
    cursor?: DefendantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefendantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefendantDetails.
     */
    skip?: number
    distinct?: DefendantDetailsScalarFieldEnum | DefendantDetailsScalarFieldEnum[]
  }

  /**
   * DefendantDetails create
   */
  export type DefendantDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a DefendantDetails.
     */
    data: XOR<DefendantDetailsCreateInput, DefendantDetailsUncheckedCreateInput>
  }

  /**
   * DefendantDetails createMany
   */
  export type DefendantDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefendantDetails.
     */
    data: DefendantDetailsCreateManyInput | DefendantDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DefendantDetails createManyAndReturn
   */
  export type DefendantDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DefendantDetails.
     */
    data: DefendantDetailsCreateManyInput | DefendantDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefendantDetails update
   */
  export type DefendantDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a DefendantDetails.
     */
    data: XOR<DefendantDetailsUpdateInput, DefendantDetailsUncheckedUpdateInput>
    /**
     * Choose, which DefendantDetails to update.
     */
    where: DefendantDetailsWhereUniqueInput
  }

  /**
   * DefendantDetails updateMany
   */
  export type DefendantDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefendantDetails.
     */
    data: XOR<DefendantDetailsUpdateManyMutationInput, DefendantDetailsUncheckedUpdateManyInput>
    /**
     * Filter which DefendantDetails to update
     */
    where?: DefendantDetailsWhereInput
  }

  /**
   * DefendantDetails upsert
   */
  export type DefendantDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the DefendantDetails to update in case it exists.
     */
    where: DefendantDetailsWhereUniqueInput
    /**
     * In case the DefendantDetails found by the `where` argument doesn't exist, create a new DefendantDetails with this data.
     */
    create: XOR<DefendantDetailsCreateInput, DefendantDetailsUncheckedCreateInput>
    /**
     * In case the DefendantDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefendantDetailsUpdateInput, DefendantDetailsUncheckedUpdateInput>
  }

  /**
   * DefendantDetails delete
   */
  export type DefendantDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    /**
     * Filter which DefendantDetails to delete.
     */
    where: DefendantDetailsWhereUniqueInput
  }

  /**
   * DefendantDetails deleteMany
   */
  export type DefendantDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefendantDetails to delete
     */
    where?: DefendantDetailsWhereInput
  }

  /**
   * DefendantDetails.defendantInsuranceCarrier
   */
  export type DefendantDetails$defendantInsuranceCarrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * DefendantDetails without action
   */
  export type DefendantDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
  }


  /**
   * Model TreatmentAndInjury
   */

  export type AggregateTreatmentAndInjury = {
    _count: TreatmentAndInjuryCountAggregateOutputType | null
    _min: TreatmentAndInjuryMinAggregateOutputType | null
    _max: TreatmentAndInjuryMaxAggregateOutputType | null
  }

  export type TreatmentAndInjuryMinAggregateOutputType = {
    id: string | null
    claimId: string | null
    treatmentId: string | null
  }

  export type TreatmentAndInjuryMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
    treatmentId: string | null
  }

  export type TreatmentAndInjuryCountAggregateOutputType = {
    id: number
    claimId: number
    treatmentId: number
    _all: number
  }


  export type TreatmentAndInjuryMinAggregateInputType = {
    id?: true
    claimId?: true
    treatmentId?: true
  }

  export type TreatmentAndInjuryMaxAggregateInputType = {
    id?: true
    claimId?: true
    treatmentId?: true
  }

  export type TreatmentAndInjuryCountAggregateInputType = {
    id?: true
    claimId?: true
    treatmentId?: true
    _all?: true
  }

  export type TreatmentAndInjuryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreatmentAndInjury to aggregate.
     */
    where?: TreatmentAndInjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentAndInjuries to fetch.
     */
    orderBy?: TreatmentAndInjuryOrderByWithRelationInput | TreatmentAndInjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreatmentAndInjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentAndInjuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentAndInjuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TreatmentAndInjuries
    **/
    _count?: true | TreatmentAndInjuryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreatmentAndInjuryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreatmentAndInjuryMaxAggregateInputType
  }

  export type GetTreatmentAndInjuryAggregateType<T extends TreatmentAndInjuryAggregateArgs> = {
        [P in keyof T & keyof AggregateTreatmentAndInjury]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreatmentAndInjury[P]>
      : GetScalarType<T[P], AggregateTreatmentAndInjury[P]>
  }




  export type TreatmentAndInjuryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentAndInjuryWhereInput
    orderBy?: TreatmentAndInjuryOrderByWithAggregationInput | TreatmentAndInjuryOrderByWithAggregationInput[]
    by: TreatmentAndInjuryScalarFieldEnum[] | TreatmentAndInjuryScalarFieldEnum
    having?: TreatmentAndInjuryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreatmentAndInjuryCountAggregateInputType | true
    _min?: TreatmentAndInjuryMinAggregateInputType
    _max?: TreatmentAndInjuryMaxAggregateInputType
  }

  export type TreatmentAndInjuryGroupByOutputType = {
    id: string
    claimId: string
    treatmentId: string
    _count: TreatmentAndInjuryCountAggregateOutputType | null
    _min: TreatmentAndInjuryMinAggregateOutputType | null
    _max: TreatmentAndInjuryMaxAggregateOutputType | null
  }

  type GetTreatmentAndInjuryGroupByPayload<T extends TreatmentAndInjuryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreatmentAndInjuryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreatmentAndInjuryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreatmentAndInjuryGroupByOutputType[P]>
            : GetScalarType<T[P], TreatmentAndInjuryGroupByOutputType[P]>
        }
      >
    >


  export type TreatmentAndInjurySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    treatmentId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentAndInjury"]>

  export type TreatmentAndInjurySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    treatmentId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentAndInjury"]>

  export type TreatmentAndInjurySelectScalar = {
    id?: boolean
    claimId?: boolean
    treatmentId?: boolean
  }

  export type TreatmentAndInjuryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }
  export type TreatmentAndInjuryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }

  export type $TreatmentAndInjuryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TreatmentAndInjury"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
      treatment: Prisma.$TreatmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
      treatmentId: string
    }, ExtArgs["result"]["treatmentAndInjury"]>
    composites: {}
  }

  type TreatmentAndInjuryGetPayload<S extends boolean | null | undefined | TreatmentAndInjuryDefaultArgs> = $Result.GetResult<Prisma.$TreatmentAndInjuryPayload, S>

  type TreatmentAndInjuryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TreatmentAndInjuryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TreatmentAndInjuryCountAggregateInputType | true
    }

  export interface TreatmentAndInjuryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TreatmentAndInjury'], meta: { name: 'TreatmentAndInjury' } }
    /**
     * Find zero or one TreatmentAndInjury that matches the filter.
     * @param {TreatmentAndInjuryFindUniqueArgs} args - Arguments to find a TreatmentAndInjury
     * @example
     * // Get one TreatmentAndInjury
     * const treatmentAndInjury = await prisma.treatmentAndInjury.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreatmentAndInjuryFindUniqueArgs>(args: SelectSubset<T, TreatmentAndInjuryFindUniqueArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TreatmentAndInjury that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TreatmentAndInjuryFindUniqueOrThrowArgs} args - Arguments to find a TreatmentAndInjury
     * @example
     * // Get one TreatmentAndInjury
     * const treatmentAndInjury = await prisma.treatmentAndInjury.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreatmentAndInjuryFindUniqueOrThrowArgs>(args: SelectSubset<T, TreatmentAndInjuryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TreatmentAndInjury that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAndInjuryFindFirstArgs} args - Arguments to find a TreatmentAndInjury
     * @example
     * // Get one TreatmentAndInjury
     * const treatmentAndInjury = await prisma.treatmentAndInjury.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreatmentAndInjuryFindFirstArgs>(args?: SelectSubset<T, TreatmentAndInjuryFindFirstArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TreatmentAndInjury that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAndInjuryFindFirstOrThrowArgs} args - Arguments to find a TreatmentAndInjury
     * @example
     * // Get one TreatmentAndInjury
     * const treatmentAndInjury = await prisma.treatmentAndInjury.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreatmentAndInjuryFindFirstOrThrowArgs>(args?: SelectSubset<T, TreatmentAndInjuryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TreatmentAndInjuries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAndInjuryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TreatmentAndInjuries
     * const treatmentAndInjuries = await prisma.treatmentAndInjury.findMany()
     * 
     * // Get first 10 TreatmentAndInjuries
     * const treatmentAndInjuries = await prisma.treatmentAndInjury.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treatmentAndInjuryWithIdOnly = await prisma.treatmentAndInjury.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreatmentAndInjuryFindManyArgs>(args?: SelectSubset<T, TreatmentAndInjuryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TreatmentAndInjury.
     * @param {TreatmentAndInjuryCreateArgs} args - Arguments to create a TreatmentAndInjury.
     * @example
     * // Create one TreatmentAndInjury
     * const TreatmentAndInjury = await prisma.treatmentAndInjury.create({
     *   data: {
     *     // ... data to create a TreatmentAndInjury
     *   }
     * })
     * 
     */
    create<T extends TreatmentAndInjuryCreateArgs>(args: SelectSubset<T, TreatmentAndInjuryCreateArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TreatmentAndInjuries.
     * @param {TreatmentAndInjuryCreateManyArgs} args - Arguments to create many TreatmentAndInjuries.
     * @example
     * // Create many TreatmentAndInjuries
     * const treatmentAndInjury = await prisma.treatmentAndInjury.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreatmentAndInjuryCreateManyArgs>(args?: SelectSubset<T, TreatmentAndInjuryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TreatmentAndInjuries and returns the data saved in the database.
     * @param {TreatmentAndInjuryCreateManyAndReturnArgs} args - Arguments to create many TreatmentAndInjuries.
     * @example
     * // Create many TreatmentAndInjuries
     * const treatmentAndInjury = await prisma.treatmentAndInjury.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TreatmentAndInjuries and only return the `id`
     * const treatmentAndInjuryWithIdOnly = await prisma.treatmentAndInjury.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreatmentAndInjuryCreateManyAndReturnArgs>(args?: SelectSubset<T, TreatmentAndInjuryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TreatmentAndInjury.
     * @param {TreatmentAndInjuryDeleteArgs} args - Arguments to delete one TreatmentAndInjury.
     * @example
     * // Delete one TreatmentAndInjury
     * const TreatmentAndInjury = await prisma.treatmentAndInjury.delete({
     *   where: {
     *     // ... filter to delete one TreatmentAndInjury
     *   }
     * })
     * 
     */
    delete<T extends TreatmentAndInjuryDeleteArgs>(args: SelectSubset<T, TreatmentAndInjuryDeleteArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TreatmentAndInjury.
     * @param {TreatmentAndInjuryUpdateArgs} args - Arguments to update one TreatmentAndInjury.
     * @example
     * // Update one TreatmentAndInjury
     * const treatmentAndInjury = await prisma.treatmentAndInjury.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreatmentAndInjuryUpdateArgs>(args: SelectSubset<T, TreatmentAndInjuryUpdateArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TreatmentAndInjuries.
     * @param {TreatmentAndInjuryDeleteManyArgs} args - Arguments to filter TreatmentAndInjuries to delete.
     * @example
     * // Delete a few TreatmentAndInjuries
     * const { count } = await prisma.treatmentAndInjury.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreatmentAndInjuryDeleteManyArgs>(args?: SelectSubset<T, TreatmentAndInjuryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreatmentAndInjuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAndInjuryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TreatmentAndInjuries
     * const treatmentAndInjury = await prisma.treatmentAndInjury.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreatmentAndInjuryUpdateManyArgs>(args: SelectSubset<T, TreatmentAndInjuryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TreatmentAndInjury.
     * @param {TreatmentAndInjuryUpsertArgs} args - Arguments to update or create a TreatmentAndInjury.
     * @example
     * // Update or create a TreatmentAndInjury
     * const treatmentAndInjury = await prisma.treatmentAndInjury.upsert({
     *   create: {
     *     // ... data to create a TreatmentAndInjury
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TreatmentAndInjury we want to update
     *   }
     * })
     */
    upsert<T extends TreatmentAndInjuryUpsertArgs>(args: SelectSubset<T, TreatmentAndInjuryUpsertArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TreatmentAndInjuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAndInjuryCountArgs} args - Arguments to filter TreatmentAndInjuries to count.
     * @example
     * // Count the number of TreatmentAndInjuries
     * const count = await prisma.treatmentAndInjury.count({
     *   where: {
     *     // ... the filter for the TreatmentAndInjuries we want to count
     *   }
     * })
    **/
    count<T extends TreatmentAndInjuryCountArgs>(
      args?: Subset<T, TreatmentAndInjuryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreatmentAndInjuryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TreatmentAndInjury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAndInjuryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreatmentAndInjuryAggregateArgs>(args: Subset<T, TreatmentAndInjuryAggregateArgs>): Prisma.PrismaPromise<GetTreatmentAndInjuryAggregateType<T>>

    /**
     * Group by TreatmentAndInjury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAndInjuryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreatmentAndInjuryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreatmentAndInjuryGroupByArgs['orderBy'] }
        : { orderBy?: TreatmentAndInjuryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreatmentAndInjuryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreatmentAndInjuryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TreatmentAndInjury model
   */
  readonly fields: TreatmentAndInjuryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TreatmentAndInjury.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreatmentAndInjuryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    treatment<T extends TreatmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TreatmentDefaultArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TreatmentAndInjury model
   */ 
  interface TreatmentAndInjuryFieldRefs {
    readonly id: FieldRef<"TreatmentAndInjury", 'String'>
    readonly claimId: FieldRef<"TreatmentAndInjury", 'String'>
    readonly treatmentId: FieldRef<"TreatmentAndInjury", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TreatmentAndInjury findUnique
   */
  export type TreatmentAndInjuryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentAndInjury to fetch.
     */
    where: TreatmentAndInjuryWhereUniqueInput
  }

  /**
   * TreatmentAndInjury findUniqueOrThrow
   */
  export type TreatmentAndInjuryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentAndInjury to fetch.
     */
    where: TreatmentAndInjuryWhereUniqueInput
  }

  /**
   * TreatmentAndInjury findFirst
   */
  export type TreatmentAndInjuryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentAndInjury to fetch.
     */
    where?: TreatmentAndInjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentAndInjuries to fetch.
     */
    orderBy?: TreatmentAndInjuryOrderByWithRelationInput | TreatmentAndInjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreatmentAndInjuries.
     */
    cursor?: TreatmentAndInjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentAndInjuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentAndInjuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreatmentAndInjuries.
     */
    distinct?: TreatmentAndInjuryScalarFieldEnum | TreatmentAndInjuryScalarFieldEnum[]
  }

  /**
   * TreatmentAndInjury findFirstOrThrow
   */
  export type TreatmentAndInjuryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentAndInjury to fetch.
     */
    where?: TreatmentAndInjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentAndInjuries to fetch.
     */
    orderBy?: TreatmentAndInjuryOrderByWithRelationInput | TreatmentAndInjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreatmentAndInjuries.
     */
    cursor?: TreatmentAndInjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentAndInjuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentAndInjuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreatmentAndInjuries.
     */
    distinct?: TreatmentAndInjuryScalarFieldEnum | TreatmentAndInjuryScalarFieldEnum[]
  }

  /**
   * TreatmentAndInjury findMany
   */
  export type TreatmentAndInjuryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentAndInjuries to fetch.
     */
    where?: TreatmentAndInjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentAndInjuries to fetch.
     */
    orderBy?: TreatmentAndInjuryOrderByWithRelationInput | TreatmentAndInjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TreatmentAndInjuries.
     */
    cursor?: TreatmentAndInjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentAndInjuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentAndInjuries.
     */
    skip?: number
    distinct?: TreatmentAndInjuryScalarFieldEnum | TreatmentAndInjuryScalarFieldEnum[]
  }

  /**
   * TreatmentAndInjury create
   */
  export type TreatmentAndInjuryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * The data needed to create a TreatmentAndInjury.
     */
    data: XOR<TreatmentAndInjuryCreateInput, TreatmentAndInjuryUncheckedCreateInput>
  }

  /**
   * TreatmentAndInjury createMany
   */
  export type TreatmentAndInjuryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TreatmentAndInjuries.
     */
    data: TreatmentAndInjuryCreateManyInput | TreatmentAndInjuryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TreatmentAndInjury createManyAndReturn
   */
  export type TreatmentAndInjuryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TreatmentAndInjuries.
     */
    data: TreatmentAndInjuryCreateManyInput | TreatmentAndInjuryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TreatmentAndInjury update
   */
  export type TreatmentAndInjuryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * The data needed to update a TreatmentAndInjury.
     */
    data: XOR<TreatmentAndInjuryUpdateInput, TreatmentAndInjuryUncheckedUpdateInput>
    /**
     * Choose, which TreatmentAndInjury to update.
     */
    where: TreatmentAndInjuryWhereUniqueInput
  }

  /**
   * TreatmentAndInjury updateMany
   */
  export type TreatmentAndInjuryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TreatmentAndInjuries.
     */
    data: XOR<TreatmentAndInjuryUpdateManyMutationInput, TreatmentAndInjuryUncheckedUpdateManyInput>
    /**
     * Filter which TreatmentAndInjuries to update
     */
    where?: TreatmentAndInjuryWhereInput
  }

  /**
   * TreatmentAndInjury upsert
   */
  export type TreatmentAndInjuryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * The filter to search for the TreatmentAndInjury to update in case it exists.
     */
    where: TreatmentAndInjuryWhereUniqueInput
    /**
     * In case the TreatmentAndInjury found by the `where` argument doesn't exist, create a new TreatmentAndInjury with this data.
     */
    create: XOR<TreatmentAndInjuryCreateInput, TreatmentAndInjuryUncheckedCreateInput>
    /**
     * In case the TreatmentAndInjury was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreatmentAndInjuryUpdateInput, TreatmentAndInjuryUncheckedUpdateInput>
  }

  /**
   * TreatmentAndInjury delete
   */
  export type TreatmentAndInjuryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    /**
     * Filter which TreatmentAndInjury to delete.
     */
    where: TreatmentAndInjuryWhereUniqueInput
  }

  /**
   * TreatmentAndInjury deleteMany
   */
  export type TreatmentAndInjuryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreatmentAndInjuries to delete
     */
    where?: TreatmentAndInjuryWhereInput
  }

  /**
   * TreatmentAndInjury without action
   */
  export type TreatmentAndInjuryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
  }


  /**
   * Model Treatment
   */

  export type AggregateTreatment = {
    _count: TreatmentCountAggregateOutputType | null
    _min: TreatmentMinAggregateOutputType | null
    _max: TreatmentMaxAggregateOutputType | null
  }

  export type TreatmentMinAggregateOutputType = {
    id: string | null
    takenHospital: boolean | null
    isCurrentlyTreated: boolean | null
    hospitalId: string | null
    doctorId: string | null
    admission: Date | null
    discharge: Date | null
    lastVisit: Date | null
    otherInjuries: string | null
  }

  export type TreatmentMaxAggregateOutputType = {
    id: string | null
    takenHospital: boolean | null
    isCurrentlyTreated: boolean | null
    hospitalId: string | null
    doctorId: string | null
    admission: Date | null
    discharge: Date | null
    lastVisit: Date | null
    otherInjuries: string | null
  }

  export type TreatmentCountAggregateOutputType = {
    id: number
    takenHospital: number
    isCurrentlyTreated: number
    hospitalId: number
    doctorId: number
    admission: number
    discharge: number
    lastVisit: number
    otherInjuries: number
    _all: number
  }


  export type TreatmentMinAggregateInputType = {
    id?: true
    takenHospital?: true
    isCurrentlyTreated?: true
    hospitalId?: true
    doctorId?: true
    admission?: true
    discharge?: true
    lastVisit?: true
    otherInjuries?: true
  }

  export type TreatmentMaxAggregateInputType = {
    id?: true
    takenHospital?: true
    isCurrentlyTreated?: true
    hospitalId?: true
    doctorId?: true
    admission?: true
    discharge?: true
    lastVisit?: true
    otherInjuries?: true
  }

  export type TreatmentCountAggregateInputType = {
    id?: true
    takenHospital?: true
    isCurrentlyTreated?: true
    hospitalId?: true
    doctorId?: true
    admission?: true
    discharge?: true
    lastVisit?: true
    otherInjuries?: true
    _all?: true
  }

  export type TreatmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatment to aggregate.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Treatments
    **/
    _count?: true | TreatmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreatmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreatmentMaxAggregateInputType
  }

  export type GetTreatmentAggregateType<T extends TreatmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTreatment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreatment[P]>
      : GetScalarType<T[P], AggregateTreatment[P]>
  }




  export type TreatmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithAggregationInput | TreatmentOrderByWithAggregationInput[]
    by: TreatmentScalarFieldEnum[] | TreatmentScalarFieldEnum
    having?: TreatmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreatmentCountAggregateInputType | true
    _min?: TreatmentMinAggregateInputType
    _max?: TreatmentMaxAggregateInputType
  }

  export type TreatmentGroupByOutputType = {
    id: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    hospitalId: string | null
    doctorId: string | null
    admission: Date | null
    discharge: Date | null
    lastVisit: Date | null
    otherInjuries: string | null
    _count: TreatmentCountAggregateOutputType | null
    _min: TreatmentMinAggregateOutputType | null
    _max: TreatmentMaxAggregateOutputType | null
  }

  type GetTreatmentGroupByPayload<T extends TreatmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreatmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreatmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreatmentGroupByOutputType[P]>
            : GetScalarType<T[P], TreatmentGroupByOutputType[P]>
        }
      >
    >


  export type TreatmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takenHospital?: boolean
    isCurrentlyTreated?: boolean
    hospitalId?: boolean
    doctorId?: boolean
    admission?: boolean
    discharge?: boolean
    lastVisit?: boolean
    otherInjuries?: boolean
    role?: boolean | Treatment$roleArgs<ExtArgs>
    doctor?: boolean | Treatment$doctorArgs<ExtArgs>
    injuries?: boolean | Treatment$injuriesArgs<ExtArgs>
    treatmentsAndInjuries?: boolean | Treatment$treatmentsAndInjuriesArgs<ExtArgs>
    _count?: boolean | TreatmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatment"]>

  export type TreatmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    takenHospital?: boolean
    isCurrentlyTreated?: boolean
    hospitalId?: boolean
    doctorId?: boolean
    admission?: boolean
    discharge?: boolean
    lastVisit?: boolean
    otherInjuries?: boolean
    role?: boolean | Treatment$roleArgs<ExtArgs>
    doctor?: boolean | Treatment$doctorArgs<ExtArgs>
  }, ExtArgs["result"]["treatment"]>

  export type TreatmentSelectScalar = {
    id?: boolean
    takenHospital?: boolean
    isCurrentlyTreated?: boolean
    hospitalId?: boolean
    doctorId?: boolean
    admission?: boolean
    discharge?: boolean
    lastVisit?: boolean
    otherInjuries?: boolean
  }

  export type TreatmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Treatment$roleArgs<ExtArgs>
    doctor?: boolean | Treatment$doctorArgs<ExtArgs>
    injuries?: boolean | Treatment$injuriesArgs<ExtArgs>
    treatmentsAndInjuries?: boolean | Treatment$treatmentsAndInjuriesArgs<ExtArgs>
    _count?: boolean | TreatmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TreatmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Treatment$roleArgs<ExtArgs>
    doctor?: boolean | Treatment$doctorArgs<ExtArgs>
  }

  export type $TreatmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Treatment"
    objects: {
      role: Prisma.$RolePayload<ExtArgs> | null
      doctor: Prisma.$RolePayload<ExtArgs> | null
      injuries: Prisma.$InjuryPayload<ExtArgs>[]
      treatmentsAndInjuries: Prisma.$TreatmentAndInjuryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      takenHospital: boolean
      isCurrentlyTreated: boolean
      hospitalId: string | null
      doctorId: string | null
      admission: Date | null
      discharge: Date | null
      lastVisit: Date | null
      otherInjuries: string | null
    }, ExtArgs["result"]["treatment"]>
    composites: {}
  }

  type TreatmentGetPayload<S extends boolean | null | undefined | TreatmentDefaultArgs> = $Result.GetResult<Prisma.$TreatmentPayload, S>

  type TreatmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TreatmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TreatmentCountAggregateInputType | true
    }

  export interface TreatmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Treatment'], meta: { name: 'Treatment' } }
    /**
     * Find zero or one Treatment that matches the filter.
     * @param {TreatmentFindUniqueArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreatmentFindUniqueArgs>(args: SelectSubset<T, TreatmentFindUniqueArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Treatment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TreatmentFindUniqueOrThrowArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreatmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TreatmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Treatment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindFirstArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreatmentFindFirstArgs>(args?: SelectSubset<T, TreatmentFindFirstArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Treatment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindFirstOrThrowArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreatmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TreatmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Treatments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treatments
     * const treatments = await prisma.treatment.findMany()
     * 
     * // Get first 10 Treatments
     * const treatments = await prisma.treatment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treatmentWithIdOnly = await prisma.treatment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreatmentFindManyArgs>(args?: SelectSubset<T, TreatmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Treatment.
     * @param {TreatmentCreateArgs} args - Arguments to create a Treatment.
     * @example
     * // Create one Treatment
     * const Treatment = await prisma.treatment.create({
     *   data: {
     *     // ... data to create a Treatment
     *   }
     * })
     * 
     */
    create<T extends TreatmentCreateArgs>(args: SelectSubset<T, TreatmentCreateArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Treatments.
     * @param {TreatmentCreateManyArgs} args - Arguments to create many Treatments.
     * @example
     * // Create many Treatments
     * const treatment = await prisma.treatment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreatmentCreateManyArgs>(args?: SelectSubset<T, TreatmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Treatments and returns the data saved in the database.
     * @param {TreatmentCreateManyAndReturnArgs} args - Arguments to create many Treatments.
     * @example
     * // Create many Treatments
     * const treatment = await prisma.treatment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Treatments and only return the `id`
     * const treatmentWithIdOnly = await prisma.treatment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreatmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TreatmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Treatment.
     * @param {TreatmentDeleteArgs} args - Arguments to delete one Treatment.
     * @example
     * // Delete one Treatment
     * const Treatment = await prisma.treatment.delete({
     *   where: {
     *     // ... filter to delete one Treatment
     *   }
     * })
     * 
     */
    delete<T extends TreatmentDeleteArgs>(args: SelectSubset<T, TreatmentDeleteArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Treatment.
     * @param {TreatmentUpdateArgs} args - Arguments to update one Treatment.
     * @example
     * // Update one Treatment
     * const treatment = await prisma.treatment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreatmentUpdateArgs>(args: SelectSubset<T, TreatmentUpdateArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Treatments.
     * @param {TreatmentDeleteManyArgs} args - Arguments to filter Treatments to delete.
     * @example
     * // Delete a few Treatments
     * const { count } = await prisma.treatment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreatmentDeleteManyArgs>(args?: SelectSubset<T, TreatmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treatments
     * const treatment = await prisma.treatment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreatmentUpdateManyArgs>(args: SelectSubset<T, TreatmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Treatment.
     * @param {TreatmentUpsertArgs} args - Arguments to update or create a Treatment.
     * @example
     * // Update or create a Treatment
     * const treatment = await prisma.treatment.upsert({
     *   create: {
     *     // ... data to create a Treatment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treatment we want to update
     *   }
     * })
     */
    upsert<T extends TreatmentUpsertArgs>(args: SelectSubset<T, TreatmentUpsertArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentCountArgs} args - Arguments to filter Treatments to count.
     * @example
     * // Count the number of Treatments
     * const count = await prisma.treatment.count({
     *   where: {
     *     // ... the filter for the Treatments we want to count
     *   }
     * })
    **/
    count<T extends TreatmentCountArgs>(
      args?: Subset<T, TreatmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreatmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreatmentAggregateArgs>(args: Subset<T, TreatmentAggregateArgs>): Prisma.PrismaPromise<GetTreatmentAggregateType<T>>

    /**
     * Group by Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreatmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreatmentGroupByArgs['orderBy'] }
        : { orderBy?: TreatmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreatmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreatmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Treatment model
   */
  readonly fields: TreatmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Treatment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreatmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends Treatment$roleArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    doctor<T extends Treatment$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$doctorArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    injuries<T extends Treatment$injuriesArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$injuriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "findMany"> | Null>
    treatmentsAndInjuries<T extends Treatment$treatmentsAndInjuriesArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$treatmentsAndInjuriesArgs<ExtArgs>>): Prisma__TreatmentAndInjuryClient<$Result.GetResult<Prisma.$TreatmentAndInjuryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Treatment model
   */ 
  interface TreatmentFieldRefs {
    readonly id: FieldRef<"Treatment", 'String'>
    readonly takenHospital: FieldRef<"Treatment", 'Boolean'>
    readonly isCurrentlyTreated: FieldRef<"Treatment", 'Boolean'>
    readonly hospitalId: FieldRef<"Treatment", 'String'>
    readonly doctorId: FieldRef<"Treatment", 'String'>
    readonly admission: FieldRef<"Treatment", 'DateTime'>
    readonly discharge: FieldRef<"Treatment", 'DateTime'>
    readonly lastVisit: FieldRef<"Treatment", 'DateTime'>
    readonly otherInjuries: FieldRef<"Treatment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Treatment findUnique
   */
  export type TreatmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment findUniqueOrThrow
   */
  export type TreatmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment findFirst
   */
  export type TreatmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment findFirstOrThrow
   */
  export type TreatmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment findMany
   */
  export type TreatmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment create
   */
  export type TreatmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Treatment.
     */
    data: XOR<TreatmentCreateInput, TreatmentUncheckedCreateInput>
  }

  /**
   * Treatment createMany
   */
  export type TreatmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Treatments.
     */
    data: TreatmentCreateManyInput | TreatmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Treatment createManyAndReturn
   */
  export type TreatmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Treatments.
     */
    data: TreatmentCreateManyInput | TreatmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Treatment update
   */
  export type TreatmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Treatment.
     */
    data: XOR<TreatmentUpdateInput, TreatmentUncheckedUpdateInput>
    /**
     * Choose, which Treatment to update.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment updateMany
   */
  export type TreatmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Treatments.
     */
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyInput>
    /**
     * Filter which Treatments to update
     */
    where?: TreatmentWhereInput
  }

  /**
   * Treatment upsert
   */
  export type TreatmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Treatment to update in case it exists.
     */
    where: TreatmentWhereUniqueInput
    /**
     * In case the Treatment found by the `where` argument doesn't exist, create a new Treatment with this data.
     */
    create: XOR<TreatmentCreateInput, TreatmentUncheckedCreateInput>
    /**
     * In case the Treatment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreatmentUpdateInput, TreatmentUncheckedUpdateInput>
  }

  /**
   * Treatment delete
   */
  export type TreatmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter which Treatment to delete.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment deleteMany
   */
  export type TreatmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatments to delete
     */
    where?: TreatmentWhereInput
  }

  /**
   * Treatment.role
   */
  export type Treatment$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Treatment.doctor
   */
  export type Treatment$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Treatment.injuries
   */
  export type Treatment$injuriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    where?: InjuryWhereInput
    orderBy?: InjuryOrderByWithRelationInput | InjuryOrderByWithRelationInput[]
    cursor?: InjuryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InjuryScalarFieldEnum | InjuryScalarFieldEnum[]
  }

  /**
   * Treatment.treatmentsAndInjuries
   */
  export type Treatment$treatmentsAndInjuriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentAndInjury
     */
    select?: TreatmentAndInjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentAndInjuryInclude<ExtArgs> | null
    where?: TreatmentAndInjuryWhereInput
  }

  /**
   * Treatment without action
   */
  export type TreatmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
  }


  /**
   * Model Injury
   */

  export type AggregateInjury = {
    _count: InjuryCountAggregateOutputType | null
    _min: InjuryMinAggregateOutputType | null
    _max: InjuryMaxAggregateOutputType | null
  }

  export type InjuryMinAggregateOutputType = {
    id: string | null
    injuryLocation: $Enums.InjuryPoint | null
    injury: $Enums.InjuryType | null
    injuryLocationSide: $Enums.InjurySide | null
    other: string | null
    treatmentId: string | null
  }

  export type InjuryMaxAggregateOutputType = {
    id: string | null
    injuryLocation: $Enums.InjuryPoint | null
    injury: $Enums.InjuryType | null
    injuryLocationSide: $Enums.InjurySide | null
    other: string | null
    treatmentId: string | null
  }

  export type InjuryCountAggregateOutputType = {
    id: number
    injuryLocation: number
    injury: number
    injuryLocationSide: number
    other: number
    treatmentId: number
    _all: number
  }


  export type InjuryMinAggregateInputType = {
    id?: true
    injuryLocation?: true
    injury?: true
    injuryLocationSide?: true
    other?: true
    treatmentId?: true
  }

  export type InjuryMaxAggregateInputType = {
    id?: true
    injuryLocation?: true
    injury?: true
    injuryLocationSide?: true
    other?: true
    treatmentId?: true
  }

  export type InjuryCountAggregateInputType = {
    id?: true
    injuryLocation?: true
    injury?: true
    injuryLocationSide?: true
    other?: true
    treatmentId?: true
    _all?: true
  }

  export type InjuryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Injury to aggregate.
     */
    where?: InjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injuries to fetch.
     */
    orderBy?: InjuryOrderByWithRelationInput | InjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Injuries
    **/
    _count?: true | InjuryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InjuryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InjuryMaxAggregateInputType
  }

  export type GetInjuryAggregateType<T extends InjuryAggregateArgs> = {
        [P in keyof T & keyof AggregateInjury]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInjury[P]>
      : GetScalarType<T[P], AggregateInjury[P]>
  }




  export type InjuryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InjuryWhereInput
    orderBy?: InjuryOrderByWithAggregationInput | InjuryOrderByWithAggregationInput[]
    by: InjuryScalarFieldEnum[] | InjuryScalarFieldEnum
    having?: InjuryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InjuryCountAggregateInputType | true
    _min?: InjuryMinAggregateInputType
    _max?: InjuryMaxAggregateInputType
  }

  export type InjuryGroupByOutputType = {
    id: string
    injuryLocation: $Enums.InjuryPoint
    injury: $Enums.InjuryType
    injuryLocationSide: $Enums.InjurySide
    other: string | null
    treatmentId: string
    _count: InjuryCountAggregateOutputType | null
    _min: InjuryMinAggregateOutputType | null
    _max: InjuryMaxAggregateOutputType | null
  }

  type GetInjuryGroupByPayload<T extends InjuryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InjuryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InjuryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InjuryGroupByOutputType[P]>
            : GetScalarType<T[P], InjuryGroupByOutputType[P]>
        }
      >
    >


  export type InjurySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    injuryLocation?: boolean
    injury?: boolean
    injuryLocationSide?: boolean
    other?: boolean
    treatmentId?: boolean
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["injury"]>

  export type InjurySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    injuryLocation?: boolean
    injury?: boolean
    injuryLocationSide?: boolean
    other?: boolean
    treatmentId?: boolean
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["injury"]>

  export type InjurySelectScalar = {
    id?: boolean
    injuryLocation?: boolean
    injury?: boolean
    injuryLocationSide?: boolean
    other?: boolean
    treatmentId?: boolean
  }

  export type InjuryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }
  export type InjuryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treatment?: boolean | TreatmentDefaultArgs<ExtArgs>
  }

  export type $InjuryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Injury"
    objects: {
      treatment: Prisma.$TreatmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      injuryLocation: $Enums.InjuryPoint
      injury: $Enums.InjuryType
      injuryLocationSide: $Enums.InjurySide
      other: string | null
      treatmentId: string
    }, ExtArgs["result"]["injury"]>
    composites: {}
  }

  type InjuryGetPayload<S extends boolean | null | undefined | InjuryDefaultArgs> = $Result.GetResult<Prisma.$InjuryPayload, S>

  type InjuryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InjuryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InjuryCountAggregateInputType | true
    }

  export interface InjuryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Injury'], meta: { name: 'Injury' } }
    /**
     * Find zero or one Injury that matches the filter.
     * @param {InjuryFindUniqueArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InjuryFindUniqueArgs>(args: SelectSubset<T, InjuryFindUniqueArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Injury that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InjuryFindUniqueOrThrowArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InjuryFindUniqueOrThrowArgs>(args: SelectSubset<T, InjuryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Injury that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryFindFirstArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InjuryFindFirstArgs>(args?: SelectSubset<T, InjuryFindFirstArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Injury that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryFindFirstOrThrowArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InjuryFindFirstOrThrowArgs>(args?: SelectSubset<T, InjuryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Injuries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Injuries
     * const injuries = await prisma.injury.findMany()
     * 
     * // Get first 10 Injuries
     * const injuries = await prisma.injury.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const injuryWithIdOnly = await prisma.injury.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InjuryFindManyArgs>(args?: SelectSubset<T, InjuryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Injury.
     * @param {InjuryCreateArgs} args - Arguments to create a Injury.
     * @example
     * // Create one Injury
     * const Injury = await prisma.injury.create({
     *   data: {
     *     // ... data to create a Injury
     *   }
     * })
     * 
     */
    create<T extends InjuryCreateArgs>(args: SelectSubset<T, InjuryCreateArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Injuries.
     * @param {InjuryCreateManyArgs} args - Arguments to create many Injuries.
     * @example
     * // Create many Injuries
     * const injury = await prisma.injury.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InjuryCreateManyArgs>(args?: SelectSubset<T, InjuryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Injuries and returns the data saved in the database.
     * @param {InjuryCreateManyAndReturnArgs} args - Arguments to create many Injuries.
     * @example
     * // Create many Injuries
     * const injury = await prisma.injury.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Injuries and only return the `id`
     * const injuryWithIdOnly = await prisma.injury.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InjuryCreateManyAndReturnArgs>(args?: SelectSubset<T, InjuryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Injury.
     * @param {InjuryDeleteArgs} args - Arguments to delete one Injury.
     * @example
     * // Delete one Injury
     * const Injury = await prisma.injury.delete({
     *   where: {
     *     // ... filter to delete one Injury
     *   }
     * })
     * 
     */
    delete<T extends InjuryDeleteArgs>(args: SelectSubset<T, InjuryDeleteArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Injury.
     * @param {InjuryUpdateArgs} args - Arguments to update one Injury.
     * @example
     * // Update one Injury
     * const injury = await prisma.injury.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InjuryUpdateArgs>(args: SelectSubset<T, InjuryUpdateArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Injuries.
     * @param {InjuryDeleteManyArgs} args - Arguments to filter Injuries to delete.
     * @example
     * // Delete a few Injuries
     * const { count } = await prisma.injury.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InjuryDeleteManyArgs>(args?: SelectSubset<T, InjuryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Injuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Injuries
     * const injury = await prisma.injury.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InjuryUpdateManyArgs>(args: SelectSubset<T, InjuryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Injury.
     * @param {InjuryUpsertArgs} args - Arguments to update or create a Injury.
     * @example
     * // Update or create a Injury
     * const injury = await prisma.injury.upsert({
     *   create: {
     *     // ... data to create a Injury
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Injury we want to update
     *   }
     * })
     */
    upsert<T extends InjuryUpsertArgs>(args: SelectSubset<T, InjuryUpsertArgs<ExtArgs>>): Prisma__InjuryClient<$Result.GetResult<Prisma.$InjuryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Injuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryCountArgs} args - Arguments to filter Injuries to count.
     * @example
     * // Count the number of Injuries
     * const count = await prisma.injury.count({
     *   where: {
     *     // ... the filter for the Injuries we want to count
     *   }
     * })
    **/
    count<T extends InjuryCountArgs>(
      args?: Subset<T, InjuryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InjuryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Injury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InjuryAggregateArgs>(args: Subset<T, InjuryAggregateArgs>): Prisma.PrismaPromise<GetInjuryAggregateType<T>>

    /**
     * Group by Injury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InjuryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InjuryGroupByArgs['orderBy'] }
        : { orderBy?: InjuryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InjuryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInjuryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Injury model
   */
  readonly fields: InjuryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Injury.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InjuryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    treatment<T extends TreatmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TreatmentDefaultArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Injury model
   */ 
  interface InjuryFieldRefs {
    readonly id: FieldRef<"Injury", 'String'>
    readonly injuryLocation: FieldRef<"Injury", 'InjuryPoint'>
    readonly injury: FieldRef<"Injury", 'InjuryType'>
    readonly injuryLocationSide: FieldRef<"Injury", 'InjurySide'>
    readonly other: FieldRef<"Injury", 'String'>
    readonly treatmentId: FieldRef<"Injury", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Injury findUnique
   */
  export type InjuryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * Filter, which Injury to fetch.
     */
    where: InjuryWhereUniqueInput
  }

  /**
   * Injury findUniqueOrThrow
   */
  export type InjuryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * Filter, which Injury to fetch.
     */
    where: InjuryWhereUniqueInput
  }

  /**
   * Injury findFirst
   */
  export type InjuryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * Filter, which Injury to fetch.
     */
    where?: InjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injuries to fetch.
     */
    orderBy?: InjuryOrderByWithRelationInput | InjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Injuries.
     */
    cursor?: InjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Injuries.
     */
    distinct?: InjuryScalarFieldEnum | InjuryScalarFieldEnum[]
  }

  /**
   * Injury findFirstOrThrow
   */
  export type InjuryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * Filter, which Injury to fetch.
     */
    where?: InjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injuries to fetch.
     */
    orderBy?: InjuryOrderByWithRelationInput | InjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Injuries.
     */
    cursor?: InjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Injuries.
     */
    distinct?: InjuryScalarFieldEnum | InjuryScalarFieldEnum[]
  }

  /**
   * Injury findMany
   */
  export type InjuryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * Filter, which Injuries to fetch.
     */
    where?: InjuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injuries to fetch.
     */
    orderBy?: InjuryOrderByWithRelationInput | InjuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Injuries.
     */
    cursor?: InjuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injuries.
     */
    skip?: number
    distinct?: InjuryScalarFieldEnum | InjuryScalarFieldEnum[]
  }

  /**
   * Injury create
   */
  export type InjuryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * The data needed to create a Injury.
     */
    data: XOR<InjuryCreateInput, InjuryUncheckedCreateInput>
  }

  /**
   * Injury createMany
   */
  export type InjuryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Injuries.
     */
    data: InjuryCreateManyInput | InjuryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Injury createManyAndReturn
   */
  export type InjuryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Injuries.
     */
    data: InjuryCreateManyInput | InjuryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Injury update
   */
  export type InjuryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * The data needed to update a Injury.
     */
    data: XOR<InjuryUpdateInput, InjuryUncheckedUpdateInput>
    /**
     * Choose, which Injury to update.
     */
    where: InjuryWhereUniqueInput
  }

  /**
   * Injury updateMany
   */
  export type InjuryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Injuries.
     */
    data: XOR<InjuryUpdateManyMutationInput, InjuryUncheckedUpdateManyInput>
    /**
     * Filter which Injuries to update
     */
    where?: InjuryWhereInput
  }

  /**
   * Injury upsert
   */
  export type InjuryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * The filter to search for the Injury to update in case it exists.
     */
    where: InjuryWhereUniqueInput
    /**
     * In case the Injury found by the `where` argument doesn't exist, create a new Injury with this data.
     */
    create: XOR<InjuryCreateInput, InjuryUncheckedCreateInput>
    /**
     * In case the Injury was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InjuryUpdateInput, InjuryUncheckedUpdateInput>
  }

  /**
   * Injury delete
   */
  export type InjuryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
    /**
     * Filter which Injury to delete.
     */
    where: InjuryWhereUniqueInput
  }

  /**
   * Injury deleteMany
   */
  export type InjuryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Injuries to delete
     */
    where?: InjuryWhereInput
  }

  /**
   * Injury without action
   */
  export type InjuryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injury
     */
    select?: InjurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjuryInclude<ExtArgs> | null
  }


  /**
   * Model AccidentMedia
   */

  export type AggregateAccidentMedia = {
    _count: AccidentMediaCountAggregateOutputType | null
    _min: AccidentMediaMinAggregateOutputType | null
    _max: AccidentMediaMaxAggregateOutputType | null
  }

  export type AccidentMediaMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    thumbnail: string | null
    claimId: string | null
  }

  export type AccidentMediaMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    thumbnail: string | null
    claimId: string | null
  }

  export type AccidentMediaCountAggregateOutputType = {
    id: number
    url: number
    type: number
    thumbnail: number
    claimId: number
    _all: number
  }


  export type AccidentMediaMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    thumbnail?: true
    claimId?: true
  }

  export type AccidentMediaMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    thumbnail?: true
    claimId?: true
  }

  export type AccidentMediaCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    thumbnail?: true
    claimId?: true
    _all?: true
  }

  export type AccidentMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccidentMedia to aggregate.
     */
    where?: AccidentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentMedias to fetch.
     */
    orderBy?: AccidentMediaOrderByWithRelationInput | AccidentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccidentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccidentMedias
    **/
    _count?: true | AccidentMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccidentMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccidentMediaMaxAggregateInputType
  }

  export type GetAccidentMediaAggregateType<T extends AccidentMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateAccidentMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccidentMedia[P]>
      : GetScalarType<T[P], AggregateAccidentMedia[P]>
  }




  export type AccidentMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccidentMediaWhereInput
    orderBy?: AccidentMediaOrderByWithAggregationInput | AccidentMediaOrderByWithAggregationInput[]
    by: AccidentMediaScalarFieldEnum[] | AccidentMediaScalarFieldEnum
    having?: AccidentMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccidentMediaCountAggregateInputType | true
    _min?: AccidentMediaMinAggregateInputType
    _max?: AccidentMediaMaxAggregateInputType
  }

  export type AccidentMediaGroupByOutputType = {
    id: string
    url: string
    type: string
    thumbnail: string | null
    claimId: string
    _count: AccidentMediaCountAggregateOutputType | null
    _min: AccidentMediaMinAggregateOutputType | null
    _max: AccidentMediaMaxAggregateOutputType | null
  }

  type GetAccidentMediaGroupByPayload<T extends AccidentMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccidentMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccidentMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccidentMediaGroupByOutputType[P]>
            : GetScalarType<T[P], AccidentMediaGroupByOutputType[P]>
        }
      >
    >


  export type AccidentMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    thumbnail?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accidentMedia"]>

  export type AccidentMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    thumbnail?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accidentMedia"]>

  export type AccidentMediaSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    thumbnail?: boolean
    claimId?: boolean
  }

  export type AccidentMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type AccidentMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $AccidentMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccidentMedia"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: string
      thumbnail: string | null
      claimId: string
    }, ExtArgs["result"]["accidentMedia"]>
    composites: {}
  }

  type AccidentMediaGetPayload<S extends boolean | null | undefined | AccidentMediaDefaultArgs> = $Result.GetResult<Prisma.$AccidentMediaPayload, S>

  type AccidentMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccidentMediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccidentMediaCountAggregateInputType | true
    }

  export interface AccidentMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccidentMedia'], meta: { name: 'AccidentMedia' } }
    /**
     * Find zero or one AccidentMedia that matches the filter.
     * @param {AccidentMediaFindUniqueArgs} args - Arguments to find a AccidentMedia
     * @example
     * // Get one AccidentMedia
     * const accidentMedia = await prisma.accidentMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccidentMediaFindUniqueArgs>(args: SelectSubset<T, AccidentMediaFindUniqueArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccidentMedia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccidentMediaFindUniqueOrThrowArgs} args - Arguments to find a AccidentMedia
     * @example
     * // Get one AccidentMedia
     * const accidentMedia = await prisma.accidentMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccidentMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, AccidentMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccidentMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentMediaFindFirstArgs} args - Arguments to find a AccidentMedia
     * @example
     * // Get one AccidentMedia
     * const accidentMedia = await prisma.accidentMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccidentMediaFindFirstArgs>(args?: SelectSubset<T, AccidentMediaFindFirstArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccidentMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentMediaFindFirstOrThrowArgs} args - Arguments to find a AccidentMedia
     * @example
     * // Get one AccidentMedia
     * const accidentMedia = await prisma.accidentMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccidentMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, AccidentMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccidentMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccidentMedias
     * const accidentMedias = await prisma.accidentMedia.findMany()
     * 
     * // Get first 10 AccidentMedias
     * const accidentMedias = await prisma.accidentMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accidentMediaWithIdOnly = await prisma.accidentMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccidentMediaFindManyArgs>(args?: SelectSubset<T, AccidentMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccidentMedia.
     * @param {AccidentMediaCreateArgs} args - Arguments to create a AccidentMedia.
     * @example
     * // Create one AccidentMedia
     * const AccidentMedia = await prisma.accidentMedia.create({
     *   data: {
     *     // ... data to create a AccidentMedia
     *   }
     * })
     * 
     */
    create<T extends AccidentMediaCreateArgs>(args: SelectSubset<T, AccidentMediaCreateArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccidentMedias.
     * @param {AccidentMediaCreateManyArgs} args - Arguments to create many AccidentMedias.
     * @example
     * // Create many AccidentMedias
     * const accidentMedia = await prisma.accidentMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccidentMediaCreateManyArgs>(args?: SelectSubset<T, AccidentMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccidentMedias and returns the data saved in the database.
     * @param {AccidentMediaCreateManyAndReturnArgs} args - Arguments to create many AccidentMedias.
     * @example
     * // Create many AccidentMedias
     * const accidentMedia = await prisma.accidentMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccidentMedias and only return the `id`
     * const accidentMediaWithIdOnly = await prisma.accidentMedia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccidentMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, AccidentMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccidentMedia.
     * @param {AccidentMediaDeleteArgs} args - Arguments to delete one AccidentMedia.
     * @example
     * // Delete one AccidentMedia
     * const AccidentMedia = await prisma.accidentMedia.delete({
     *   where: {
     *     // ... filter to delete one AccidentMedia
     *   }
     * })
     * 
     */
    delete<T extends AccidentMediaDeleteArgs>(args: SelectSubset<T, AccidentMediaDeleteArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccidentMedia.
     * @param {AccidentMediaUpdateArgs} args - Arguments to update one AccidentMedia.
     * @example
     * // Update one AccidentMedia
     * const accidentMedia = await prisma.accidentMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccidentMediaUpdateArgs>(args: SelectSubset<T, AccidentMediaUpdateArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccidentMedias.
     * @param {AccidentMediaDeleteManyArgs} args - Arguments to filter AccidentMedias to delete.
     * @example
     * // Delete a few AccidentMedias
     * const { count } = await prisma.accidentMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccidentMediaDeleteManyArgs>(args?: SelectSubset<T, AccidentMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccidentMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccidentMedias
     * const accidentMedia = await prisma.accidentMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccidentMediaUpdateManyArgs>(args: SelectSubset<T, AccidentMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccidentMedia.
     * @param {AccidentMediaUpsertArgs} args - Arguments to update or create a AccidentMedia.
     * @example
     * // Update or create a AccidentMedia
     * const accidentMedia = await prisma.accidentMedia.upsert({
     *   create: {
     *     // ... data to create a AccidentMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccidentMedia we want to update
     *   }
     * })
     */
    upsert<T extends AccidentMediaUpsertArgs>(args: SelectSubset<T, AccidentMediaUpsertArgs<ExtArgs>>): Prisma__AccidentMediaClient<$Result.GetResult<Prisma.$AccidentMediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccidentMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentMediaCountArgs} args - Arguments to filter AccidentMedias to count.
     * @example
     * // Count the number of AccidentMedias
     * const count = await prisma.accidentMedia.count({
     *   where: {
     *     // ... the filter for the AccidentMedias we want to count
     *   }
     * })
    **/
    count<T extends AccidentMediaCountArgs>(
      args?: Subset<T, AccidentMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccidentMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccidentMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccidentMediaAggregateArgs>(args: Subset<T, AccidentMediaAggregateArgs>): Prisma.PrismaPromise<GetAccidentMediaAggregateType<T>>

    /**
     * Group by AccidentMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccidentMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccidentMediaGroupByArgs['orderBy'] }
        : { orderBy?: AccidentMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccidentMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccidentMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccidentMedia model
   */
  readonly fields: AccidentMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccidentMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccidentMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccidentMedia model
   */ 
  interface AccidentMediaFieldRefs {
    readonly id: FieldRef<"AccidentMedia", 'String'>
    readonly url: FieldRef<"AccidentMedia", 'String'>
    readonly type: FieldRef<"AccidentMedia", 'String'>
    readonly thumbnail: FieldRef<"AccidentMedia", 'String'>
    readonly claimId: FieldRef<"AccidentMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccidentMedia findUnique
   */
  export type AccidentMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AccidentMedia to fetch.
     */
    where: AccidentMediaWhereUniqueInput
  }

  /**
   * AccidentMedia findUniqueOrThrow
   */
  export type AccidentMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AccidentMedia to fetch.
     */
    where: AccidentMediaWhereUniqueInput
  }

  /**
   * AccidentMedia findFirst
   */
  export type AccidentMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AccidentMedia to fetch.
     */
    where?: AccidentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentMedias to fetch.
     */
    orderBy?: AccidentMediaOrderByWithRelationInput | AccidentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccidentMedias.
     */
    cursor?: AccidentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccidentMedias.
     */
    distinct?: AccidentMediaScalarFieldEnum | AccidentMediaScalarFieldEnum[]
  }

  /**
   * AccidentMedia findFirstOrThrow
   */
  export type AccidentMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AccidentMedia to fetch.
     */
    where?: AccidentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentMedias to fetch.
     */
    orderBy?: AccidentMediaOrderByWithRelationInput | AccidentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccidentMedias.
     */
    cursor?: AccidentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccidentMedias.
     */
    distinct?: AccidentMediaScalarFieldEnum | AccidentMediaScalarFieldEnum[]
  }

  /**
   * AccidentMedia findMany
   */
  export type AccidentMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AccidentMedias to fetch.
     */
    where?: AccidentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentMedias to fetch.
     */
    orderBy?: AccidentMediaOrderByWithRelationInput | AccidentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccidentMedias.
     */
    cursor?: AccidentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentMedias.
     */
    skip?: number
    distinct?: AccidentMediaScalarFieldEnum | AccidentMediaScalarFieldEnum[]
  }

  /**
   * AccidentMedia create
   */
  export type AccidentMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a AccidentMedia.
     */
    data: XOR<AccidentMediaCreateInput, AccidentMediaUncheckedCreateInput>
  }

  /**
   * AccidentMedia createMany
   */
  export type AccidentMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccidentMedias.
     */
    data: AccidentMediaCreateManyInput | AccidentMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccidentMedia createManyAndReturn
   */
  export type AccidentMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccidentMedias.
     */
    data: AccidentMediaCreateManyInput | AccidentMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccidentMedia update
   */
  export type AccidentMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a AccidentMedia.
     */
    data: XOR<AccidentMediaUpdateInput, AccidentMediaUncheckedUpdateInput>
    /**
     * Choose, which AccidentMedia to update.
     */
    where: AccidentMediaWhereUniqueInput
  }

  /**
   * AccidentMedia updateMany
   */
  export type AccidentMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccidentMedias.
     */
    data: XOR<AccidentMediaUpdateManyMutationInput, AccidentMediaUncheckedUpdateManyInput>
    /**
     * Filter which AccidentMedias to update
     */
    where?: AccidentMediaWhereInput
  }

  /**
   * AccidentMedia upsert
   */
  export type AccidentMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the AccidentMedia to update in case it exists.
     */
    where: AccidentMediaWhereUniqueInput
    /**
     * In case the AccidentMedia found by the `where` argument doesn't exist, create a new AccidentMedia with this data.
     */
    create: XOR<AccidentMediaCreateInput, AccidentMediaUncheckedCreateInput>
    /**
     * In case the AccidentMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccidentMediaUpdateInput, AccidentMediaUncheckedUpdateInput>
  }

  /**
   * AccidentMedia delete
   */
  export type AccidentMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
    /**
     * Filter which AccidentMedia to delete.
     */
    where: AccidentMediaWhereUniqueInput
  }

  /**
   * AccidentMedia deleteMany
   */
  export type AccidentMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccidentMedias to delete
     */
    where?: AccidentMediaWhereInput
  }

  /**
   * AccidentMedia without action
   */
  export type AccidentMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentMedia
     */
    select?: AccidentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentMediaInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentAvgAggregateOutputType = {
    vehicleCount: number | null
  }

  export type IncidentSumAggregateOutputType = {
    vehicleCount: number | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    vehicleRole: string | null
    vehicleCount: number | null
    busOrVehicle: $Enums.BusOrVehicle | null
    transportType: $Enums.TransportType | null
    rideShareCompany: string | null
    rideShareOtherName: string | null
    propertyType: $Enums.PropertyType | null
    datetime: Date | null
    location: string | null
    workRelated: boolean | null
    description: string | null
    policeReportCompleted: boolean | null
    policeStationId: string | null
    policeOfficerId: string | null
    reportCompleted: boolean | null
    reportNumber: string | null
    supportingDocument: boolean | null
    lostEarning: string | null
    amountLoss: string | null
    timeLoss: string | null
    witness: boolean | null
    priorRepresentation: boolean | null
    priorRepresentationReason: string | null
    lawfirmId: string | null
    attorneyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    vehicleRole: string | null
    vehicleCount: number | null
    busOrVehicle: $Enums.BusOrVehicle | null
    transportType: $Enums.TransportType | null
    rideShareCompany: string | null
    rideShareOtherName: string | null
    propertyType: $Enums.PropertyType | null
    datetime: Date | null
    location: string | null
    workRelated: boolean | null
    description: string | null
    policeReportCompleted: boolean | null
    policeStationId: string | null
    policeOfficerId: string | null
    reportCompleted: boolean | null
    reportNumber: string | null
    supportingDocument: boolean | null
    lostEarning: string | null
    amountLoss: string | null
    timeLoss: string | null
    witness: boolean | null
    priorRepresentation: boolean | null
    priorRepresentationReason: string | null
    lawfirmId: string | null
    attorneyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    vehicleRole: number
    vehicleCount: number
    busOrVehicle: number
    transportType: number
    rideShareCompany: number
    rideShareOtherName: number
    propertyType: number
    datetime: number
    location: number
    workRelated: number
    description: number
    policeReportCompleted: number
    policeStationId: number
    policeOfficerId: number
    reportCompleted: number
    reportNumber: number
    supportingDocument: number
    lostEarning: number
    amountLoss: number
    timeLoss: number
    witness: number
    priorRepresentation: number
    priorRepresentationReason: number
    lawfirmId: number
    attorneyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentAvgAggregateInputType = {
    vehicleCount?: true
  }

  export type IncidentSumAggregateInputType = {
    vehicleCount?: true
  }

  export type IncidentMinAggregateInputType = {
    id?: true
    vehicleRole?: true
    vehicleCount?: true
    busOrVehicle?: true
    transportType?: true
    rideShareCompany?: true
    rideShareOtherName?: true
    propertyType?: true
    datetime?: true
    location?: true
    workRelated?: true
    description?: true
    policeReportCompleted?: true
    policeStationId?: true
    policeOfficerId?: true
    reportCompleted?: true
    reportNumber?: true
    supportingDocument?: true
    lostEarning?: true
    amountLoss?: true
    timeLoss?: true
    witness?: true
    priorRepresentation?: true
    priorRepresentationReason?: true
    lawfirmId?: true
    attorneyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    vehicleRole?: true
    vehicleCount?: true
    busOrVehicle?: true
    transportType?: true
    rideShareCompany?: true
    rideShareOtherName?: true
    propertyType?: true
    datetime?: true
    location?: true
    workRelated?: true
    description?: true
    policeReportCompleted?: true
    policeStationId?: true
    policeOfficerId?: true
    reportCompleted?: true
    reportNumber?: true
    supportingDocument?: true
    lostEarning?: true
    amountLoss?: true
    timeLoss?: true
    witness?: true
    priorRepresentation?: true
    priorRepresentationReason?: true
    lawfirmId?: true
    attorneyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    vehicleRole?: true
    vehicleCount?: true
    busOrVehicle?: true
    transportType?: true
    rideShareCompany?: true
    rideShareOtherName?: true
    propertyType?: true
    datetime?: true
    location?: true
    workRelated?: true
    description?: true
    policeReportCompleted?: true
    policeStationId?: true
    policeOfficerId?: true
    reportCompleted?: true
    reportNumber?: true
    supportingDocument?: true
    lostEarning?: true
    amountLoss?: true
    timeLoss?: true
    witness?: true
    priorRepresentation?: true
    priorRepresentationReason?: true
    lawfirmId?: true
    attorneyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncidentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncidentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _avg?: IncidentAvgAggregateInputType
    _sum?: IncidentSumAggregateInputType
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    vehicleRole: string | null
    vehicleCount: number | null
    busOrVehicle: $Enums.BusOrVehicle | null
    transportType: $Enums.TransportType | null
    rideShareCompany: string | null
    rideShareOtherName: string | null
    propertyType: $Enums.PropertyType | null
    datetime: Date
    location: string | null
    workRelated: boolean
    description: string | null
    policeReportCompleted: boolean
    policeStationId: string | null
    policeOfficerId: string | null
    reportCompleted: boolean
    reportNumber: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss: string | null
    timeLoss: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason: string | null
    lawfirmId: string | null
    attorneyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleRole?: boolean
    vehicleCount?: boolean
    busOrVehicle?: boolean
    transportType?: boolean
    rideShareCompany?: boolean
    rideShareOtherName?: boolean
    propertyType?: boolean
    datetime?: boolean
    location?: boolean
    workRelated?: boolean
    description?: boolean
    policeReportCompleted?: boolean
    policeStationId?: boolean
    policeOfficerId?: boolean
    reportCompleted?: boolean
    reportNumber?: boolean
    supportingDocument?: boolean
    lostEarning?: boolean
    amountLoss?: boolean
    timeLoss?: boolean
    witness?: boolean
    priorRepresentation?: boolean
    priorRepresentationReason?: boolean
    lawfirmId?: boolean
    attorneyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    policeStation?: boolean | Incident$policeStationArgs<ExtArgs>
    policeOfficer?: boolean | Incident$policeOfficerArgs<ExtArgs>
    lawfirm?: boolean | Incident$lawfirmArgs<ExtArgs>
    attorney?: boolean | Incident$attorneyArgs<ExtArgs>
    Claim?: boolean | Incident$ClaimArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleRole?: boolean
    vehicleCount?: boolean
    busOrVehicle?: boolean
    transportType?: boolean
    rideShareCompany?: boolean
    rideShareOtherName?: boolean
    propertyType?: boolean
    datetime?: boolean
    location?: boolean
    workRelated?: boolean
    description?: boolean
    policeReportCompleted?: boolean
    policeStationId?: boolean
    policeOfficerId?: boolean
    reportCompleted?: boolean
    reportNumber?: boolean
    supportingDocument?: boolean
    lostEarning?: boolean
    amountLoss?: boolean
    timeLoss?: boolean
    witness?: boolean
    priorRepresentation?: boolean
    priorRepresentationReason?: boolean
    lawfirmId?: boolean
    attorneyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    policeStation?: boolean | Incident$policeStationArgs<ExtArgs>
    policeOfficer?: boolean | Incident$policeOfficerArgs<ExtArgs>
    lawfirm?: boolean | Incident$lawfirmArgs<ExtArgs>
    attorney?: boolean | Incident$attorneyArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    vehicleRole?: boolean
    vehicleCount?: boolean
    busOrVehicle?: boolean
    transportType?: boolean
    rideShareCompany?: boolean
    rideShareOtherName?: boolean
    propertyType?: boolean
    datetime?: boolean
    location?: boolean
    workRelated?: boolean
    description?: boolean
    policeReportCompleted?: boolean
    policeStationId?: boolean
    policeOfficerId?: boolean
    reportCompleted?: boolean
    reportNumber?: boolean
    supportingDocument?: boolean
    lostEarning?: boolean
    amountLoss?: boolean
    timeLoss?: boolean
    witness?: boolean
    priorRepresentation?: boolean
    priorRepresentationReason?: boolean
    lawfirmId?: boolean
    attorneyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policeStation?: boolean | Incident$policeStationArgs<ExtArgs>
    policeOfficer?: boolean | Incident$policeOfficerArgs<ExtArgs>
    lawfirm?: boolean | Incident$lawfirmArgs<ExtArgs>
    attorney?: boolean | Incident$attorneyArgs<ExtArgs>
    Claim?: boolean | Incident$ClaimArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policeStation?: boolean | Incident$policeStationArgs<ExtArgs>
    policeOfficer?: boolean | Incident$policeOfficerArgs<ExtArgs>
    lawfirm?: boolean | Incident$lawfirmArgs<ExtArgs>
    attorney?: boolean | Incident$attorneyArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      policeStation: Prisma.$RolePayload<ExtArgs> | null
      policeOfficer: Prisma.$SubAccountPayload<ExtArgs> | null
      lawfirm: Prisma.$RolePayload<ExtArgs> | null
      attorney: Prisma.$SubAccountPayload<ExtArgs> | null
      Claim: Prisma.$ClaimPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicleRole: string | null
      vehicleCount: number | null
      busOrVehicle: $Enums.BusOrVehicle | null
      transportType: $Enums.TransportType | null
      rideShareCompany: string | null
      rideShareOtherName: string | null
      propertyType: $Enums.PropertyType | null
      datetime: Date
      location: string | null
      workRelated: boolean
      description: string | null
      policeReportCompleted: boolean
      policeStationId: string | null
      policeOfficerId: string | null
      reportCompleted: boolean
      reportNumber: string | null
      supportingDocument: boolean
      lostEarning: string
      amountLoss: string | null
      timeLoss: string | null
      witness: boolean
      priorRepresentation: boolean
      priorRepresentationReason: string | null
      lawfirmId: string | null
      attorneyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    policeStation<T extends Incident$policeStationArgs<ExtArgs> = {}>(args?: Subset<T, Incident$policeStationArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    policeOfficer<T extends Incident$policeOfficerArgs<ExtArgs> = {}>(args?: Subset<T, Incident$policeOfficerArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lawfirm<T extends Incident$lawfirmArgs<ExtArgs> = {}>(args?: Subset<T, Incident$lawfirmArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    attorney<T extends Incident$attorneyArgs<ExtArgs> = {}>(args?: Subset<T, Incident$attorneyArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Claim<T extends Incident$ClaimArgs<ExtArgs> = {}>(args?: Subset<T, Incident$ClaimArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */ 
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly vehicleRole: FieldRef<"Incident", 'String'>
    readonly vehicleCount: FieldRef<"Incident", 'Int'>
    readonly busOrVehicle: FieldRef<"Incident", 'BusOrVehicle'>
    readonly transportType: FieldRef<"Incident", 'TransportType'>
    readonly rideShareCompany: FieldRef<"Incident", 'String'>
    readonly rideShareOtherName: FieldRef<"Incident", 'String'>
    readonly propertyType: FieldRef<"Incident", 'PropertyType'>
    readonly datetime: FieldRef<"Incident", 'DateTime'>
    readonly location: FieldRef<"Incident", 'String'>
    readonly workRelated: FieldRef<"Incident", 'Boolean'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly policeReportCompleted: FieldRef<"Incident", 'Boolean'>
    readonly policeStationId: FieldRef<"Incident", 'String'>
    readonly policeOfficerId: FieldRef<"Incident", 'String'>
    readonly reportCompleted: FieldRef<"Incident", 'Boolean'>
    readonly reportNumber: FieldRef<"Incident", 'String'>
    readonly supportingDocument: FieldRef<"Incident", 'Boolean'>
    readonly lostEarning: FieldRef<"Incident", 'String'>
    readonly amountLoss: FieldRef<"Incident", 'String'>
    readonly timeLoss: FieldRef<"Incident", 'String'>
    readonly witness: FieldRef<"Incident", 'Boolean'>
    readonly priorRepresentation: FieldRef<"Incident", 'Boolean'>
    readonly priorRepresentationReason: FieldRef<"Incident", 'String'>
    readonly lawfirmId: FieldRef<"Incident", 'String'>
    readonly attorneyId: FieldRef<"Incident", 'String'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident.policeStation
   */
  export type Incident$policeStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Incident.policeOfficer
   */
  export type Incident$policeOfficerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
  }

  /**
   * Incident.lawfirm
   */
  export type Incident$lawfirmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Incident.attorney
   */
  export type Incident$attorneyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
  }

  /**
   * Incident.Claim
   */
  export type Incident$ClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model Witness
   */

  export type AggregateWitness = {
    _count: WitnessCountAggregateOutputType | null
    _min: WitnessMinAggregateOutputType | null
    _max: WitnessMaxAggregateOutputType | null
  }

  export type WitnessMinAggregateOutputType = {
    id: string | null
    claimId: string | null
  }

  export type WitnessMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
  }

  export type WitnessCountAggregateOutputType = {
    id: number
    claimId: number
    _all: number
  }


  export type WitnessMinAggregateInputType = {
    id?: true
    claimId?: true
  }

  export type WitnessMaxAggregateInputType = {
    id?: true
    claimId?: true
  }

  export type WitnessCountAggregateInputType = {
    id?: true
    claimId?: true
    _all?: true
  }

  export type WitnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Witness to aggregate.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Witnesses
    **/
    _count?: true | WitnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WitnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WitnessMaxAggregateInputType
  }

  export type GetWitnessAggregateType<T extends WitnessAggregateArgs> = {
        [P in keyof T & keyof AggregateWitness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWitness[P]>
      : GetScalarType<T[P], AggregateWitness[P]>
  }




  export type WitnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WitnessWhereInput
    orderBy?: WitnessOrderByWithAggregationInput | WitnessOrderByWithAggregationInput[]
    by: WitnessScalarFieldEnum[] | WitnessScalarFieldEnum
    having?: WitnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WitnessCountAggregateInputType | true
    _min?: WitnessMinAggregateInputType
    _max?: WitnessMaxAggregateInputType
  }

  export type WitnessGroupByOutputType = {
    id: string
    claimId: string
    _count: WitnessCountAggregateOutputType | null
    _min: WitnessMinAggregateOutputType | null
    _max: WitnessMaxAggregateOutputType | null
  }

  type GetWitnessGroupByPayload<T extends WitnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WitnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WitnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WitnessGroupByOutputType[P]>
            : GetScalarType<T[P], WitnessGroupByOutputType[P]>
        }
      >
    >


  export type WitnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    witnessDetails?: boolean | Witness$witnessDetailsArgs<ExtArgs>
    _count?: boolean | WitnessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["witness"]>

  export type WitnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["witness"]>

  export type WitnessSelectScalar = {
    id?: boolean
    claimId?: boolean
  }

  export type WitnessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    witnessDetails?: boolean | Witness$witnessDetailsArgs<ExtArgs>
    _count?: boolean | WitnessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WitnessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $WitnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Witness"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
      witnessDetails: Prisma.$WitnessDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
    }, ExtArgs["result"]["witness"]>
    composites: {}
  }

  type WitnessGetPayload<S extends boolean | null | undefined | WitnessDefaultArgs> = $Result.GetResult<Prisma.$WitnessPayload, S>

  type WitnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WitnessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WitnessCountAggregateInputType | true
    }

  export interface WitnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Witness'], meta: { name: 'Witness' } }
    /**
     * Find zero or one Witness that matches the filter.
     * @param {WitnessFindUniqueArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WitnessFindUniqueArgs>(args: SelectSubset<T, WitnessFindUniqueArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Witness that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WitnessFindUniqueOrThrowArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WitnessFindUniqueOrThrowArgs>(args: SelectSubset<T, WitnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Witness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessFindFirstArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WitnessFindFirstArgs>(args?: SelectSubset<T, WitnessFindFirstArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Witness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessFindFirstOrThrowArgs} args - Arguments to find a Witness
     * @example
     * // Get one Witness
     * const witness = await prisma.witness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WitnessFindFirstOrThrowArgs>(args?: SelectSubset<T, WitnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Witnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Witnesses
     * const witnesses = await prisma.witness.findMany()
     * 
     * // Get first 10 Witnesses
     * const witnesses = await prisma.witness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const witnessWithIdOnly = await prisma.witness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WitnessFindManyArgs>(args?: SelectSubset<T, WitnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Witness.
     * @param {WitnessCreateArgs} args - Arguments to create a Witness.
     * @example
     * // Create one Witness
     * const Witness = await prisma.witness.create({
     *   data: {
     *     // ... data to create a Witness
     *   }
     * })
     * 
     */
    create<T extends WitnessCreateArgs>(args: SelectSubset<T, WitnessCreateArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Witnesses.
     * @param {WitnessCreateManyArgs} args - Arguments to create many Witnesses.
     * @example
     * // Create many Witnesses
     * const witness = await prisma.witness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WitnessCreateManyArgs>(args?: SelectSubset<T, WitnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Witnesses and returns the data saved in the database.
     * @param {WitnessCreateManyAndReturnArgs} args - Arguments to create many Witnesses.
     * @example
     * // Create many Witnesses
     * const witness = await prisma.witness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Witnesses and only return the `id`
     * const witnessWithIdOnly = await prisma.witness.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WitnessCreateManyAndReturnArgs>(args?: SelectSubset<T, WitnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Witness.
     * @param {WitnessDeleteArgs} args - Arguments to delete one Witness.
     * @example
     * // Delete one Witness
     * const Witness = await prisma.witness.delete({
     *   where: {
     *     // ... filter to delete one Witness
     *   }
     * })
     * 
     */
    delete<T extends WitnessDeleteArgs>(args: SelectSubset<T, WitnessDeleteArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Witness.
     * @param {WitnessUpdateArgs} args - Arguments to update one Witness.
     * @example
     * // Update one Witness
     * const witness = await prisma.witness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WitnessUpdateArgs>(args: SelectSubset<T, WitnessUpdateArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Witnesses.
     * @param {WitnessDeleteManyArgs} args - Arguments to filter Witnesses to delete.
     * @example
     * // Delete a few Witnesses
     * const { count } = await prisma.witness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WitnessDeleteManyArgs>(args?: SelectSubset<T, WitnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Witnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Witnesses
     * const witness = await prisma.witness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WitnessUpdateManyArgs>(args: SelectSubset<T, WitnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Witness.
     * @param {WitnessUpsertArgs} args - Arguments to update or create a Witness.
     * @example
     * // Update or create a Witness
     * const witness = await prisma.witness.upsert({
     *   create: {
     *     // ... data to create a Witness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Witness we want to update
     *   }
     * })
     */
    upsert<T extends WitnessUpsertArgs>(args: SelectSubset<T, WitnessUpsertArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Witnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessCountArgs} args - Arguments to filter Witnesses to count.
     * @example
     * // Count the number of Witnesses
     * const count = await prisma.witness.count({
     *   where: {
     *     // ... the filter for the Witnesses we want to count
     *   }
     * })
    **/
    count<T extends WitnessCountArgs>(
      args?: Subset<T, WitnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WitnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Witness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WitnessAggregateArgs>(args: Subset<T, WitnessAggregateArgs>): Prisma.PrismaPromise<GetWitnessAggregateType<T>>

    /**
     * Group by Witness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WitnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WitnessGroupByArgs['orderBy'] }
        : { orderBy?: WitnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WitnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWitnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Witness model
   */
  readonly fields: WitnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Witness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WitnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    witnessDetails<T extends Witness$witnessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Witness$witnessDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Witness model
   */ 
  interface WitnessFieldRefs {
    readonly id: FieldRef<"Witness", 'String'>
    readonly claimId: FieldRef<"Witness", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Witness findUnique
   */
  export type WitnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness findUniqueOrThrow
   */
  export type WitnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness findFirst
   */
  export type WitnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Witnesses.
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Witnesses.
     */
    distinct?: WitnessScalarFieldEnum | WitnessScalarFieldEnum[]
  }

  /**
   * Witness findFirstOrThrow
   */
  export type WitnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witness to fetch.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Witnesses.
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Witnesses.
     */
    distinct?: WitnessScalarFieldEnum | WitnessScalarFieldEnum[]
  }

  /**
   * Witness findMany
   */
  export type WitnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter, which Witnesses to fetch.
     */
    where?: WitnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Witnesses to fetch.
     */
    orderBy?: WitnessOrderByWithRelationInput | WitnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Witnesses.
     */
    cursor?: WitnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Witnesses.
     */
    skip?: number
    distinct?: WitnessScalarFieldEnum | WitnessScalarFieldEnum[]
  }

  /**
   * Witness create
   */
  export type WitnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * The data needed to create a Witness.
     */
    data: XOR<WitnessCreateInput, WitnessUncheckedCreateInput>
  }

  /**
   * Witness createMany
   */
  export type WitnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Witnesses.
     */
    data: WitnessCreateManyInput | WitnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Witness createManyAndReturn
   */
  export type WitnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Witnesses.
     */
    data: WitnessCreateManyInput | WitnessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Witness update
   */
  export type WitnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * The data needed to update a Witness.
     */
    data: XOR<WitnessUpdateInput, WitnessUncheckedUpdateInput>
    /**
     * Choose, which Witness to update.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness updateMany
   */
  export type WitnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Witnesses.
     */
    data: XOR<WitnessUpdateManyMutationInput, WitnessUncheckedUpdateManyInput>
    /**
     * Filter which Witnesses to update
     */
    where?: WitnessWhereInput
  }

  /**
   * Witness upsert
   */
  export type WitnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * The filter to search for the Witness to update in case it exists.
     */
    where: WitnessWhereUniqueInput
    /**
     * In case the Witness found by the `where` argument doesn't exist, create a new Witness with this data.
     */
    create: XOR<WitnessCreateInput, WitnessUncheckedCreateInput>
    /**
     * In case the Witness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WitnessUpdateInput, WitnessUncheckedUpdateInput>
  }

  /**
   * Witness delete
   */
  export type WitnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
    /**
     * Filter which Witness to delete.
     */
    where: WitnessWhereUniqueInput
  }

  /**
   * Witness deleteMany
   */
  export type WitnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Witnesses to delete
     */
    where?: WitnessWhereInput
  }

  /**
   * Witness.witnessDetails
   */
  export type Witness$witnessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    where?: WitnessDetailsWhereInput
    orderBy?: WitnessDetailsOrderByWithRelationInput | WitnessDetailsOrderByWithRelationInput[]
    cursor?: WitnessDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WitnessDetailsScalarFieldEnum | WitnessDetailsScalarFieldEnum[]
  }

  /**
   * Witness without action
   */
  export type WitnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Witness
     */
    select?: WitnessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessInclude<ExtArgs> | null
  }


  /**
   * Model WitnessDetails
   */

  export type AggregateWitnessDetails = {
    _count: WitnessDetailsCountAggregateOutputType | null
    _min: WitnessDetailsMinAggregateOutputType | null
    _max: WitnessDetailsMaxAggregateOutputType | null
  }

  export type WitnessDetailsMinAggregateOutputType = {
    id: string | null
    witnessId: string | null
    roleId: string | null
  }

  export type WitnessDetailsMaxAggregateOutputType = {
    id: string | null
    witnessId: string | null
    roleId: string | null
  }

  export type WitnessDetailsCountAggregateOutputType = {
    id: number
    witnessId: number
    roleId: number
    _all: number
  }


  export type WitnessDetailsMinAggregateInputType = {
    id?: true
    witnessId?: true
    roleId?: true
  }

  export type WitnessDetailsMaxAggregateInputType = {
    id?: true
    witnessId?: true
    roleId?: true
  }

  export type WitnessDetailsCountAggregateInputType = {
    id?: true
    witnessId?: true
    roleId?: true
    _all?: true
  }

  export type WitnessDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WitnessDetails to aggregate.
     */
    where?: WitnessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessDetails to fetch.
     */
    orderBy?: WitnessDetailsOrderByWithRelationInput | WitnessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WitnessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WitnessDetails
    **/
    _count?: true | WitnessDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WitnessDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WitnessDetailsMaxAggregateInputType
  }

  export type GetWitnessDetailsAggregateType<T extends WitnessDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateWitnessDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWitnessDetails[P]>
      : GetScalarType<T[P], AggregateWitnessDetails[P]>
  }




  export type WitnessDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WitnessDetailsWhereInput
    orderBy?: WitnessDetailsOrderByWithAggregationInput | WitnessDetailsOrderByWithAggregationInput[]
    by: WitnessDetailsScalarFieldEnum[] | WitnessDetailsScalarFieldEnum
    having?: WitnessDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WitnessDetailsCountAggregateInputType | true
    _min?: WitnessDetailsMinAggregateInputType
    _max?: WitnessDetailsMaxAggregateInputType
  }

  export type WitnessDetailsGroupByOutputType = {
    id: string
    witnessId: string
    roleId: string
    _count: WitnessDetailsCountAggregateOutputType | null
    _min: WitnessDetailsMinAggregateOutputType | null
    _max: WitnessDetailsMaxAggregateOutputType | null
  }

  type GetWitnessDetailsGroupByPayload<T extends WitnessDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WitnessDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WitnessDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WitnessDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], WitnessDetailsGroupByOutputType[P]>
        }
      >
    >


  export type WitnessDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    witnessId?: boolean
    roleId?: boolean
    witness?: boolean | WitnessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["witnessDetails"]>

  export type WitnessDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    witnessId?: boolean
    roleId?: boolean
    witness?: boolean | WitnessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["witnessDetails"]>

  export type WitnessDetailsSelectScalar = {
    id?: boolean
    witnessId?: boolean
    roleId?: boolean
  }

  export type WitnessDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    witness?: boolean | WitnessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type WitnessDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    witness?: boolean | WitnessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $WitnessDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WitnessDetails"
    objects: {
      witness: Prisma.$WitnessPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      witnessId: string
      roleId: string
    }, ExtArgs["result"]["witnessDetails"]>
    composites: {}
  }

  type WitnessDetailsGetPayload<S extends boolean | null | undefined | WitnessDetailsDefaultArgs> = $Result.GetResult<Prisma.$WitnessDetailsPayload, S>

  type WitnessDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WitnessDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WitnessDetailsCountAggregateInputType | true
    }

  export interface WitnessDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WitnessDetails'], meta: { name: 'WitnessDetails' } }
    /**
     * Find zero or one WitnessDetails that matches the filter.
     * @param {WitnessDetailsFindUniqueArgs} args - Arguments to find a WitnessDetails
     * @example
     * // Get one WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WitnessDetailsFindUniqueArgs>(args: SelectSubset<T, WitnessDetailsFindUniqueArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WitnessDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WitnessDetailsFindUniqueOrThrowArgs} args - Arguments to find a WitnessDetails
     * @example
     * // Get one WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WitnessDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, WitnessDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WitnessDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessDetailsFindFirstArgs} args - Arguments to find a WitnessDetails
     * @example
     * // Get one WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WitnessDetailsFindFirstArgs>(args?: SelectSubset<T, WitnessDetailsFindFirstArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WitnessDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessDetailsFindFirstOrThrowArgs} args - Arguments to find a WitnessDetails
     * @example
     * // Get one WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WitnessDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, WitnessDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WitnessDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.findMany()
     * 
     * // Get first 10 WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const witnessDetailsWithIdOnly = await prisma.witnessDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WitnessDetailsFindManyArgs>(args?: SelectSubset<T, WitnessDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WitnessDetails.
     * @param {WitnessDetailsCreateArgs} args - Arguments to create a WitnessDetails.
     * @example
     * // Create one WitnessDetails
     * const WitnessDetails = await prisma.witnessDetails.create({
     *   data: {
     *     // ... data to create a WitnessDetails
     *   }
     * })
     * 
     */
    create<T extends WitnessDetailsCreateArgs>(args: SelectSubset<T, WitnessDetailsCreateArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WitnessDetails.
     * @param {WitnessDetailsCreateManyArgs} args - Arguments to create many WitnessDetails.
     * @example
     * // Create many WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WitnessDetailsCreateManyArgs>(args?: SelectSubset<T, WitnessDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WitnessDetails and returns the data saved in the database.
     * @param {WitnessDetailsCreateManyAndReturnArgs} args - Arguments to create many WitnessDetails.
     * @example
     * // Create many WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WitnessDetails and only return the `id`
     * const witnessDetailsWithIdOnly = await prisma.witnessDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WitnessDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, WitnessDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WitnessDetails.
     * @param {WitnessDetailsDeleteArgs} args - Arguments to delete one WitnessDetails.
     * @example
     * // Delete one WitnessDetails
     * const WitnessDetails = await prisma.witnessDetails.delete({
     *   where: {
     *     // ... filter to delete one WitnessDetails
     *   }
     * })
     * 
     */
    delete<T extends WitnessDetailsDeleteArgs>(args: SelectSubset<T, WitnessDetailsDeleteArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WitnessDetails.
     * @param {WitnessDetailsUpdateArgs} args - Arguments to update one WitnessDetails.
     * @example
     * // Update one WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WitnessDetailsUpdateArgs>(args: SelectSubset<T, WitnessDetailsUpdateArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WitnessDetails.
     * @param {WitnessDetailsDeleteManyArgs} args - Arguments to filter WitnessDetails to delete.
     * @example
     * // Delete a few WitnessDetails
     * const { count } = await prisma.witnessDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WitnessDetailsDeleteManyArgs>(args?: SelectSubset<T, WitnessDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WitnessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WitnessDetailsUpdateManyArgs>(args: SelectSubset<T, WitnessDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WitnessDetails.
     * @param {WitnessDetailsUpsertArgs} args - Arguments to update or create a WitnessDetails.
     * @example
     * // Update or create a WitnessDetails
     * const witnessDetails = await prisma.witnessDetails.upsert({
     *   create: {
     *     // ... data to create a WitnessDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WitnessDetails we want to update
     *   }
     * })
     */
    upsert<T extends WitnessDetailsUpsertArgs>(args: SelectSubset<T, WitnessDetailsUpsertArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WitnessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessDetailsCountArgs} args - Arguments to filter WitnessDetails to count.
     * @example
     * // Count the number of WitnessDetails
     * const count = await prisma.witnessDetails.count({
     *   where: {
     *     // ... the filter for the WitnessDetails we want to count
     *   }
     * })
    **/
    count<T extends WitnessDetailsCountArgs>(
      args?: Subset<T, WitnessDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WitnessDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WitnessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WitnessDetailsAggregateArgs>(args: Subset<T, WitnessDetailsAggregateArgs>): Prisma.PrismaPromise<GetWitnessDetailsAggregateType<T>>

    /**
     * Group by WitnessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WitnessDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WitnessDetailsGroupByArgs['orderBy'] }
        : { orderBy?: WitnessDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WitnessDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWitnessDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WitnessDetails model
   */
  readonly fields: WitnessDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WitnessDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WitnessDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    witness<T extends WitnessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WitnessDefaultArgs<ExtArgs>>): Prisma__WitnessClient<$Result.GetResult<Prisma.$WitnessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WitnessDetails model
   */ 
  interface WitnessDetailsFieldRefs {
    readonly id: FieldRef<"WitnessDetails", 'String'>
    readonly witnessId: FieldRef<"WitnessDetails", 'String'>
    readonly roleId: FieldRef<"WitnessDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WitnessDetails findUnique
   */
  export type WitnessDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which WitnessDetails to fetch.
     */
    where: WitnessDetailsWhereUniqueInput
  }

  /**
   * WitnessDetails findUniqueOrThrow
   */
  export type WitnessDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which WitnessDetails to fetch.
     */
    where: WitnessDetailsWhereUniqueInput
  }

  /**
   * WitnessDetails findFirst
   */
  export type WitnessDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which WitnessDetails to fetch.
     */
    where?: WitnessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessDetails to fetch.
     */
    orderBy?: WitnessDetailsOrderByWithRelationInput | WitnessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WitnessDetails.
     */
    cursor?: WitnessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WitnessDetails.
     */
    distinct?: WitnessDetailsScalarFieldEnum | WitnessDetailsScalarFieldEnum[]
  }

  /**
   * WitnessDetails findFirstOrThrow
   */
  export type WitnessDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which WitnessDetails to fetch.
     */
    where?: WitnessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessDetails to fetch.
     */
    orderBy?: WitnessDetailsOrderByWithRelationInput | WitnessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WitnessDetails.
     */
    cursor?: WitnessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WitnessDetails.
     */
    distinct?: WitnessDetailsScalarFieldEnum | WitnessDetailsScalarFieldEnum[]
  }

  /**
   * WitnessDetails findMany
   */
  export type WitnessDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which WitnessDetails to fetch.
     */
    where?: WitnessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessDetails to fetch.
     */
    orderBy?: WitnessDetailsOrderByWithRelationInput | WitnessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WitnessDetails.
     */
    cursor?: WitnessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessDetails.
     */
    skip?: number
    distinct?: WitnessDetailsScalarFieldEnum | WitnessDetailsScalarFieldEnum[]
  }

  /**
   * WitnessDetails create
   */
  export type WitnessDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a WitnessDetails.
     */
    data: XOR<WitnessDetailsCreateInput, WitnessDetailsUncheckedCreateInput>
  }

  /**
   * WitnessDetails createMany
   */
  export type WitnessDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WitnessDetails.
     */
    data: WitnessDetailsCreateManyInput | WitnessDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WitnessDetails createManyAndReturn
   */
  export type WitnessDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WitnessDetails.
     */
    data: WitnessDetailsCreateManyInput | WitnessDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WitnessDetails update
   */
  export type WitnessDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a WitnessDetails.
     */
    data: XOR<WitnessDetailsUpdateInput, WitnessDetailsUncheckedUpdateInput>
    /**
     * Choose, which WitnessDetails to update.
     */
    where: WitnessDetailsWhereUniqueInput
  }

  /**
   * WitnessDetails updateMany
   */
  export type WitnessDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WitnessDetails.
     */
    data: XOR<WitnessDetailsUpdateManyMutationInput, WitnessDetailsUncheckedUpdateManyInput>
    /**
     * Filter which WitnessDetails to update
     */
    where?: WitnessDetailsWhereInput
  }

  /**
   * WitnessDetails upsert
   */
  export type WitnessDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the WitnessDetails to update in case it exists.
     */
    where: WitnessDetailsWhereUniqueInput
    /**
     * In case the WitnessDetails found by the `where` argument doesn't exist, create a new WitnessDetails with this data.
     */
    create: XOR<WitnessDetailsCreateInput, WitnessDetailsUncheckedCreateInput>
    /**
     * In case the WitnessDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WitnessDetailsUpdateInput, WitnessDetailsUncheckedUpdateInput>
  }

  /**
   * WitnessDetails delete
   */
  export type WitnessDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    /**
     * Filter which WitnessDetails to delete.
     */
    where: WitnessDetailsWhereUniqueInput
  }

  /**
   * WitnessDetails deleteMany
   */
  export type WitnessDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WitnessDetails to delete
     */
    where?: WitnessDetailsWhereInput
  }

  /**
   * WitnessDetails without action
   */
  export type WitnessDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    roletypeId: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    roletypeId: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    accountId: number
    roletypeId: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    accountId?: true
    roletypeId?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    accountId?: true
    roletypeId?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    accountId?: true
    roletypeId?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    accountId: string | null
    roletypeId: string
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    roletypeId?: boolean
    account?: boolean | Role$accountArgs<ExtArgs>
    roletype?: boolean | RoleTypeDefaultArgs<ExtArgs>
    clientClaims?: boolean | Role$clientClaimsArgs<ExtArgs>
    injuredPartyClaims?: boolean | Role$injuredPartyClaimsArgs<ExtArgs>
    healthInsuranceClaims?: boolean | Role$healthInsuranceClaimsArgs<ExtArgs>
    witnessDetails?: boolean | Role$witnessDetailsArgs<ExtArgs>
    defendantAccount?: boolean | Role$defendantAccountArgs<ExtArgs>
    defendantInsuranceCarrier?: boolean | Role$defendantInsuranceCarrierArgs<ExtArgs>
    hospitalTreatments?: boolean | Role$hospitalTreatmentsArgs<ExtArgs>
    doctorTreatments?: boolean | Role$doctorTreatmentsArgs<ExtArgs>
    lawfirmIncidents?: boolean | Role$lawfirmIncidentsArgs<ExtArgs>
    policeStationIncidents?: boolean | Role$policeStationIncidentsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    roletypeId?: boolean
    account?: boolean | Role$accountArgs<ExtArgs>
    roletype?: boolean | RoleTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    accountId?: boolean
    roletypeId?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Role$accountArgs<ExtArgs>
    roletype?: boolean | RoleTypeDefaultArgs<ExtArgs>
    clientClaims?: boolean | Role$clientClaimsArgs<ExtArgs>
    injuredPartyClaims?: boolean | Role$injuredPartyClaimsArgs<ExtArgs>
    healthInsuranceClaims?: boolean | Role$healthInsuranceClaimsArgs<ExtArgs>
    witnessDetails?: boolean | Role$witnessDetailsArgs<ExtArgs>
    defendantAccount?: boolean | Role$defendantAccountArgs<ExtArgs>
    defendantInsuranceCarrier?: boolean | Role$defendantInsuranceCarrierArgs<ExtArgs>
    hospitalTreatments?: boolean | Role$hospitalTreatmentsArgs<ExtArgs>
    doctorTreatments?: boolean | Role$doctorTreatmentsArgs<ExtArgs>
    lawfirmIncidents?: boolean | Role$lawfirmIncidentsArgs<ExtArgs>
    policeStationIncidents?: boolean | Role$policeStationIncidentsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Role$accountArgs<ExtArgs>
    roletype?: boolean | RoleTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      roletype: Prisma.$RoleTypePayload<ExtArgs>
      clientClaims: Prisma.$ClaimPayload<ExtArgs>[]
      injuredPartyClaims: Prisma.$ClaimPayload<ExtArgs>[]
      healthInsuranceClaims: Prisma.$ClaimPayload<ExtArgs>[]
      witnessDetails: Prisma.$WitnessDetailsPayload<ExtArgs> | null
      defendantAccount: Prisma.$DefendantDetailsPayload<ExtArgs>[]
      defendantInsuranceCarrier: Prisma.$DefendantDetailsPayload<ExtArgs>[]
      hospitalTreatments: Prisma.$TreatmentPayload<ExtArgs>[]
      doctorTreatments: Prisma.$TreatmentPayload<ExtArgs>[]
      lawfirmIncidents: Prisma.$IncidentPayload<ExtArgs>[]
      policeStationIncidents: Prisma.$IncidentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string | null
      roletypeId: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends Role$accountArgs<ExtArgs> = {}>(args?: Subset<T, Role$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roletype<T extends RoleTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleTypeDefaultArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clientClaims<T extends Role$clientClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Role$clientClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    injuredPartyClaims<T extends Role$injuredPartyClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Role$injuredPartyClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    healthInsuranceClaims<T extends Role$healthInsuranceClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Role$healthInsuranceClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    witnessDetails<T extends Role$witnessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Role$witnessDetailsArgs<ExtArgs>>): Prisma__WitnessDetailsClient<$Result.GetResult<Prisma.$WitnessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    defendantAccount<T extends Role$defendantAccountArgs<ExtArgs> = {}>(args?: Subset<T, Role$defendantAccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    defendantInsuranceCarrier<T extends Role$defendantInsuranceCarrierArgs<ExtArgs> = {}>(args?: Subset<T, Role$defendantInsuranceCarrierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefendantDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    hospitalTreatments<T extends Role$hospitalTreatmentsArgs<ExtArgs> = {}>(args?: Subset<T, Role$hospitalTreatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany"> | Null>
    doctorTreatments<T extends Role$doctorTreatmentsArgs<ExtArgs> = {}>(args?: Subset<T, Role$doctorTreatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany"> | Null>
    lawfirmIncidents<T extends Role$lawfirmIncidentsArgs<ExtArgs> = {}>(args?: Subset<T, Role$lawfirmIncidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    policeStationIncidents<T extends Role$policeStationIncidentsArgs<ExtArgs> = {}>(args?: Subset<T, Role$policeStationIncidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly accountId: FieldRef<"Role", 'String'>
    readonly roletypeId: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.account
   */
  export type Role$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Role.clientClaims
   */
  export type Role$clientClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Role.injuredPartyClaims
   */
  export type Role$injuredPartyClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Role.healthInsuranceClaims
   */
  export type Role$healthInsuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Role.witnessDetails
   */
  export type Role$witnessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessDetails
     */
    select?: WitnessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WitnessDetailsInclude<ExtArgs> | null
    where?: WitnessDetailsWhereInput
  }

  /**
   * Role.defendantAccount
   */
  export type Role$defendantAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    where?: DefendantDetailsWhereInput
    orderBy?: DefendantDetailsOrderByWithRelationInput | DefendantDetailsOrderByWithRelationInput[]
    cursor?: DefendantDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefendantDetailsScalarFieldEnum | DefendantDetailsScalarFieldEnum[]
  }

  /**
   * Role.defendantInsuranceCarrier
   */
  export type Role$defendantInsuranceCarrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefendantDetails
     */
    select?: DefendantDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefendantDetailsInclude<ExtArgs> | null
    where?: DefendantDetailsWhereInput
    orderBy?: DefendantDetailsOrderByWithRelationInput | DefendantDetailsOrderByWithRelationInput[]
    cursor?: DefendantDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefendantDetailsScalarFieldEnum | DefendantDetailsScalarFieldEnum[]
  }

  /**
   * Role.hospitalTreatments
   */
  export type Role$hospitalTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Role.doctorTreatments
   */
  export type Role$doctorTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Role.lawfirmIncidents
   */
  export type Role$lawfirmIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Role.policeStationIncidents
   */
  export type Role$policeStationIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model RoleType
   */

  export type AggregateRoleType = {
    _count: RoleTypeCountAggregateOutputType | null
    _min: RoleTypeMinAggregateOutputType | null
    _max: RoleTypeMaxAggregateOutputType | null
  }

  export type RoleTypeMinAggregateOutputType = {
    id: string | null
    roleType: string | null
    createdAt: Date | null
    createdBy: string | null
    enable: boolean | null
  }

  export type RoleTypeMaxAggregateOutputType = {
    id: string | null
    roleType: string | null
    createdAt: Date | null
    createdBy: string | null
    enable: boolean | null
  }

  export type RoleTypeCountAggregateOutputType = {
    id: number
    roleType: number
    createdAt: number
    createdBy: number
    enable: number
    _all: number
  }


  export type RoleTypeMinAggregateInputType = {
    id?: true
    roleType?: true
    createdAt?: true
    createdBy?: true
    enable?: true
  }

  export type RoleTypeMaxAggregateInputType = {
    id?: true
    roleType?: true
    createdAt?: true
    createdBy?: true
    enable?: true
  }

  export type RoleTypeCountAggregateInputType = {
    id?: true
    roleType?: true
    createdAt?: true
    createdBy?: true
    enable?: true
    _all?: true
  }

  export type RoleTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleType to aggregate.
     */
    where?: RoleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTypes to fetch.
     */
    orderBy?: RoleTypeOrderByWithRelationInput | RoleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTypes
    **/
    _count?: true | RoleTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTypeMaxAggregateInputType
  }

  export type GetRoleTypeAggregateType<T extends RoleTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleType[P]>
      : GetScalarType<T[P], AggregateRoleType[P]>
  }




  export type RoleTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTypeWhereInput
    orderBy?: RoleTypeOrderByWithAggregationInput | RoleTypeOrderByWithAggregationInput[]
    by: RoleTypeScalarFieldEnum[] | RoleTypeScalarFieldEnum
    having?: RoleTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTypeCountAggregateInputType | true
    _min?: RoleTypeMinAggregateInputType
    _max?: RoleTypeMaxAggregateInputType
  }

  export type RoleTypeGroupByOutputType = {
    id: string
    roleType: string
    createdAt: Date
    createdBy: string | null
    enable: boolean | null
    _count: RoleTypeCountAggregateOutputType | null
    _min: RoleTypeMinAggregateOutputType | null
    _max: RoleTypeMaxAggregateOutputType | null
  }

  type GetRoleTypeGroupByPayload<T extends RoleTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTypeGroupByOutputType[P]>
        }
      >
    >


  export type RoleTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleType?: boolean
    createdAt?: boolean
    createdBy?: boolean
    enable?: boolean
    Role?: boolean | RoleType$RoleArgs<ExtArgs>
    _count?: boolean | RoleTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleType"]>

  export type RoleTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleType?: boolean
    createdAt?: boolean
    createdBy?: boolean
    enable?: boolean
  }, ExtArgs["result"]["roleType"]>

  export type RoleTypeSelectScalar = {
    id?: boolean
    roleType?: boolean
    createdAt?: boolean
    createdBy?: boolean
    enable?: boolean
  }

  export type RoleTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleType$RoleArgs<ExtArgs>
    _count?: boolean | RoleTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoleTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleType"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleType: string
      createdAt: Date
      createdBy: string | null
      enable: boolean | null
    }, ExtArgs["result"]["roleType"]>
    composites: {}
  }

  type RoleTypeGetPayload<S extends boolean | null | undefined | RoleTypeDefaultArgs> = $Result.GetResult<Prisma.$RoleTypePayload, S>

  type RoleTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleTypeCountAggregateInputType | true
    }

  export interface RoleTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleType'], meta: { name: 'RoleType' } }
    /**
     * Find zero or one RoleType that matches the filter.
     * @param {RoleTypeFindUniqueArgs} args - Arguments to find a RoleType
     * @example
     * // Get one RoleType
     * const roleType = await prisma.roleType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTypeFindUniqueArgs>(args: SelectSubset<T, RoleTypeFindUniqueArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleTypeFindUniqueOrThrowArgs} args - Arguments to find a RoleType
     * @example
     * // Get one RoleType
     * const roleType = await prisma.roleType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTypeFindFirstArgs} args - Arguments to find a RoleType
     * @example
     * // Get one RoleType
     * const roleType = await prisma.roleType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTypeFindFirstArgs>(args?: SelectSubset<T, RoleTypeFindFirstArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTypeFindFirstOrThrowArgs} args - Arguments to find a RoleType
     * @example
     * // Get one RoleType
     * const roleType = await prisma.roleType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTypes
     * const roleTypes = await prisma.roleType.findMany()
     * 
     * // Get first 10 RoleTypes
     * const roleTypes = await prisma.roleType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTypeWithIdOnly = await prisma.roleType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTypeFindManyArgs>(args?: SelectSubset<T, RoleTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleType.
     * @param {RoleTypeCreateArgs} args - Arguments to create a RoleType.
     * @example
     * // Create one RoleType
     * const RoleType = await prisma.roleType.create({
     *   data: {
     *     // ... data to create a RoleType
     *   }
     * })
     * 
     */
    create<T extends RoleTypeCreateArgs>(args: SelectSubset<T, RoleTypeCreateArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleTypes.
     * @param {RoleTypeCreateManyArgs} args - Arguments to create many RoleTypes.
     * @example
     * // Create many RoleTypes
     * const roleType = await prisma.roleType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTypeCreateManyArgs>(args?: SelectSubset<T, RoleTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTypes and returns the data saved in the database.
     * @param {RoleTypeCreateManyAndReturnArgs} args - Arguments to create many RoleTypes.
     * @example
     * // Create many RoleTypes
     * const roleType = await prisma.roleType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTypes and only return the `id`
     * const roleTypeWithIdOnly = await prisma.roleType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleType.
     * @param {RoleTypeDeleteArgs} args - Arguments to delete one RoleType.
     * @example
     * // Delete one RoleType
     * const RoleType = await prisma.roleType.delete({
     *   where: {
     *     // ... filter to delete one RoleType
     *   }
     * })
     * 
     */
    delete<T extends RoleTypeDeleteArgs>(args: SelectSubset<T, RoleTypeDeleteArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleType.
     * @param {RoleTypeUpdateArgs} args - Arguments to update one RoleType.
     * @example
     * // Update one RoleType
     * const roleType = await prisma.roleType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTypeUpdateArgs>(args: SelectSubset<T, RoleTypeUpdateArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleTypes.
     * @param {RoleTypeDeleteManyArgs} args - Arguments to filter RoleTypes to delete.
     * @example
     * // Delete a few RoleTypes
     * const { count } = await prisma.roleType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTypeDeleteManyArgs>(args?: SelectSubset<T, RoleTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTypes
     * const roleType = await prisma.roleType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTypeUpdateManyArgs>(args: SelectSubset<T, RoleTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleType.
     * @param {RoleTypeUpsertArgs} args - Arguments to update or create a RoleType.
     * @example
     * // Update or create a RoleType
     * const roleType = await prisma.roleType.upsert({
     *   create: {
     *     // ... data to create a RoleType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleType we want to update
     *   }
     * })
     */
    upsert<T extends RoleTypeUpsertArgs>(args: SelectSubset<T, RoleTypeUpsertArgs<ExtArgs>>): Prisma__RoleTypeClient<$Result.GetResult<Prisma.$RoleTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTypeCountArgs} args - Arguments to filter RoleTypes to count.
     * @example
     * // Count the number of RoleTypes
     * const count = await prisma.roleType.count({
     *   where: {
     *     // ... the filter for the RoleTypes we want to count
     *   }
     * })
    **/
    count<T extends RoleTypeCountArgs>(
      args?: Subset<T, RoleTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTypeAggregateArgs>(args: Subset<T, RoleTypeAggregateArgs>): Prisma.PrismaPromise<GetRoleTypeAggregateType<T>>

    /**
     * Group by RoleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTypeGroupByArgs['orderBy'] }
        : { orderBy?: RoleTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleType model
   */
  readonly fields: RoleTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends RoleType$RoleArgs<ExtArgs> = {}>(args?: Subset<T, RoleType$RoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleType model
   */ 
  interface RoleTypeFieldRefs {
    readonly id: FieldRef<"RoleType", 'String'>
    readonly roleType: FieldRef<"RoleType", 'String'>
    readonly createdAt: FieldRef<"RoleType", 'DateTime'>
    readonly createdBy: FieldRef<"RoleType", 'String'>
    readonly enable: FieldRef<"RoleType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RoleType findUnique
   */
  export type RoleTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoleType to fetch.
     */
    where: RoleTypeWhereUniqueInput
  }

  /**
   * RoleType findUniqueOrThrow
   */
  export type RoleTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoleType to fetch.
     */
    where: RoleTypeWhereUniqueInput
  }

  /**
   * RoleType findFirst
   */
  export type RoleTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoleType to fetch.
     */
    where?: RoleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTypes to fetch.
     */
    orderBy?: RoleTypeOrderByWithRelationInput | RoleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTypes.
     */
    cursor?: RoleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTypes.
     */
    distinct?: RoleTypeScalarFieldEnum | RoleTypeScalarFieldEnum[]
  }

  /**
   * RoleType findFirstOrThrow
   */
  export type RoleTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoleType to fetch.
     */
    where?: RoleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTypes to fetch.
     */
    orderBy?: RoleTypeOrderByWithRelationInput | RoleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTypes.
     */
    cursor?: RoleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTypes.
     */
    distinct?: RoleTypeScalarFieldEnum | RoleTypeScalarFieldEnum[]
  }

  /**
   * RoleType findMany
   */
  export type RoleTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoleTypes to fetch.
     */
    where?: RoleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTypes to fetch.
     */
    orderBy?: RoleTypeOrderByWithRelationInput | RoleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTypes.
     */
    cursor?: RoleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTypes.
     */
    skip?: number
    distinct?: RoleTypeScalarFieldEnum | RoleTypeScalarFieldEnum[]
  }

  /**
   * RoleType create
   */
  export type RoleTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleType.
     */
    data: XOR<RoleTypeCreateInput, RoleTypeUncheckedCreateInput>
  }

  /**
   * RoleType createMany
   */
  export type RoleTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTypes.
     */
    data: RoleTypeCreateManyInput | RoleTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleType createManyAndReturn
   */
  export type RoleTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleTypes.
     */
    data: RoleTypeCreateManyInput | RoleTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleType update
   */
  export type RoleTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleType.
     */
    data: XOR<RoleTypeUpdateInput, RoleTypeUncheckedUpdateInput>
    /**
     * Choose, which RoleType to update.
     */
    where: RoleTypeWhereUniqueInput
  }

  /**
   * RoleType updateMany
   */
  export type RoleTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTypes.
     */
    data: XOR<RoleTypeUpdateManyMutationInput, RoleTypeUncheckedUpdateManyInput>
    /**
     * Filter which RoleTypes to update
     */
    where?: RoleTypeWhereInput
  }

  /**
   * RoleType upsert
   */
  export type RoleTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleType to update in case it exists.
     */
    where: RoleTypeWhereUniqueInput
    /**
     * In case the RoleType found by the `where` argument doesn't exist, create a new RoleType with this data.
     */
    create: XOR<RoleTypeCreateInput, RoleTypeUncheckedCreateInput>
    /**
     * In case the RoleType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTypeUpdateInput, RoleTypeUncheckedUpdateInput>
  }

  /**
   * RoleType delete
   */
  export type RoleTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
    /**
     * Filter which RoleType to delete.
     */
    where: RoleTypeWhereUniqueInput
  }

  /**
   * RoleType deleteMany
   */
  export type RoleTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTypes to delete
     */
    where?: RoleTypeWhereInput
  }

  /**
   * RoleType.Role
   */
  export type RoleType$RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * RoleType without action
   */
  export type RoleTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleType
     */
    select?: RoleTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTypeInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    phone2: string | null
    fax: string | null
    mailingAddress: string | null
    mailingAddressBuilding: string | null
    mailingCity: string | null
    mailingState: string | null
    mailingZipCode: string | null
    billingAddressStreet: string | null
    billingAddressBuilding: string | null
    billingAddressCity: string | null
    billingAddressState: string | null
    billingAddressPostalCode: string | null
    website: string | null
    enable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    phone2: string | null
    fax: string | null
    mailingAddress: string | null
    mailingAddressBuilding: string | null
    mailingCity: string | null
    mailingState: string | null
    mailingZipCode: string | null
    billingAddressStreet: string | null
    billingAddressBuilding: string | null
    billingAddressCity: string | null
    billingAddressState: string | null
    billingAddressPostalCode: string | null
    website: string | null
    enable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    phone2: number
    fax: number
    mailingAddress: number
    mailingAddressBuilding: number
    mailingCity: number
    mailingState: number
    mailingZipCode: number
    billingAddressStreet: number
    billingAddressBuilding: number
    billingAddressCity: number
    billingAddressState: number
    billingAddressPostalCode: number
    website: number
    enable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    phone2?: true
    fax?: true
    mailingAddress?: true
    mailingAddressBuilding?: true
    mailingCity?: true
    mailingState?: true
    mailingZipCode?: true
    billingAddressStreet?: true
    billingAddressBuilding?: true
    billingAddressCity?: true
    billingAddressState?: true
    billingAddressPostalCode?: true
    website?: true
    enable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    phone2?: true
    fax?: true
    mailingAddress?: true
    mailingAddressBuilding?: true
    mailingCity?: true
    mailingState?: true
    mailingZipCode?: true
    billingAddressStreet?: true
    billingAddressBuilding?: true
    billingAddressCity?: true
    billingAddressState?: true
    billingAddressPostalCode?: true
    website?: true
    enable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    phone2?: true
    fax?: true
    mailingAddress?: true
    mailingAddressBuilding?: true
    mailingCity?: true
    mailingState?: true
    mailingZipCode?: true
    billingAddressStreet?: true
    billingAddressBuilding?: true
    billingAddressCity?: true
    billingAddressState?: true
    billingAddressPostalCode?: true
    website?: true
    enable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    phone2: string | null
    fax: string | null
    mailingAddress: string | null
    mailingAddressBuilding: string | null
    mailingCity: string | null
    mailingState: string | null
    mailingZipCode: string | null
    billingAddressStreet: string | null
    billingAddressBuilding: string | null
    billingAddressCity: string | null
    billingAddressState: string | null
    billingAddressPostalCode: string | null
    website: string | null
    enable: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    phone2?: boolean
    fax?: boolean
    mailingAddress?: boolean
    mailingAddressBuilding?: boolean
    mailingCity?: boolean
    mailingState?: boolean
    mailingZipCode?: boolean
    billingAddressStreet?: boolean
    billingAddressBuilding?: boolean
    billingAddressCity?: boolean
    billingAddressState?: boolean
    billingAddressPostalCode?: boolean
    website?: boolean
    enable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | Account$RoleArgs<ExtArgs>
    subAccount?: boolean | Account$subAccountArgs<ExtArgs>
    projectAccounts?: boolean | Account$projectAccountsArgs<ExtArgs>
    taskAccounts?: boolean | Account$taskAccountsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    phone2?: boolean
    fax?: boolean
    mailingAddress?: boolean
    mailingAddressBuilding?: boolean
    mailingCity?: boolean
    mailingState?: boolean
    mailingZipCode?: boolean
    billingAddressStreet?: boolean
    billingAddressBuilding?: boolean
    billingAddressCity?: boolean
    billingAddressState?: boolean
    billingAddressPostalCode?: boolean
    website?: boolean
    enable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    phone2?: boolean
    fax?: boolean
    mailingAddress?: boolean
    mailingAddressBuilding?: boolean
    mailingCity?: boolean
    mailingState?: boolean
    mailingZipCode?: boolean
    billingAddressStreet?: boolean
    billingAddressBuilding?: boolean
    billingAddressCity?: boolean
    billingAddressState?: boolean
    billingAddressPostalCode?: boolean
    website?: boolean
    enable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | Account$RoleArgs<ExtArgs>
    subAccount?: boolean | Account$subAccountArgs<ExtArgs>
    projectAccounts?: boolean | Account$projectAccountsArgs<ExtArgs>
    taskAccounts?: boolean | Account$taskAccountsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>[]
      subAccount: Prisma.$SubAccountPayload<ExtArgs>[]
      projectAccounts: Prisma.$ProjectAccountPayload<ExtArgs>[]
      taskAccounts: Prisma.$TaskAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      lastName: string | null
      email: string | null
      phone: string | null
      phone2: string | null
      fax: string | null
      mailingAddress: string | null
      mailingAddressBuilding: string | null
      mailingCity: string | null
      mailingState: string | null
      mailingZipCode: string | null
      billingAddressStreet: string | null
      billingAddressBuilding: string | null
      billingAddressCity: string | null
      billingAddressState: string | null
      billingAddressPostalCode: string | null
      website: string | null
      enable: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends Account$RoleArgs<ExtArgs> = {}>(args?: Subset<T, Account$RoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany"> | Null>
    subAccount<T extends Account$subAccountArgs<ExtArgs> = {}>(args?: Subset<T, Account$subAccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany"> | Null>
    projectAccounts<T extends Account$projectAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$projectAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectAccountPayload<ExtArgs>, T, "findMany"> | Null>
    taskAccounts<T extends Account$taskAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$taskAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAccountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly firstName: FieldRef<"Account", 'String'>
    readonly lastName: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly phone: FieldRef<"Account", 'String'>
    readonly phone2: FieldRef<"Account", 'String'>
    readonly fax: FieldRef<"Account", 'String'>
    readonly mailingAddress: FieldRef<"Account", 'String'>
    readonly mailingAddressBuilding: FieldRef<"Account", 'String'>
    readonly mailingCity: FieldRef<"Account", 'String'>
    readonly mailingState: FieldRef<"Account", 'String'>
    readonly mailingZipCode: FieldRef<"Account", 'String'>
    readonly billingAddressStreet: FieldRef<"Account", 'String'>
    readonly billingAddressBuilding: FieldRef<"Account", 'String'>
    readonly billingAddressCity: FieldRef<"Account", 'String'>
    readonly billingAddressState: FieldRef<"Account", 'String'>
    readonly billingAddressPostalCode: FieldRef<"Account", 'String'>
    readonly website: FieldRef<"Account", 'String'>
    readonly enable: FieldRef<"Account", 'Boolean'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.Role
   */
  export type Account$RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Account.subAccount
   */
  export type Account$subAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    cursor?: SubAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * Account.projectAccounts
   */
  export type Account$projectAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectAccount
     */
    select?: ProjectAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectAccountInclude<ExtArgs> | null
    where?: ProjectAccountWhereInput
    orderBy?: ProjectAccountOrderByWithRelationInput | ProjectAccountOrderByWithRelationInput[]
    cursor?: ProjectAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectAccountScalarFieldEnum | ProjectAccountScalarFieldEnum[]
  }

  /**
   * Account.taskAccounts
   */
  export type Account$taskAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAccount
     */
    select?: TaskAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAccountInclude<ExtArgs> | null
    where?: TaskAccountWhereInput
    orderBy?: TaskAccountOrderByWithRelationInput | TaskAccountOrderByWithRelationInput[]
    cursor?: TaskAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAccountScalarFieldEnum | TaskAccountScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model SubAccount
   */

  export type AggregateSubAccount = {
    _count: SubAccountCountAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  export type SubAccountMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    accountId: string | null
    enable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubAccountMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    accountId: string | null
    enable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubAccountCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phone: number
    accountId: number
    enable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubAccountMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    accountId?: true
    enable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubAccountMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    accountId?: true
    enable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubAccountCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    accountId?: true
    enable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccount to aggregate.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccounts
    **/
    _count?: true | SubAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountMaxAggregateInputType
  }

  export type GetSubAccountAggregateType<T extends SubAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccount[P]>
      : GetScalarType<T[P], AggregateSubAccount[P]>
  }




  export type SubAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithAggregationInput | SubAccountOrderByWithAggregationInput[]
    by: SubAccountScalarFieldEnum[] | SubAccountScalarFieldEnum
    having?: SubAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountCountAggregateInputType | true
    _min?: SubAccountMinAggregateInputType
    _max?: SubAccountMaxAggregateInputType
  }

  export type SubAccountGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    phone: string | null
    accountId: string
    enable: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: SubAccountCountAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  type GetSubAccountGroupByPayload<T extends SubAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    accountId?: boolean
    enable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    incidents?: boolean | SubAccount$incidentsArgs<ExtArgs>
    policeIncidents?: boolean | SubAccount$policeIncidentsArgs<ExtArgs>
    _count?: boolean | SubAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    accountId?: boolean
    enable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    accountId?: boolean
    enable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    incidents?: boolean | SubAccount$incidentsArgs<ExtArgs>
    policeIncidents?: boolean | SubAccount$policeIncidentsArgs<ExtArgs>
    _count?: boolean | SubAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $SubAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccount"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      policeIncidents: Prisma.$IncidentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      lastName: string | null
      phone: string | null
      accountId: string
      enable: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subAccount"]>
    composites: {}
  }

  type SubAccountGetPayload<S extends boolean | null | undefined | SubAccountDefaultArgs> = $Result.GetResult<Prisma.$SubAccountPayload, S>

  type SubAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubAccountCountAggregateInputType | true
    }

  export interface SubAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccount'], meta: { name: 'SubAccount' } }
    /**
     * Find zero or one SubAccount that matches the filter.
     * @param {SubAccountFindUniqueArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountFindUniqueArgs>(args: SelectSubset<T, SubAccountFindUniqueArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubAccountFindUniqueOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountFindFirstArgs>(args?: SelectSubset<T, SubAccountFindFirstArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccounts
     * const subAccounts = await prisma.subAccount.findMany()
     * 
     * // Get first 10 SubAccounts
     * const subAccounts = await prisma.subAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountFindManyArgs>(args?: SelectSubset<T, SubAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubAccount.
     * @param {SubAccountCreateArgs} args - Arguments to create a SubAccount.
     * @example
     * // Create one SubAccount
     * const SubAccount = await prisma.subAccount.create({
     *   data: {
     *     // ... data to create a SubAccount
     *   }
     * })
     * 
     */
    create<T extends SubAccountCreateArgs>(args: SelectSubset<T, SubAccountCreateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubAccounts.
     * @param {SubAccountCreateManyArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccount = await prisma.subAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountCreateManyArgs>(args?: SelectSubset<T, SubAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubAccounts and returns the data saved in the database.
     * @param {SubAccountCreateManyAndReturnArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccount = await prisma.subAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubAccounts and only return the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SubAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubAccount.
     * @param {SubAccountDeleteArgs} args - Arguments to delete one SubAccount.
     * @example
     * // Delete one SubAccount
     * const SubAccount = await prisma.subAccount.delete({
     *   where: {
     *     // ... filter to delete one SubAccount
     *   }
     * })
     * 
     */
    delete<T extends SubAccountDeleteArgs>(args: SelectSubset<T, SubAccountDeleteArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubAccount.
     * @param {SubAccountUpdateArgs} args - Arguments to update one SubAccount.
     * @example
     * // Update one SubAccount
     * const subAccount = await prisma.subAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountUpdateArgs>(args: SelectSubset<T, SubAccountUpdateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubAccounts.
     * @param {SubAccountDeleteManyArgs} args - Arguments to filter SubAccounts to delete.
     * @example
     * // Delete a few SubAccounts
     * const { count } = await prisma.subAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountDeleteManyArgs>(args?: SelectSubset<T, SubAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccounts
     * const subAccount = await prisma.subAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountUpdateManyArgs>(args: SelectSubset<T, SubAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubAccount.
     * @param {SubAccountUpsertArgs} args - Arguments to update or create a SubAccount.
     * @example
     * // Update or create a SubAccount
     * const subAccount = await prisma.subAccount.upsert({
     *   create: {
     *     // ... data to create a SubAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccount we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountUpsertArgs>(args: SelectSubset<T, SubAccountUpsertArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountCountArgs} args - Arguments to filter SubAccounts to count.
     * @example
     * // Count the number of SubAccounts
     * const count = await prisma.subAccount.count({
     *   where: {
     *     // ... the filter for the SubAccounts we want to count
     *   }
     * })
    **/
    count<T extends SubAccountCountArgs>(
      args?: Subset<T, SubAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountAggregateArgs>(args: Subset<T, SubAccountAggregateArgs>): Prisma.PrismaPromise<GetSubAccountAggregateType<T>>

    /**
     * Group by SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccount model
   */
  readonly fields: SubAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    incidents<T extends SubAccount$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    policeIncidents<T extends SubAccount$policeIncidentsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$policeIncidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccount model
   */ 
  interface SubAccountFieldRefs {
    readonly id: FieldRef<"SubAccount", 'String'>
    readonly firstName: FieldRef<"SubAccount", 'String'>
    readonly lastName: FieldRef<"SubAccount", 'String'>
    readonly phone: FieldRef<"SubAccount", 'String'>
    readonly accountId: FieldRef<"SubAccount", 'String'>
    readonly enable: FieldRef<"SubAccount", 'Boolean'>
    readonly createdAt: FieldRef<"SubAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubAccount findUnique
   */
  export type SubAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findUniqueOrThrow
   */
  export type SubAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findFirst
   */
  export type SubAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findFirstOrThrow
   */
  export type SubAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findMany
   */
  export type SubAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount create
   */
  export type SubAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccount.
     */
    data: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
  }

  /**
   * SubAccount createMany
   */
  export type SubAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountCreateManyInput | SubAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccount createManyAndReturn
   */
  export type SubAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountCreateManyInput | SubAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccount update
   */
  export type SubAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccount.
     */
    data: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
    /**
     * Choose, which SubAccount to update.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount updateMany
   */
  export type SubAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountWhereInput
  }

  /**
   * SubAccount upsert
   */
  export type SubAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccount to update in case it exists.
     */
    where: SubAccountWhereUniqueInput
    /**
     * In case the SubAccount found by the `where` argument doesn't exist, create a new SubAccount with this data.
     */
    create: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
    /**
     * In case the SubAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
  }

  /**
   * SubAccount delete
   */
  export type SubAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter which SubAccount to delete.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount deleteMany
   */
  export type SubAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccounts to delete
     */
    where?: SubAccountWhereInput
  }

  /**
   * SubAccount.incidents
   */
  export type SubAccount$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * SubAccount.policeIncidents
   */
  export type SubAccount$policeIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * SubAccount without action
   */
  export type SubAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
  }


  /**
   * Model Car
   */

  export type AggregateCar = {
    _count: CarCountAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  export type CarMinAggregateOutputType = {
    id: string | null
    make: string | null
    model: string | null
    year: string | null
  }

  export type CarMaxAggregateOutputType = {
    id: string | null
    make: string | null
    model: string | null
    year: string | null
  }

  export type CarCountAggregateOutputType = {
    id: number
    make: number
    model: number
    year: number
    _all: number
  }


  export type CarMinAggregateInputType = {
    id?: true
    make?: true
    model?: true
    year?: true
  }

  export type CarMaxAggregateInputType = {
    id?: true
    make?: true
    model?: true
    year?: true
  }

  export type CarCountAggregateInputType = {
    id?: true
    make?: true
    model?: true
    year?: true
    _all?: true
  }

  export type CarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Car to aggregate.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cars
    **/
    _count?: true | CarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarMaxAggregateInputType
  }

  export type GetCarAggregateType<T extends CarAggregateArgs> = {
        [P in keyof T & keyof AggregateCar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar[P]>
      : GetScalarType<T[P], AggregateCar[P]>
  }




  export type CarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarWhereInput
    orderBy?: CarOrderByWithAggregationInput | CarOrderByWithAggregationInput[]
    by: CarScalarFieldEnum[] | CarScalarFieldEnum
    having?: CarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarCountAggregateInputType | true
    _min?: CarMinAggregateInputType
    _max?: CarMaxAggregateInputType
  }

  export type CarGroupByOutputType = {
    id: string
    make: string
    model: string
    year: string
    _count: CarCountAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  type GetCarGroupByPayload<T extends CarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarGroupByOutputType[P]>
            : GetScalarType<T[P], CarGroupByOutputType[P]>
        }
      >
    >


  export type CarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
  }, ExtArgs["result"]["car"]>

  export type CarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
  }, ExtArgs["result"]["car"]>

  export type CarSelectScalar = {
    id?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
  }


  export type $CarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Car"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      make: string
      model: string
      year: string
    }, ExtArgs["result"]["car"]>
    composites: {}
  }

  type CarGetPayload<S extends boolean | null | undefined | CarDefaultArgs> = $Result.GetResult<Prisma.$CarPayload, S>

  type CarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CarCountAggregateInputType | true
    }

  export interface CarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Car'], meta: { name: 'Car' } }
    /**
     * Find zero or one Car that matches the filter.
     * @param {CarFindUniqueArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarFindUniqueArgs>(args: SelectSubset<T, CarFindUniqueArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Car that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CarFindUniqueOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarFindUniqueOrThrowArgs>(args: SelectSubset<T, CarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Car that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarFindFirstArgs>(args?: SelectSubset<T, CarFindFirstArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Car that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarFindFirstOrThrowArgs>(args?: SelectSubset<T, CarFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cars
     * const cars = await prisma.car.findMany()
     * 
     * // Get first 10 Cars
     * const cars = await prisma.car.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carWithIdOnly = await prisma.car.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarFindManyArgs>(args?: SelectSubset<T, CarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Car.
     * @param {CarCreateArgs} args - Arguments to create a Car.
     * @example
     * // Create one Car
     * const Car = await prisma.car.create({
     *   data: {
     *     // ... data to create a Car
     *   }
     * })
     * 
     */
    create<T extends CarCreateArgs>(args: SelectSubset<T, CarCreateArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cars.
     * @param {CarCreateManyArgs} args - Arguments to create many Cars.
     * @example
     * // Create many Cars
     * const car = await prisma.car.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarCreateManyArgs>(args?: SelectSubset<T, CarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cars and returns the data saved in the database.
     * @param {CarCreateManyAndReturnArgs} args - Arguments to create many Cars.
     * @example
     * // Create many Cars
     * const car = await prisma.car.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cars and only return the `id`
     * const carWithIdOnly = await prisma.car.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarCreateManyAndReturnArgs>(args?: SelectSubset<T, CarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Car.
     * @param {CarDeleteArgs} args - Arguments to delete one Car.
     * @example
     * // Delete one Car
     * const Car = await prisma.car.delete({
     *   where: {
     *     // ... filter to delete one Car
     *   }
     * })
     * 
     */
    delete<T extends CarDeleteArgs>(args: SelectSubset<T, CarDeleteArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Car.
     * @param {CarUpdateArgs} args - Arguments to update one Car.
     * @example
     * // Update one Car
     * const car = await prisma.car.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarUpdateArgs>(args: SelectSubset<T, CarUpdateArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cars.
     * @param {CarDeleteManyArgs} args - Arguments to filter Cars to delete.
     * @example
     * // Delete a few Cars
     * const { count } = await prisma.car.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarDeleteManyArgs>(args?: SelectSubset<T, CarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cars
     * const car = await prisma.car.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarUpdateManyArgs>(args: SelectSubset<T, CarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car.
     * @param {CarUpsertArgs} args - Arguments to update or create a Car.
     * @example
     * // Update or create a Car
     * const car = await prisma.car.upsert({
     *   create: {
     *     // ... data to create a Car
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car we want to update
     *   }
     * })
     */
    upsert<T extends CarUpsertArgs>(args: SelectSubset<T, CarUpsertArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarCountArgs} args - Arguments to filter Cars to count.
     * @example
     * // Count the number of Cars
     * const count = await prisma.car.count({
     *   where: {
     *     // ... the filter for the Cars we want to count
     *   }
     * })
    **/
    count<T extends CarCountArgs>(
      args?: Subset<T, CarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarAggregateArgs>(args: Subset<T, CarAggregateArgs>): Prisma.PrismaPromise<GetCarAggregateType<T>>

    /**
     * Group by Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarGroupByArgs['orderBy'] }
        : { orderBy?: CarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Car model
   */
  readonly fields: CarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Car.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Car model
   */ 
  interface CarFieldRefs {
    readonly id: FieldRef<"Car", 'String'>
    readonly make: FieldRef<"Car", 'String'>
    readonly model: FieldRef<"Car", 'String'>
    readonly year: FieldRef<"Car", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Car findUnique
   */
  export type CarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car findUniqueOrThrow
   */
  export type CarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car findFirst
   */
  export type CarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car findFirstOrThrow
   */
  export type CarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car findMany
   */
  export type CarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Filter, which Cars to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car create
   */
  export type CarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * The data needed to create a Car.
     */
    data: XOR<CarCreateInput, CarUncheckedCreateInput>
  }

  /**
   * Car createMany
   */
  export type CarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cars.
     */
    data: CarCreateManyInput | CarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Car createManyAndReturn
   */
  export type CarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cars.
     */
    data: CarCreateManyInput | CarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Car update
   */
  export type CarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * The data needed to update a Car.
     */
    data: XOR<CarUpdateInput, CarUncheckedUpdateInput>
    /**
     * Choose, which Car to update.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car updateMany
   */
  export type CarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cars.
     */
    data: XOR<CarUpdateManyMutationInput, CarUncheckedUpdateManyInput>
    /**
     * Filter which Cars to update
     */
    where?: CarWhereInput
  }

  /**
   * Car upsert
   */
  export type CarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * The filter to search for the Car to update in case it exists.
     */
    where: CarWhereUniqueInput
    /**
     * In case the Car found by the `where` argument doesn't exist, create a new Car with this data.
     */
    create: XOR<CarCreateInput, CarUncheckedCreateInput>
    /**
     * In case the Car was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarUpdateInput, CarUncheckedUpdateInput>
  }

  /**
   * Car delete
   */
  export type CarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Filter which Car to delete.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car deleteMany
   */
  export type CarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cars to delete
     */
    where?: CarWhereInput
  }

  /**
   * Car without action
   */
  export type CarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectUserScalarFieldEnum: {
    projectId: 'projectId',
    userId: 'userId',
    assignedAt: 'assignedAt'
  };

  export type ProjectUserScalarFieldEnum = (typeof ProjectUserScalarFieldEnum)[keyof typeof ProjectUserScalarFieldEnum]


  export const ProjectAccountScalarFieldEnum: {
    projectId: 'projectId',
    accountId: 'accountId',
    assignedAt: 'assignedAt'
  };

  export type ProjectAccountScalarFieldEnum = (typeof ProjectAccountScalarFieldEnum)[keyof typeof ProjectAccountScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const ColumnScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    boardId: 'boardId'
  };

  export type ColumnScalarFieldEnum = (typeof ColumnScalarFieldEnum)[keyof typeof ColumnScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    priority: 'priority',
    dueDate: 'dueDate',
    status: 'status',
    position: 'position',
    archive: 'archive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    columnId: 'columnId',
    createdById: 'createdById',
    claimId: 'claimId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskAccountScalarFieldEnum: {
    taskId: 'taskId',
    accountId: 'accountId',
    assignedAt: 'assignedAt'
  };

  export type TaskAccountScalarFieldEnum = (typeof TaskAccountScalarFieldEnum)[keyof typeof TaskAccountScalarFieldEnum]


  export const TaskAssigneeScalarFieldEnum: {
    taskId: 'taskId',
    userId: 'userId',
    assignedAt: 'assignedAt'
  };

  export type TaskAssigneeScalarFieldEnum = (typeof TaskAssigneeScalarFieldEnum)[keyof typeof TaskAssigneeScalarFieldEnum]


  export const TaskCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    taskId: 'taskId',
    userId: 'userId'
  };

  export type TaskCommentScalarFieldEnum = (typeof TaskCommentScalarFieldEnum)[keyof typeof TaskCommentScalarFieldEnum]


  export const TaskAttachmentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    originalName: 'originalName',
    s3Key: 's3Key',
    s3Bucket: 's3Bucket',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedAt: 'uploadedAt',
    isPublic: 'isPublic',
    etag: 'etag',
    checksum: 'checksum',
    taskId: 'taskId',
    uploadedById: 'uploadedById'
  };

  export type TaskAttachmentScalarFieldEnum = (typeof TaskAttachmentScalarFieldEnum)[keyof typeof TaskAttachmentScalarFieldEnum]


  export const TaskLabelScalarFieldEnum: {
    taskId: 'taskId',
    labelId: 'labelId',
    assignedAt: 'assignedAt'
  };

  export type TaskLabelScalarFieldEnum = (typeof TaskLabelScalarFieldEnum)[keyof typeof TaskLabelScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    colour: 'colour',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    injured: 'injured',
    email: 'email',
    phone: 'phone',
    password: 'password',
    phone2: 'phone2',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    isUnder18: 'isUnder18',
    fatherFirstName: 'fatherFirstName',
    fatherLastName: 'fatherLastName',
    motherFirstName: 'motherFirstName',
    motherLastName: 'motherLastName',
    mailingAddress1: 'mailingAddress1',
    mailingAddress2: 'mailingAddress2',
    mailingCity: 'mailingCity',
    mailingState: 'mailingState',
    mailingZipCode: 'mailingZipCode',
    isPOBoxOrDifferentAddress: 'isPOBoxOrDifferentAddress',
    physicalAddress1: 'physicalAddress1',
    physicalAddress2: 'physicalAddress2',
    physicalCity: 'physicalCity',
    physicalState: 'physicalState',
    physicalZipCode: 'physicalZipCode',
    maritalStatus: 'maritalStatus',
    spouseFirstName: 'spouseFirstName',
    spouseLastName: 'spouseLastName',
    spousePhone: 'spousePhone',
    employmentStatus: 'employmentStatus',
    employerName: 'employerName',
    employerTitle: 'employerTitle',
    employmentType: 'employmentType',
    pay: 'pay',
    schoolName: 'schoolName',
    expectedGraduationYear: 'expectedGraduationYear',
    role: 'role',
    isVerified: 'isVerified',
    verificationCode: 'verificationCode',
    sourceId: 'sourceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    claimlistId: 'claimlistId',
    accountSync: 'accountSync'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerifyScalarFieldEnum: {
    id: 'id',
    token: 'token',
    url: 'url',
    status: 'status',
    sessionId: 'sessionId',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type VerifyScalarFieldEnum = (typeof VerifyScalarFieldEnum)[keyof typeof VerifyScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    status: 'status',
    injured: 'injured',
    relationship: 'relationship',
    otherRelationship: 'otherRelationship',
    healthInsurance: 'healthInsurance',
    healthInsuranceNumber: 'healthInsuranceNumber',
    isOver65: 'isOver65',
    receiveMedicare: 'receiveMedicare',
    assignedCaseManager: 'assignedCaseManager',
    userId: 'userId',
    clientRoleId: 'clientRoleId',
    injuredPartyRoleId: 'injuredPartyRoleId',
    incidentId: 'incidentId',
    healthInsuranceProviderId: 'healthInsuranceProviderId',
    claimlistId: 'claimlistId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const ProjectClaimScalarFieldEnum: {
    projectId: 'projectId',
    claimId: 'claimId',
    assignedAt: 'assignedAt'
  };

  export type ProjectClaimScalarFieldEnum = (typeof ProjectClaimScalarFieldEnum)[keyof typeof ProjectClaimScalarFieldEnum]


  export const EnvelopScalarFieldEnum: {
    id: 'id',
    status: 'status',
    claimId: 'claimId',
    submitterUrl: 'submitterUrl',
    submitterId: 'submitterId',
    submittedUrl: 'submittedUrl',
    createdAt: 'createdAt'
  };

  export type EnvelopScalarFieldEnum = (typeof EnvelopScalarFieldEnum)[keyof typeof EnvelopScalarFieldEnum]


  export const ClaimListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    enable: 'enable',
    questionId: 'questionId',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type ClaimListScalarFieldEnum = (typeof ClaimListScalarFieldEnum)[keyof typeof ClaimListScalarFieldEnum]


  export const SourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    enable: 'enable'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const QuestionnaireScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId'
  };

  export type QuestionnaireScalarFieldEnum = (typeof QuestionnaireScalarFieldEnum)[keyof typeof QuestionnaireScalarFieldEnum]


  export const QuestionAnswerScalarFieldEnum: {
    id: 'id',
    questionnaireId: 'questionnaireId',
    questionId: 'questionId',
    answer: 'answer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionAnswerScalarFieldEnum = (typeof QuestionAnswerScalarFieldEnum)[keyof typeof QuestionAnswerScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    claimListId: 'claimListId',
    type: 'type',
    enable: 'enable'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const ChoiceScalarFieldEnum: {
    id: 'id',
    text: 'text',
    questionId: 'questionId'
  };

  export type ChoiceScalarFieldEnum = (typeof ChoiceScalarFieldEnum)[keyof typeof ChoiceScalarFieldEnum]


  export const DefendantScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId'
  };

  export type DefendantScalarFieldEnum = (typeof DefendantScalarFieldEnum)[keyof typeof DefendantScalarFieldEnum]


  export const DefendantDetailsScalarFieldEnum: {
    id: 'id',
    defendantRole: 'defendantRole',
    defendantAccountId: 'defendantAccountId',
    defendantInsuranceCarrierId: 'defendantInsuranceCarrierId',
    insurancePolicyNumber: 'insurancePolicyNumber',
    driverLicenseNumber: 'driverLicenseNumber',
    driverLicenseState: 'driverLicenseState',
    vehicleMake: 'vehicleMake',
    vehicleModel: 'vehicleModel',
    vehicleYear: 'vehicleYear',
    vehicleColor: 'vehicleColor',
    vehiclePlate: 'vehiclePlate',
    vehiclePosition: 'vehiclePosition',
    vehicleRegisteredState: 'vehicleRegisteredState',
    collisionType: 'collisionType',
    supervisorName: 'supervisorName',
    supervisorContact: 'supervisorContact',
    client: 'client',
    groupId: 'groupId',
    sort: 'sort',
    defendantId: 'defendantId'
  };

  export type DefendantDetailsScalarFieldEnum = (typeof DefendantDetailsScalarFieldEnum)[keyof typeof DefendantDetailsScalarFieldEnum]


  export const TreatmentAndInjuryScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId',
    treatmentId: 'treatmentId'
  };

  export type TreatmentAndInjuryScalarFieldEnum = (typeof TreatmentAndInjuryScalarFieldEnum)[keyof typeof TreatmentAndInjuryScalarFieldEnum]


  export const TreatmentScalarFieldEnum: {
    id: 'id',
    takenHospital: 'takenHospital',
    isCurrentlyTreated: 'isCurrentlyTreated',
    hospitalId: 'hospitalId',
    doctorId: 'doctorId',
    admission: 'admission',
    discharge: 'discharge',
    lastVisit: 'lastVisit',
    otherInjuries: 'otherInjuries'
  };

  export type TreatmentScalarFieldEnum = (typeof TreatmentScalarFieldEnum)[keyof typeof TreatmentScalarFieldEnum]


  export const InjuryScalarFieldEnum: {
    id: 'id',
    injuryLocation: 'injuryLocation',
    injury: 'injury',
    injuryLocationSide: 'injuryLocationSide',
    other: 'other',
    treatmentId: 'treatmentId'
  };

  export type InjuryScalarFieldEnum = (typeof InjuryScalarFieldEnum)[keyof typeof InjuryScalarFieldEnum]


  export const AccidentMediaScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    thumbnail: 'thumbnail',
    claimId: 'claimId'
  };

  export type AccidentMediaScalarFieldEnum = (typeof AccidentMediaScalarFieldEnum)[keyof typeof AccidentMediaScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    vehicleRole: 'vehicleRole',
    vehicleCount: 'vehicleCount',
    busOrVehicle: 'busOrVehicle',
    transportType: 'transportType',
    rideShareCompany: 'rideShareCompany',
    rideShareOtherName: 'rideShareOtherName',
    propertyType: 'propertyType',
    datetime: 'datetime',
    location: 'location',
    workRelated: 'workRelated',
    description: 'description',
    policeReportCompleted: 'policeReportCompleted',
    policeStationId: 'policeStationId',
    policeOfficerId: 'policeOfficerId',
    reportCompleted: 'reportCompleted',
    reportNumber: 'reportNumber',
    supportingDocument: 'supportingDocument',
    lostEarning: 'lostEarning',
    amountLoss: 'amountLoss',
    timeLoss: 'timeLoss',
    witness: 'witness',
    priorRepresentation: 'priorRepresentation',
    priorRepresentationReason: 'priorRepresentationReason',
    lawfirmId: 'lawfirmId',
    attorneyId: 'attorneyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const WitnessScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId'
  };

  export type WitnessScalarFieldEnum = (typeof WitnessScalarFieldEnum)[keyof typeof WitnessScalarFieldEnum]


  export const WitnessDetailsScalarFieldEnum: {
    id: 'id',
    witnessId: 'witnessId',
    roleId: 'roleId'
  };

  export type WitnessDetailsScalarFieldEnum = (typeof WitnessDetailsScalarFieldEnum)[keyof typeof WitnessDetailsScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    roletypeId: 'roletypeId'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RoleTypeScalarFieldEnum: {
    id: 'id',
    roleType: 'roleType',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    enable: 'enable'
  };

  export type RoleTypeScalarFieldEnum = (typeof RoleTypeScalarFieldEnum)[keyof typeof RoleTypeScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    phone2: 'phone2',
    fax: 'fax',
    mailingAddress: 'mailingAddress',
    mailingAddressBuilding: 'mailingAddressBuilding',
    mailingCity: 'mailingCity',
    mailingState: 'mailingState',
    mailingZipCode: 'mailingZipCode',
    billingAddressStreet: 'billingAddressStreet',
    billingAddressBuilding: 'billingAddressBuilding',
    billingAddressCity: 'billingAddressCity',
    billingAddressState: 'billingAddressState',
    billingAddressPostalCode: 'billingAddressPostalCode',
    website: 'website',
    enable: 'enable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SubAccountScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    accountId: 'accountId',
    enable: 'enable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubAccountScalarFieldEnum = (typeof SubAccountScalarFieldEnum)[keyof typeof SubAccountScalarFieldEnum]


  export const CarScalarFieldEnum: {
    id: 'id',
    make: 'make',
    model: 'model',
    year: 'year'
  };

  export type CarScalarFieldEnum = (typeof CarScalarFieldEnum)[keyof typeof CarScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TaskPriority'
   */
  export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


  /**
   * Reference to a field of type 'TaskPriority[]'
   */
  export type ListEnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'WereYouInjured'
   */
  export type EnumWereYouInjuredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WereYouInjured'>
    


  /**
   * Reference to a field of type 'WereYouInjured[]'
   */
  export type ListEnumWereYouInjuredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WereYouInjured[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'ClaimStatus'
   */
  export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


  /**
   * Reference to a field of type 'ClaimStatus[]'
   */
  export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


  /**
   * Reference to a field of type 'Relationship'
   */
  export type EnumRelationshipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Relationship'>
    


  /**
   * Reference to a field of type 'Relationship[]'
   */
  export type ListEnumRelationshipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Relationship[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'DefendantRole'
   */
  export type EnumDefendantRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefendantRole'>
    


  /**
   * Reference to a field of type 'DefendantRole[]'
   */
  export type ListEnumDefendantRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefendantRole[]'>
    


  /**
   * Reference to a field of type 'CollisionType'
   */
  export type EnumCollisionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollisionType'>
    


  /**
   * Reference to a field of type 'CollisionType[]'
   */
  export type ListEnumCollisionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollisionType[]'>
    


  /**
   * Reference to a field of type 'InjuryPoint'
   */
  export type EnumInjuryPointFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryPoint'>
    


  /**
   * Reference to a field of type 'InjuryPoint[]'
   */
  export type ListEnumInjuryPointFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryPoint[]'>
    


  /**
   * Reference to a field of type 'InjuryType'
   */
  export type EnumInjuryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryType'>
    


  /**
   * Reference to a field of type 'InjuryType[]'
   */
  export type ListEnumInjuryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryType[]'>
    


  /**
   * Reference to a field of type 'InjurySide'
   */
  export type EnumInjurySideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjurySide'>
    


  /**
   * Reference to a field of type 'InjurySide[]'
   */
  export type ListEnumInjurySideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjurySide[]'>
    


  /**
   * Reference to a field of type 'BusOrVehicle'
   */
  export type EnumBusOrVehicleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusOrVehicle'>
    


  /**
   * Reference to a field of type 'BusOrVehicle[]'
   */
  export type ListEnumBusOrVehicleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusOrVehicle[]'>
    


  /**
   * Reference to a field of type 'TransportType'
   */
  export type EnumTransportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransportType'>
    


  /**
   * Reference to a field of type 'TransportType[]'
   */
  export type ListEnumTransportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransportType[]'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    boards?: BoardListRelationFilter
    projectClaims?: ProjectClaimListRelationFilter
    projectAccounts?: ProjectAccountListRelationFilter
    projectUsers?: ProjectUserListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    owner?: UserOrderByWithRelationInput
    boards?: BoardOrderByRelationAggregateInput
    projectClaims?: ProjectClaimOrderByRelationAggregateInput
    projectAccounts?: ProjectAccountOrderByRelationAggregateInput
    projectUsers?: ProjectUserOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    boards?: BoardListRelationFilter
    projectClaims?: ProjectClaimListRelationFilter
    projectAccounts?: ProjectAccountListRelationFilter
    projectUsers?: ProjectUserListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    ownerId?: StringWithAggregatesFilter<"Project"> | string
  }

  export type ProjectUserWhereInput = {
    AND?: ProjectUserWhereInput | ProjectUserWhereInput[]
    OR?: ProjectUserWhereInput[]
    NOT?: ProjectUserWhereInput | ProjectUserWhereInput[]
    projectId?: StringFilter<"ProjectUser"> | string
    userId?: StringFilter<"ProjectUser"> | string
    assignedAt?: DateTimeFilter<"ProjectUser"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectUserOrderByWithRelationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectUserWhereUniqueInput = Prisma.AtLeast<{
    projectId_userId?: ProjectUserProjectIdUserIdCompoundUniqueInput
    AND?: ProjectUserWhereInput | ProjectUserWhereInput[]
    OR?: ProjectUserWhereInput[]
    NOT?: ProjectUserWhereInput | ProjectUserWhereInput[]
    projectId?: StringFilter<"ProjectUser"> | string
    userId?: StringFilter<"ProjectUser"> | string
    assignedAt?: DateTimeFilter<"ProjectUser"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "projectId_userId">

  export type ProjectUserOrderByWithAggregationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    _count?: ProjectUserCountOrderByAggregateInput
    _max?: ProjectUserMaxOrderByAggregateInput
    _min?: ProjectUserMinOrderByAggregateInput
  }

  export type ProjectUserScalarWhereWithAggregatesInput = {
    AND?: ProjectUserScalarWhereWithAggregatesInput | ProjectUserScalarWhereWithAggregatesInput[]
    OR?: ProjectUserScalarWhereWithAggregatesInput[]
    NOT?: ProjectUserScalarWhereWithAggregatesInput | ProjectUserScalarWhereWithAggregatesInput[]
    projectId?: StringWithAggregatesFilter<"ProjectUser"> | string
    userId?: StringWithAggregatesFilter<"ProjectUser"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"ProjectUser"> | Date | string
  }

  export type ProjectAccountWhereInput = {
    AND?: ProjectAccountWhereInput | ProjectAccountWhereInput[]
    OR?: ProjectAccountWhereInput[]
    NOT?: ProjectAccountWhereInput | ProjectAccountWhereInput[]
    projectId?: StringFilter<"ProjectAccount"> | string
    accountId?: StringFilter<"ProjectAccount"> | string
    assignedAt?: DateTimeFilter<"ProjectAccount"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type ProjectAccountOrderByWithRelationInput = {
    projectId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type ProjectAccountWhereUniqueInput = Prisma.AtLeast<{
    projectId_accountId?: ProjectAccountProjectIdAccountIdCompoundUniqueInput
    AND?: ProjectAccountWhereInput | ProjectAccountWhereInput[]
    OR?: ProjectAccountWhereInput[]
    NOT?: ProjectAccountWhereInput | ProjectAccountWhereInput[]
    projectId?: StringFilter<"ProjectAccount"> | string
    accountId?: StringFilter<"ProjectAccount"> | string
    assignedAt?: DateTimeFilter<"ProjectAccount"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "projectId_accountId">

  export type ProjectAccountOrderByWithAggregationInput = {
    projectId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
    _count?: ProjectAccountCountOrderByAggregateInput
    _max?: ProjectAccountMaxOrderByAggregateInput
    _min?: ProjectAccountMinOrderByAggregateInput
  }

  export type ProjectAccountScalarWhereWithAggregatesInput = {
    AND?: ProjectAccountScalarWhereWithAggregatesInput | ProjectAccountScalarWhereWithAggregatesInput[]
    OR?: ProjectAccountScalarWhereWithAggregatesInput[]
    NOT?: ProjectAccountScalarWhereWithAggregatesInput | ProjectAccountScalarWhereWithAggregatesInput[]
    projectId?: StringWithAggregatesFilter<"ProjectAccount"> | string
    accountId?: StringWithAggregatesFilter<"ProjectAccount"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"ProjectAccount"> | Date | string
  }

  export type BoardWhereInput = {
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    id?: StringFilter<"Board"> | string
    title?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    projectId?: StringFilter<"Board"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    columns?: ColumnListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    columns?: ColumnOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    title?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    projectId?: StringFilter<"Board"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    columns?: ColumnListRelationFilter
  }, "id">

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    OR?: BoardScalarWhereWithAggregatesInput[]
    NOT?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Board"> | string
    title?: StringWithAggregatesFilter<"Board"> | string
    description?: StringNullableWithAggregatesFilter<"Board"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    projectId?: StringWithAggregatesFilter<"Board"> | string
  }

  export type ColumnWhereInput = {
    AND?: ColumnWhereInput | ColumnWhereInput[]
    OR?: ColumnWhereInput[]
    NOT?: ColumnWhereInput | ColumnWhereInput[]
    id?: StringFilter<"Column"> | string
    title?: StringFilter<"Column"> | string
    description?: StringNullableFilter<"Column"> | string | null
    order?: IntFilter<"Column"> | number
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
    boardId?: StringFilter<"Column"> | string
    board?: XOR<BoardRelationFilter, BoardWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type ColumnOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
    board?: BoardOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ColumnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ColumnWhereInput | ColumnWhereInput[]
    OR?: ColumnWhereInput[]
    NOT?: ColumnWhereInput | ColumnWhereInput[]
    title?: StringFilter<"Column"> | string
    description?: StringNullableFilter<"Column"> | string | null
    order?: IntFilter<"Column"> | number
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
    boardId?: StringFilter<"Column"> | string
    board?: XOR<BoardRelationFilter, BoardWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type ColumnOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
    _count?: ColumnCountOrderByAggregateInput
    _avg?: ColumnAvgOrderByAggregateInput
    _max?: ColumnMaxOrderByAggregateInput
    _min?: ColumnMinOrderByAggregateInput
    _sum?: ColumnSumOrderByAggregateInput
  }

  export type ColumnScalarWhereWithAggregatesInput = {
    AND?: ColumnScalarWhereWithAggregatesInput | ColumnScalarWhereWithAggregatesInput[]
    OR?: ColumnScalarWhereWithAggregatesInput[]
    NOT?: ColumnScalarWhereWithAggregatesInput | ColumnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Column"> | string
    title?: StringWithAggregatesFilter<"Column"> | string
    description?: StringNullableWithAggregatesFilter<"Column"> | string | null
    order?: IntWithAggregatesFilter<"Column"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Column"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Column"> | Date | string
    boardId?: StringWithAggregatesFilter<"Column"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    status?: StringFilter<"Task"> | string
    position?: IntFilter<"Task"> | number
    archive?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    columnId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    claimId?: StringNullableFilter<"Task"> | string | null
    column?: XOR<ColumnRelationFilter, ColumnWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    taskAccounts?: TaskAccountListRelationFilter
    taskAssignees?: TaskAssigneeListRelationFilter
    comments?: TaskCommentListRelationFilter
    attachments?: TaskAttachmentListRelationFilter
    labels?: TaskLabelListRelationFilter
    claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    position?: SortOrder
    archive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    columnId?: SortOrder
    createdById?: SortOrder
    claimId?: SortOrderInput | SortOrder
    column?: ColumnOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    taskAccounts?: TaskAccountOrderByRelationAggregateInput
    taskAssignees?: TaskAssigneeOrderByRelationAggregateInput
    comments?: TaskCommentOrderByRelationAggregateInput
    attachments?: TaskAttachmentOrderByRelationAggregateInput
    labels?: TaskLabelOrderByRelationAggregateInput
    claim?: ClaimOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    status?: StringFilter<"Task"> | string
    position?: IntFilter<"Task"> | number
    archive?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    columnId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    claimId?: StringNullableFilter<"Task"> | string | null
    column?: XOR<ColumnRelationFilter, ColumnWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    taskAccounts?: TaskAccountListRelationFilter
    taskAssignees?: TaskAssigneeListRelationFilter
    comments?: TaskCommentListRelationFilter
    attachments?: TaskAttachmentListRelationFilter
    labels?: TaskLabelListRelationFilter
    claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    position?: SortOrder
    archive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    columnId?: SortOrder
    createdById?: SortOrder
    claimId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    priority?: EnumTaskPriorityWithAggregatesFilter<"Task"> | $Enums.TaskPriority
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    position?: IntWithAggregatesFilter<"Task"> | number
    archive?: BoolWithAggregatesFilter<"Task"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    columnId?: StringWithAggregatesFilter<"Task"> | string
    createdById?: StringWithAggregatesFilter<"Task"> | string
    claimId?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type TaskAccountWhereInput = {
    AND?: TaskAccountWhereInput | TaskAccountWhereInput[]
    OR?: TaskAccountWhereInput[]
    NOT?: TaskAccountWhereInput | TaskAccountWhereInput[]
    taskId?: StringFilter<"TaskAccount"> | string
    accountId?: StringFilter<"TaskAccount"> | string
    assignedAt?: DateTimeFilter<"TaskAccount"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type TaskAccountOrderByWithRelationInput = {
    taskId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type TaskAccountWhereUniqueInput = Prisma.AtLeast<{
    taskId_accountId?: TaskAccountTaskIdAccountIdCompoundUniqueInput
    AND?: TaskAccountWhereInput | TaskAccountWhereInput[]
    OR?: TaskAccountWhereInput[]
    NOT?: TaskAccountWhereInput | TaskAccountWhereInput[]
    taskId?: StringFilter<"TaskAccount"> | string
    accountId?: StringFilter<"TaskAccount"> | string
    assignedAt?: DateTimeFilter<"TaskAccount"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "taskId_accountId">

  export type TaskAccountOrderByWithAggregationInput = {
    taskId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
    _count?: TaskAccountCountOrderByAggregateInput
    _max?: TaskAccountMaxOrderByAggregateInput
    _min?: TaskAccountMinOrderByAggregateInput
  }

  export type TaskAccountScalarWhereWithAggregatesInput = {
    AND?: TaskAccountScalarWhereWithAggregatesInput | TaskAccountScalarWhereWithAggregatesInput[]
    OR?: TaskAccountScalarWhereWithAggregatesInput[]
    NOT?: TaskAccountScalarWhereWithAggregatesInput | TaskAccountScalarWhereWithAggregatesInput[]
    taskId?: StringWithAggregatesFilter<"TaskAccount"> | string
    accountId?: StringWithAggregatesFilter<"TaskAccount"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TaskAccount"> | Date | string
  }

  export type TaskAssigneeWhereInput = {
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    taskId?: StringFilter<"TaskAssignee"> | string
    userId?: StringFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeFilter<"TaskAssignee"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TaskAssigneeOrderByWithRelationInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskAssigneeWhereUniqueInput = Prisma.AtLeast<{
    taskId_userId?: TaskAssigneeTaskIdUserIdCompoundUniqueInput
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    taskId?: StringFilter<"TaskAssignee"> | string
    userId?: StringFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeFilter<"TaskAssignee"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "taskId_userId">

  export type TaskAssigneeOrderByWithAggregationInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    _count?: TaskAssigneeCountOrderByAggregateInput
    _max?: TaskAssigneeMaxOrderByAggregateInput
    _min?: TaskAssigneeMinOrderByAggregateInput
  }

  export type TaskAssigneeScalarWhereWithAggregatesInput = {
    AND?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    OR?: TaskAssigneeScalarWhereWithAggregatesInput[]
    NOT?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    taskId?: StringWithAggregatesFilter<"TaskAssignee"> | string
    userId?: StringWithAggregatesFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TaskAssignee"> | Date | string
  }

  export type TaskCommentWhereInput = {
    AND?: TaskCommentWhereInput | TaskCommentWhereInput[]
    OR?: TaskCommentWhereInput[]
    NOT?: TaskCommentWhereInput | TaskCommentWhereInput[]
    id?: StringFilter<"TaskComment"> | string
    content?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
    updatedAt?: DateTimeFilter<"TaskComment"> | Date | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TaskCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskCommentWhereInput | TaskCommentWhereInput[]
    OR?: TaskCommentWhereInput[]
    NOT?: TaskCommentWhereInput | TaskCommentWhereInput[]
    content?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
    updatedAt?: DateTimeFilter<"TaskComment"> | Date | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TaskCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    _count?: TaskCommentCountOrderByAggregateInput
    _max?: TaskCommentMaxOrderByAggregateInput
    _min?: TaskCommentMinOrderByAggregateInput
  }

  export type TaskCommentScalarWhereWithAggregatesInput = {
    AND?: TaskCommentScalarWhereWithAggregatesInput | TaskCommentScalarWhereWithAggregatesInput[]
    OR?: TaskCommentScalarWhereWithAggregatesInput[]
    NOT?: TaskCommentScalarWhereWithAggregatesInput | TaskCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskComment"> | string
    content?: StringWithAggregatesFilter<"TaskComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskComment"> | Date | string
    taskId?: StringWithAggregatesFilter<"TaskComment"> | string
    userId?: StringWithAggregatesFilter<"TaskComment"> | string
  }

  export type TaskAttachmentWhereInput = {
    AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    OR?: TaskAttachmentWhereInput[]
    NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    id?: StringFilter<"TaskAttachment"> | string
    fileName?: StringFilter<"TaskAttachment"> | string
    originalName?: StringFilter<"TaskAttachment"> | string
    s3Key?: StringFilter<"TaskAttachment"> | string
    s3Bucket?: StringFilter<"TaskAttachment"> | string
    fileSize?: IntFilter<"TaskAttachment"> | number
    mimeType?: StringFilter<"TaskAttachment"> | string
    uploadedAt?: DateTimeFilter<"TaskAttachment"> | Date | string
    isPublic?: BoolFilter<"TaskAttachment"> | boolean
    etag?: StringNullableFilter<"TaskAttachment"> | string | null
    checksum?: StringNullableFilter<"TaskAttachment"> | string | null
    taskId?: StringFilter<"TaskAttachment"> | string
    uploadedById?: StringFilter<"TaskAttachment"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TaskAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    isPublic?: SortOrder
    etag?: SortOrderInput | SortOrder
    checksum?: SortOrderInput | SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
    task?: TaskOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type TaskAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    s3Bucket_s3Key?: TaskAttachmentS3BucketS3KeyCompoundUniqueInput
    AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    OR?: TaskAttachmentWhereInput[]
    NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    fileName?: StringFilter<"TaskAttachment"> | string
    originalName?: StringFilter<"TaskAttachment"> | string
    s3Key?: StringFilter<"TaskAttachment"> | string
    s3Bucket?: StringFilter<"TaskAttachment"> | string
    fileSize?: IntFilter<"TaskAttachment"> | number
    mimeType?: StringFilter<"TaskAttachment"> | string
    uploadedAt?: DateTimeFilter<"TaskAttachment"> | Date | string
    isPublic?: BoolFilter<"TaskAttachment"> | boolean
    etag?: StringNullableFilter<"TaskAttachment"> | string | null
    checksum?: StringNullableFilter<"TaskAttachment"> | string | null
    taskId?: StringFilter<"TaskAttachment"> | string
    uploadedById?: StringFilter<"TaskAttachment"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "s3Bucket_s3Key">

  export type TaskAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    isPublic?: SortOrder
    etag?: SortOrderInput | SortOrder
    checksum?: SortOrderInput | SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
    _count?: TaskAttachmentCountOrderByAggregateInput
    _avg?: TaskAttachmentAvgOrderByAggregateInput
    _max?: TaskAttachmentMaxOrderByAggregateInput
    _min?: TaskAttachmentMinOrderByAggregateInput
    _sum?: TaskAttachmentSumOrderByAggregateInput
  }

  export type TaskAttachmentScalarWhereWithAggregatesInput = {
    AND?: TaskAttachmentScalarWhereWithAggregatesInput | TaskAttachmentScalarWhereWithAggregatesInput[]
    OR?: TaskAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAttachmentScalarWhereWithAggregatesInput | TaskAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskAttachment"> | string
    fileName?: StringWithAggregatesFilter<"TaskAttachment"> | string
    originalName?: StringWithAggregatesFilter<"TaskAttachment"> | string
    s3Key?: StringWithAggregatesFilter<"TaskAttachment"> | string
    s3Bucket?: StringWithAggregatesFilter<"TaskAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"TaskAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"TaskAttachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"TaskAttachment"> | Date | string
    isPublic?: BoolWithAggregatesFilter<"TaskAttachment"> | boolean
    etag?: StringNullableWithAggregatesFilter<"TaskAttachment"> | string | null
    checksum?: StringNullableWithAggregatesFilter<"TaskAttachment"> | string | null
    taskId?: StringWithAggregatesFilter<"TaskAttachment"> | string
    uploadedById?: StringWithAggregatesFilter<"TaskAttachment"> | string
  }

  export type TaskLabelWhereInput = {
    AND?: TaskLabelWhereInput | TaskLabelWhereInput[]
    OR?: TaskLabelWhereInput[]
    NOT?: TaskLabelWhereInput | TaskLabelWhereInput[]
    taskId?: StringFilter<"TaskLabel"> | string
    labelId?: StringFilter<"TaskLabel"> | string
    assignedAt?: DateTimeFilter<"TaskLabel"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    label?: XOR<LabelRelationFilter, LabelWhereInput>
  }

  export type TaskLabelOrderByWithRelationInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    assignedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    label?: LabelOrderByWithRelationInput
  }

  export type TaskLabelWhereUniqueInput = Prisma.AtLeast<{
    taskId_labelId?: TaskLabelTaskIdLabelIdCompoundUniqueInput
    AND?: TaskLabelWhereInput | TaskLabelWhereInput[]
    OR?: TaskLabelWhereInput[]
    NOT?: TaskLabelWhereInput | TaskLabelWhereInput[]
    taskId?: StringFilter<"TaskLabel"> | string
    labelId?: StringFilter<"TaskLabel"> | string
    assignedAt?: DateTimeFilter<"TaskLabel"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    label?: XOR<LabelRelationFilter, LabelWhereInput>
  }, "taskId_labelId">

  export type TaskLabelOrderByWithAggregationInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    assignedAt?: SortOrder
    _count?: TaskLabelCountOrderByAggregateInput
    _max?: TaskLabelMaxOrderByAggregateInput
    _min?: TaskLabelMinOrderByAggregateInput
  }

  export type TaskLabelScalarWhereWithAggregatesInput = {
    AND?: TaskLabelScalarWhereWithAggregatesInput | TaskLabelScalarWhereWithAggregatesInput[]
    OR?: TaskLabelScalarWhereWithAggregatesInput[]
    NOT?: TaskLabelScalarWhereWithAggregatesInput | TaskLabelScalarWhereWithAggregatesInput[]
    taskId?: StringWithAggregatesFilter<"TaskLabel"> | string
    labelId?: StringWithAggregatesFilter<"TaskLabel"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TaskLabel"> | Date | string
  }

  export type LabelWhereInput = {
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    id?: StringFilter<"Label"> | string
    name?: StringFilter<"Label"> | string
    description?: StringNullableFilter<"Label"> | string | null
    colour?: StringFilter<"Label"> | string
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    createdById?: StringFilter<"Label"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    taskLabels?: TaskLabelListRelationFilter
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    colour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    taskLabels?: TaskLabelOrderByRelationAggregateInput
  }

  export type LabelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    name?: StringFilter<"Label"> | string
    description?: StringNullableFilter<"Label"> | string | null
    colour?: StringFilter<"Label"> | string
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    createdById?: StringFilter<"Label"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    taskLabels?: TaskLabelListRelationFilter
  }, "id">

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    colour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: LabelCountOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    OR?: LabelScalarWhereWithAggregatesInput[]
    NOT?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Label"> | string
    name?: StringWithAggregatesFilter<"Label"> | string
    description?: StringNullableWithAggregatesFilter<"Label"> | string | null
    colour?: StringWithAggregatesFilter<"Label"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    createdById?: StringWithAggregatesFilter<"Label"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    injured?: EnumWereYouInjuredFilter<"User"> | $Enums.WereYouInjured
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone2?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    isUnder18?: BoolFilter<"User"> | boolean
    fatherFirstName?: StringNullableFilter<"User"> | string | null
    fatherLastName?: StringNullableFilter<"User"> | string | null
    motherFirstName?: StringNullableFilter<"User"> | string | null
    motherLastName?: StringNullableFilter<"User"> | string | null
    mailingAddress1?: StringNullableFilter<"User"> | string | null
    mailingAddress2?: StringNullableFilter<"User"> | string | null
    mailingCity?: StringNullableFilter<"User"> | string | null
    mailingState?: StringNullableFilter<"User"> | string | null
    mailingZipCode?: StringNullableFilter<"User"> | string | null
    isPOBoxOrDifferentAddress?: BoolNullableFilter<"User"> | boolean | null
    physicalAddress1?: StringNullableFilter<"User"> | string | null
    physicalAddress2?: StringNullableFilter<"User"> | string | null
    physicalCity?: StringNullableFilter<"User"> | string | null
    physicalState?: StringNullableFilter<"User"> | string | null
    physicalZipCode?: StringNullableFilter<"User"> | string | null
    maritalStatus?: StringNullableFilter<"User"> | string | null
    spouseFirstName?: StringNullableFilter<"User"> | string | null
    spouseLastName?: StringNullableFilter<"User"> | string | null
    spousePhone?: StringNullableFilter<"User"> | string | null
    employmentStatus?: StringNullableFilter<"User"> | string | null
    employerName?: StringNullableFilter<"User"> | string | null
    employerTitle?: StringNullableFilter<"User"> | string | null
    employmentType?: StringNullableFilter<"User"> | string | null
    pay?: StringNullableFilter<"User"> | string | null
    schoolName?: StringNullableFilter<"User"> | string | null
    expectedGraduationYear?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    sourceId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    claimlistId?: StringFilter<"User"> | string
    accountSync?: StringNullableFilter<"User"> | string | null
    source?: XOR<SourceNullableRelationFilter, SourceWhereInput> | null
    claims?: ClaimListRelationFilter
    verify?: XOR<VerifyNullableRelationFilter, VerifyWhereInput> | null
    claimlist?: XOR<ClaimListRelationFilter, ClaimListWhereInput>
    projectsOwned?: ProjectListRelationFilter
    tasksCreated?: TaskListRelationFilter
    taskAssignments?: TaskAssigneeListRelationFilter
    projectAssignments?: ProjectUserListRelationFilter
    taskComments?: TaskCommentListRelationFilter
    labelsCreated?: LabelListRelationFilter
    taskAttachments?: TaskAttachmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    injured?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phone2?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    isUnder18?: SortOrder
    fatherFirstName?: SortOrderInput | SortOrder
    fatherLastName?: SortOrderInput | SortOrder
    motherFirstName?: SortOrderInput | SortOrder
    motherLastName?: SortOrderInput | SortOrder
    mailingAddress1?: SortOrderInput | SortOrder
    mailingAddress2?: SortOrderInput | SortOrder
    mailingCity?: SortOrderInput | SortOrder
    mailingState?: SortOrderInput | SortOrder
    mailingZipCode?: SortOrderInput | SortOrder
    isPOBoxOrDifferentAddress?: SortOrderInput | SortOrder
    physicalAddress1?: SortOrderInput | SortOrder
    physicalAddress2?: SortOrderInput | SortOrder
    physicalCity?: SortOrderInput | SortOrder
    physicalState?: SortOrderInput | SortOrder
    physicalZipCode?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    spouseFirstName?: SortOrderInput | SortOrder
    spouseLastName?: SortOrderInput | SortOrder
    spousePhone?: SortOrderInput | SortOrder
    employmentStatus?: SortOrderInput | SortOrder
    employerName?: SortOrderInput | SortOrder
    employerTitle?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    pay?: SortOrderInput | SortOrder
    schoolName?: SortOrderInput | SortOrder
    expectedGraduationYear?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claimlistId?: SortOrder
    accountSync?: SortOrderInput | SortOrder
    source?: SourceOrderByWithRelationInput
    claims?: ClaimOrderByRelationAggregateInput
    verify?: VerifyOrderByWithRelationInput
    claimlist?: ClaimListOrderByWithRelationInput
    projectsOwned?: ProjectOrderByRelationAggregateInput
    tasksCreated?: TaskOrderByRelationAggregateInput
    taskAssignments?: TaskAssigneeOrderByRelationAggregateInput
    projectAssignments?: ProjectUserOrderByRelationAggregateInput
    taskComments?: TaskCommentOrderByRelationAggregateInput
    labelsCreated?: LabelOrderByRelationAggregateInput
    taskAttachments?: TaskAttachmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    injured?: EnumWereYouInjuredFilter<"User"> | $Enums.WereYouInjured
    password?: StringFilter<"User"> | string
    phone2?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    isUnder18?: BoolFilter<"User"> | boolean
    fatherFirstName?: StringNullableFilter<"User"> | string | null
    fatherLastName?: StringNullableFilter<"User"> | string | null
    motherFirstName?: StringNullableFilter<"User"> | string | null
    motherLastName?: StringNullableFilter<"User"> | string | null
    mailingAddress1?: StringNullableFilter<"User"> | string | null
    mailingAddress2?: StringNullableFilter<"User"> | string | null
    mailingCity?: StringNullableFilter<"User"> | string | null
    mailingState?: StringNullableFilter<"User"> | string | null
    mailingZipCode?: StringNullableFilter<"User"> | string | null
    isPOBoxOrDifferentAddress?: BoolNullableFilter<"User"> | boolean | null
    physicalAddress1?: StringNullableFilter<"User"> | string | null
    physicalAddress2?: StringNullableFilter<"User"> | string | null
    physicalCity?: StringNullableFilter<"User"> | string | null
    physicalState?: StringNullableFilter<"User"> | string | null
    physicalZipCode?: StringNullableFilter<"User"> | string | null
    maritalStatus?: StringNullableFilter<"User"> | string | null
    spouseFirstName?: StringNullableFilter<"User"> | string | null
    spouseLastName?: StringNullableFilter<"User"> | string | null
    spousePhone?: StringNullableFilter<"User"> | string | null
    employmentStatus?: StringNullableFilter<"User"> | string | null
    employerName?: StringNullableFilter<"User"> | string | null
    employerTitle?: StringNullableFilter<"User"> | string | null
    employmentType?: StringNullableFilter<"User"> | string | null
    pay?: StringNullableFilter<"User"> | string | null
    schoolName?: StringNullableFilter<"User"> | string | null
    expectedGraduationYear?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    sourceId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    claimlistId?: StringFilter<"User"> | string
    accountSync?: StringNullableFilter<"User"> | string | null
    source?: XOR<SourceNullableRelationFilter, SourceWhereInput> | null
    claims?: ClaimListRelationFilter
    verify?: XOR<VerifyNullableRelationFilter, VerifyWhereInput> | null
    claimlist?: XOR<ClaimListRelationFilter, ClaimListWhereInput>
    projectsOwned?: ProjectListRelationFilter
    tasksCreated?: TaskListRelationFilter
    taskAssignments?: TaskAssigneeListRelationFilter
    projectAssignments?: ProjectUserListRelationFilter
    taskComments?: TaskCommentListRelationFilter
    labelsCreated?: LabelListRelationFilter
    taskAttachments?: TaskAttachmentListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    injured?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phone2?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    isUnder18?: SortOrder
    fatherFirstName?: SortOrderInput | SortOrder
    fatherLastName?: SortOrderInput | SortOrder
    motherFirstName?: SortOrderInput | SortOrder
    motherLastName?: SortOrderInput | SortOrder
    mailingAddress1?: SortOrderInput | SortOrder
    mailingAddress2?: SortOrderInput | SortOrder
    mailingCity?: SortOrderInput | SortOrder
    mailingState?: SortOrderInput | SortOrder
    mailingZipCode?: SortOrderInput | SortOrder
    isPOBoxOrDifferentAddress?: SortOrderInput | SortOrder
    physicalAddress1?: SortOrderInput | SortOrder
    physicalAddress2?: SortOrderInput | SortOrder
    physicalCity?: SortOrderInput | SortOrder
    physicalState?: SortOrderInput | SortOrder
    physicalZipCode?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    spouseFirstName?: SortOrderInput | SortOrder
    spouseLastName?: SortOrderInput | SortOrder
    spousePhone?: SortOrderInput | SortOrder
    employmentStatus?: SortOrderInput | SortOrder
    employerName?: SortOrderInput | SortOrder
    employerTitle?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    pay?: SortOrderInput | SortOrder
    schoolName?: SortOrderInput | SortOrder
    expectedGraduationYear?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claimlistId?: SortOrder
    accountSync?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    middleName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringWithAggregatesFilter<"User"> | string
    injured?: EnumWereYouInjuredWithAggregatesFilter<"User"> | $Enums.WereYouInjured
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone2?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isUnder18?: BoolWithAggregatesFilter<"User"> | boolean
    fatherFirstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    fatherLastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    motherFirstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    motherLastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    mailingAddress1?: StringNullableWithAggregatesFilter<"User"> | string | null
    mailingAddress2?: StringNullableWithAggregatesFilter<"User"> | string | null
    mailingCity?: StringNullableWithAggregatesFilter<"User"> | string | null
    mailingState?: StringNullableWithAggregatesFilter<"User"> | string | null
    mailingZipCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    isPOBoxOrDifferentAddress?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    physicalAddress1?: StringNullableWithAggregatesFilter<"User"> | string | null
    physicalAddress2?: StringNullableWithAggregatesFilter<"User"> | string | null
    physicalCity?: StringNullableWithAggregatesFilter<"User"> | string | null
    physicalState?: StringNullableWithAggregatesFilter<"User"> | string | null
    physicalZipCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    maritalStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    spouseFirstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    spouseLastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    spousePhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    employmentStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    employerName?: StringNullableWithAggregatesFilter<"User"> | string | null
    employerTitle?: StringNullableWithAggregatesFilter<"User"> | string | null
    employmentType?: StringNullableWithAggregatesFilter<"User"> | string | null
    pay?: StringNullableWithAggregatesFilter<"User"> | string | null
    schoolName?: StringNullableWithAggregatesFilter<"User"> | string | null
    expectedGraduationYear?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    sourceId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    claimlistId?: StringWithAggregatesFilter<"User"> | string
    accountSync?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type VerifyWhereInput = {
    AND?: VerifyWhereInput | VerifyWhereInput[]
    OR?: VerifyWhereInput[]
    NOT?: VerifyWhereInput | VerifyWhereInput[]
    id?: StringFilter<"Verify"> | string
    token?: StringFilter<"Verify"> | string
    url?: StringFilter<"Verify"> | string
    status?: StringFilter<"Verify"> | string
    sessionId?: StringNullableFilter<"Verify"> | string | null
    errorCode?: StringNullableFilter<"Verify"> | string | null
    errorMessage?: StringNullableFilter<"Verify"> | string | null
    updatedAt?: DateTimeFilter<"Verify"> | Date | string
    createdAt?: DateTimeFilter<"Verify"> | Date | string
    userId?: StringFilter<"Verify"> | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VerifyOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    url?: SortOrder
    status?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type VerifyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: VerifyWhereInput | VerifyWhereInput[]
    OR?: VerifyWhereInput[]
    NOT?: VerifyWhereInput | VerifyWhereInput[]
    token?: StringFilter<"Verify"> | string
    url?: StringFilter<"Verify"> | string
    status?: StringFilter<"Verify"> | string
    sessionId?: StringNullableFilter<"Verify"> | string | null
    errorCode?: StringNullableFilter<"Verify"> | string | null
    errorMessage?: StringNullableFilter<"Verify"> | string | null
    updatedAt?: DateTimeFilter<"Verify"> | Date | string
    createdAt?: DateTimeFilter<"Verify"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type VerifyOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    url?: SortOrder
    status?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: VerifyCountOrderByAggregateInput
    _max?: VerifyMaxOrderByAggregateInput
    _min?: VerifyMinOrderByAggregateInput
  }

  export type VerifyScalarWhereWithAggregatesInput = {
    AND?: VerifyScalarWhereWithAggregatesInput | VerifyScalarWhereWithAggregatesInput[]
    OR?: VerifyScalarWhereWithAggregatesInput[]
    NOT?: VerifyScalarWhereWithAggregatesInput | VerifyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verify"> | string
    token?: StringWithAggregatesFilter<"Verify"> | string
    url?: StringWithAggregatesFilter<"Verify"> | string
    status?: StringWithAggregatesFilter<"Verify"> | string
    sessionId?: StringNullableWithAggregatesFilter<"Verify"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"Verify"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Verify"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Verify"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verify"> | Date | string
    userId?: StringWithAggregatesFilter<"Verify"> | string
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: StringFilter<"Claim"> | string
    status?: EnumClaimStatusNullableFilter<"Claim"> | $Enums.ClaimStatus | null
    injured?: BoolNullableFilter<"Claim"> | boolean | null
    relationship?: EnumRelationshipNullableFilter<"Claim"> | $Enums.Relationship | null
    otherRelationship?: StringNullableFilter<"Claim"> | string | null
    healthInsurance?: BoolNullableFilter<"Claim"> | boolean | null
    healthInsuranceNumber?: StringNullableFilter<"Claim"> | string | null
    isOver65?: BoolNullableFilter<"Claim"> | boolean | null
    receiveMedicare?: StringNullableListFilter<"Claim">
    assignedCaseManager?: StringNullableFilter<"Claim"> | string | null
    userId?: StringFilter<"Claim"> | string
    clientRoleId?: StringNullableFilter<"Claim"> | string | null
    injuredPartyRoleId?: StringNullableFilter<"Claim"> | string | null
    incidentId?: StringNullableFilter<"Claim"> | string | null
    healthInsuranceProviderId?: StringNullableFilter<"Claim"> | string | null
    claimlistId?: StringFilter<"Claim"> | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clientRole?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    injuredPartyRole?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    incident?: XOR<IncidentNullableRelationFilter, IncidentWhereInput> | null
    healthInsuranceProvider?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    witness?: XOR<WitnessNullableRelationFilter, WitnessWhereInput> | null
    defendant?: XOR<DefendantNullableRelationFilter, DefendantWhereInput> | null
    treatmentsAndInjuries?: XOR<TreatmentAndInjuryNullableRelationFilter, TreatmentAndInjuryWhereInput> | null
    questionnaire?: XOR<QuestionnaireNullableRelationFilter, QuestionnaireWhereInput> | null
    claimlist?: XOR<ClaimListRelationFilter, ClaimListWhereInput>
    envelop?: EnvelopListRelationFilter
    media?: AccidentMediaListRelationFilter
    tasks?: TaskListRelationFilter
    projectClaims?: ProjectClaimListRelationFilter
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    injured?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    otherRelationship?: SortOrderInput | SortOrder
    healthInsurance?: SortOrderInput | SortOrder
    healthInsuranceNumber?: SortOrderInput | SortOrder
    isOver65?: SortOrderInput | SortOrder
    receiveMedicare?: SortOrder
    assignedCaseManager?: SortOrderInput | SortOrder
    userId?: SortOrder
    clientRoleId?: SortOrderInput | SortOrder
    injuredPartyRoleId?: SortOrderInput | SortOrder
    incidentId?: SortOrderInput | SortOrder
    healthInsuranceProviderId?: SortOrderInput | SortOrder
    claimlistId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    clientRole?: RoleOrderByWithRelationInput
    injuredPartyRole?: RoleOrderByWithRelationInput
    incident?: IncidentOrderByWithRelationInput
    healthInsuranceProvider?: RoleOrderByWithRelationInput
    witness?: WitnessOrderByWithRelationInput
    defendant?: DefendantOrderByWithRelationInput
    treatmentsAndInjuries?: TreatmentAndInjuryOrderByWithRelationInput
    questionnaire?: QuestionnaireOrderByWithRelationInput
    claimlist?: ClaimListOrderByWithRelationInput
    envelop?: EnvelopOrderByRelationAggregateInput
    media?: AccidentMediaOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    projectClaims?: ProjectClaimOrderByRelationAggregateInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    incidentId?: string
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    status?: EnumClaimStatusNullableFilter<"Claim"> | $Enums.ClaimStatus | null
    injured?: BoolNullableFilter<"Claim"> | boolean | null
    relationship?: EnumRelationshipNullableFilter<"Claim"> | $Enums.Relationship | null
    otherRelationship?: StringNullableFilter<"Claim"> | string | null
    healthInsurance?: BoolNullableFilter<"Claim"> | boolean | null
    healthInsuranceNumber?: StringNullableFilter<"Claim"> | string | null
    isOver65?: BoolNullableFilter<"Claim"> | boolean | null
    receiveMedicare?: StringNullableListFilter<"Claim">
    assignedCaseManager?: StringNullableFilter<"Claim"> | string | null
    userId?: StringFilter<"Claim"> | string
    clientRoleId?: StringNullableFilter<"Claim"> | string | null
    injuredPartyRoleId?: StringNullableFilter<"Claim"> | string | null
    healthInsuranceProviderId?: StringNullableFilter<"Claim"> | string | null
    claimlistId?: StringFilter<"Claim"> | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clientRole?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    injuredPartyRole?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    incident?: XOR<IncidentNullableRelationFilter, IncidentWhereInput> | null
    healthInsuranceProvider?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    witness?: XOR<WitnessNullableRelationFilter, WitnessWhereInput> | null
    defendant?: XOR<DefendantNullableRelationFilter, DefendantWhereInput> | null
    treatmentsAndInjuries?: XOR<TreatmentAndInjuryNullableRelationFilter, TreatmentAndInjuryWhereInput> | null
    questionnaire?: XOR<QuestionnaireNullableRelationFilter, QuestionnaireWhereInput> | null
    claimlist?: XOR<ClaimListRelationFilter, ClaimListWhereInput>
    envelop?: EnvelopListRelationFilter
    media?: AccidentMediaListRelationFilter
    tasks?: TaskListRelationFilter
    projectClaims?: ProjectClaimListRelationFilter
  }, "id" | "incidentId">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    injured?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    otherRelationship?: SortOrderInput | SortOrder
    healthInsurance?: SortOrderInput | SortOrder
    healthInsuranceNumber?: SortOrderInput | SortOrder
    isOver65?: SortOrderInput | SortOrder
    receiveMedicare?: SortOrder
    assignedCaseManager?: SortOrderInput | SortOrder
    userId?: SortOrder
    clientRoleId?: SortOrderInput | SortOrder
    injuredPartyRoleId?: SortOrderInput | SortOrder
    incidentId?: SortOrderInput | SortOrder
    healthInsuranceProviderId?: SortOrderInput | SortOrder
    claimlistId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Claim"> | string
    status?: EnumClaimStatusNullableWithAggregatesFilter<"Claim"> | $Enums.ClaimStatus | null
    injured?: BoolNullableWithAggregatesFilter<"Claim"> | boolean | null
    relationship?: EnumRelationshipNullableWithAggregatesFilter<"Claim"> | $Enums.Relationship | null
    otherRelationship?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    healthInsurance?: BoolNullableWithAggregatesFilter<"Claim"> | boolean | null
    healthInsuranceNumber?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    isOver65?: BoolNullableWithAggregatesFilter<"Claim"> | boolean | null
    receiveMedicare?: StringNullableListFilter<"Claim">
    assignedCaseManager?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    userId?: StringWithAggregatesFilter<"Claim"> | string
    clientRoleId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    injuredPartyRoleId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    incidentId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    healthInsuranceProviderId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    claimlistId?: StringWithAggregatesFilter<"Claim"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
  }

  export type ProjectClaimWhereInput = {
    AND?: ProjectClaimWhereInput | ProjectClaimWhereInput[]
    OR?: ProjectClaimWhereInput[]
    NOT?: ProjectClaimWhereInput | ProjectClaimWhereInput[]
    projectId?: StringFilter<"ProjectClaim"> | string
    claimId?: StringFilter<"ProjectClaim"> | string
    assignedAt?: DateTimeFilter<"ProjectClaim"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
  }

  export type ProjectClaimOrderByWithRelationInput = {
    projectId?: SortOrder
    claimId?: SortOrder
    assignedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    claim?: ClaimOrderByWithRelationInput
  }

  export type ProjectClaimWhereUniqueInput = Prisma.AtLeast<{
    projectId_claimId?: ProjectClaimProjectIdClaimIdCompoundUniqueInput
    AND?: ProjectClaimWhereInput | ProjectClaimWhereInput[]
    OR?: ProjectClaimWhereInput[]
    NOT?: ProjectClaimWhereInput | ProjectClaimWhereInput[]
    projectId?: StringFilter<"ProjectClaim"> | string
    claimId?: StringFilter<"ProjectClaim"> | string
    assignedAt?: DateTimeFilter<"ProjectClaim"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
  }, "projectId_claimId">

  export type ProjectClaimOrderByWithAggregationInput = {
    projectId?: SortOrder
    claimId?: SortOrder
    assignedAt?: SortOrder
    _count?: ProjectClaimCountOrderByAggregateInput
    _max?: ProjectClaimMaxOrderByAggregateInput
    _min?: ProjectClaimMinOrderByAggregateInput
  }

  export type ProjectClaimScalarWhereWithAggregatesInput = {
    AND?: ProjectClaimScalarWhereWithAggregatesInput | ProjectClaimScalarWhereWithAggregatesInput[]
    OR?: ProjectClaimScalarWhereWithAggregatesInput[]
    NOT?: ProjectClaimScalarWhereWithAggregatesInput | ProjectClaimScalarWhereWithAggregatesInput[]
    projectId?: StringWithAggregatesFilter<"ProjectClaim"> | string
    claimId?: StringWithAggregatesFilter<"ProjectClaim"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"ProjectClaim"> | Date | string
  }

  export type EnvelopWhereInput = {
    AND?: EnvelopWhereInput | EnvelopWhereInput[]
    OR?: EnvelopWhereInput[]
    NOT?: EnvelopWhereInput | EnvelopWhereInput[]
    id?: StringFilter<"Envelop"> | string
    status?: BoolFilter<"Envelop"> | boolean
    claimId?: StringFilter<"Envelop"> | string
    submitterUrl?: StringNullableFilter<"Envelop"> | string | null
    submitterId?: IntNullableFilter<"Envelop"> | number | null
    submittedUrl?: StringNullableFilter<"Envelop"> | string | null
    createdAt?: DateTimeFilter<"Envelop"> | Date | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
  }

  export type EnvelopOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    claimId?: SortOrder
    submitterUrl?: SortOrderInput | SortOrder
    submitterId?: SortOrderInput | SortOrder
    submittedUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    claim?: ClaimOrderByWithRelationInput
  }

  export type EnvelopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnvelopWhereInput | EnvelopWhereInput[]
    OR?: EnvelopWhereInput[]
    NOT?: EnvelopWhereInput | EnvelopWhereInput[]
    status?: BoolFilter<"Envelop"> | boolean
    claimId?: StringFilter<"Envelop"> | string
    submitterUrl?: StringNullableFilter<"Envelop"> | string | null
    submitterId?: IntNullableFilter<"Envelop"> | number | null
    submittedUrl?: StringNullableFilter<"Envelop"> | string | null
    createdAt?: DateTimeFilter<"Envelop"> | Date | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
  }, "id">

  export type EnvelopOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    claimId?: SortOrder
    submitterUrl?: SortOrderInput | SortOrder
    submitterId?: SortOrderInput | SortOrder
    submittedUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EnvelopCountOrderByAggregateInput
    _avg?: EnvelopAvgOrderByAggregateInput
    _max?: EnvelopMaxOrderByAggregateInput
    _min?: EnvelopMinOrderByAggregateInput
    _sum?: EnvelopSumOrderByAggregateInput
  }

  export type EnvelopScalarWhereWithAggregatesInput = {
    AND?: EnvelopScalarWhereWithAggregatesInput | EnvelopScalarWhereWithAggregatesInput[]
    OR?: EnvelopScalarWhereWithAggregatesInput[]
    NOT?: EnvelopScalarWhereWithAggregatesInput | EnvelopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Envelop"> | string
    status?: BoolWithAggregatesFilter<"Envelop"> | boolean
    claimId?: StringWithAggregatesFilter<"Envelop"> | string
    submitterUrl?: StringNullableWithAggregatesFilter<"Envelop"> | string | null
    submitterId?: IntNullableWithAggregatesFilter<"Envelop"> | number | null
    submittedUrl?: StringNullableWithAggregatesFilter<"Envelop"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Envelop"> | Date | string
  }

  export type ClaimListWhereInput = {
    AND?: ClaimListWhereInput | ClaimListWhereInput[]
    OR?: ClaimListWhereInput[]
    NOT?: ClaimListWhereInput | ClaimListWhereInput[]
    id?: StringFilter<"ClaimList"> | string
    name?: StringFilter<"ClaimList"> | string
    enable?: BoolNullableFilter<"ClaimList"> | boolean | null
    questionId?: StringNullableFilter<"ClaimList"> | string | null
    createdAt?: DateTimeFilter<"ClaimList"> | Date | string
    createdBy?: StringNullableFilter<"ClaimList"> | string | null
    claim?: ClaimListRelationFilter
    user?: UserListRelationFilter
    question?: QuestionListRelationFilter
  }

  export type ClaimListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    enable?: SortOrderInput | SortOrder
    questionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    claim?: ClaimOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
    question?: QuestionOrderByRelationAggregateInput
  }

  export type ClaimListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClaimListWhereInput | ClaimListWhereInput[]
    OR?: ClaimListWhereInput[]
    NOT?: ClaimListWhereInput | ClaimListWhereInput[]
    name?: StringFilter<"ClaimList"> | string
    enable?: BoolNullableFilter<"ClaimList"> | boolean | null
    questionId?: StringNullableFilter<"ClaimList"> | string | null
    createdAt?: DateTimeFilter<"ClaimList"> | Date | string
    createdBy?: StringNullableFilter<"ClaimList"> | string | null
    claim?: ClaimListRelationFilter
    user?: UserListRelationFilter
    question?: QuestionListRelationFilter
  }, "id">

  export type ClaimListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    enable?: SortOrderInput | SortOrder
    questionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: ClaimListCountOrderByAggregateInput
    _max?: ClaimListMaxOrderByAggregateInput
    _min?: ClaimListMinOrderByAggregateInput
  }

  export type ClaimListScalarWhereWithAggregatesInput = {
    AND?: ClaimListScalarWhereWithAggregatesInput | ClaimListScalarWhereWithAggregatesInput[]
    OR?: ClaimListScalarWhereWithAggregatesInput[]
    NOT?: ClaimListScalarWhereWithAggregatesInput | ClaimListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClaimList"> | string
    name?: StringWithAggregatesFilter<"ClaimList"> | string
    enable?: BoolNullableWithAggregatesFilter<"ClaimList"> | boolean | null
    questionId?: StringNullableWithAggregatesFilter<"ClaimList"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClaimList"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ClaimList"> | string | null
  }

  export type SourceWhereInput = {
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    id?: StringFilter<"Source"> | string
    name?: StringFilter<"Source"> | string
    createdAt?: DateTimeFilter<"Source"> | Date | string
    createdBy?: StringNullableFilter<"Source"> | string | null
    enable?: BoolNullableFilter<"Source"> | boolean | null
    user?: UserListRelationFilter
  }

  export type SourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type SourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    name?: StringFilter<"Source"> | string
    createdAt?: DateTimeFilter<"Source"> | Date | string
    createdBy?: StringNullableFilter<"Source"> | string | null
    enable?: BoolNullableFilter<"Source"> | boolean | null
    user?: UserListRelationFilter
  }, "id">

  export type SourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    _count?: SourceCountOrderByAggregateInput
    _max?: SourceMaxOrderByAggregateInput
    _min?: SourceMinOrderByAggregateInput
  }

  export type SourceScalarWhereWithAggregatesInput = {
    AND?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    OR?: SourceScalarWhereWithAggregatesInput[]
    NOT?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Source"> | string
    name?: StringWithAggregatesFilter<"Source"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Source"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Source"> | string | null
    enable?: BoolNullableWithAggregatesFilter<"Source"> | boolean | null
  }

  export type QuestionnaireWhereInput = {
    AND?: QuestionnaireWhereInput | QuestionnaireWhereInput[]
    OR?: QuestionnaireWhereInput[]
    NOT?: QuestionnaireWhereInput | QuestionnaireWhereInput[]
    id?: StringFilter<"Questionnaire"> | string
    claimId?: StringFilter<"Questionnaire"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    question?: QuestionAnswerListRelationFilter
  }

  export type QuestionnaireOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    claim?: ClaimOrderByWithRelationInput
    question?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type QuestionnaireWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimId?: string
    AND?: QuestionnaireWhereInput | QuestionnaireWhereInput[]
    OR?: QuestionnaireWhereInput[]
    NOT?: QuestionnaireWhereInput | QuestionnaireWhereInput[]
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    question?: QuestionAnswerListRelationFilter
  }, "id" | "claimId">

  export type QuestionnaireOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    _count?: QuestionnaireCountOrderByAggregateInput
    _max?: QuestionnaireMaxOrderByAggregateInput
    _min?: QuestionnaireMinOrderByAggregateInput
  }

  export type QuestionnaireScalarWhereWithAggregatesInput = {
    AND?: QuestionnaireScalarWhereWithAggregatesInput | QuestionnaireScalarWhereWithAggregatesInput[]
    OR?: QuestionnaireScalarWhereWithAggregatesInput[]
    NOT?: QuestionnaireScalarWhereWithAggregatesInput | QuestionnaireScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Questionnaire"> | string
    claimId?: StringWithAggregatesFilter<"Questionnaire"> | string
  }

  export type QuestionAnswerWhereInput = {
    AND?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    OR?: QuestionAnswerWhereInput[]
    NOT?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    id?: StringFilter<"QuestionAnswer"> | string
    questionnaireId?: StringNullableFilter<"QuestionAnswer"> | string | null
    questionId?: StringFilter<"QuestionAnswer"> | string
    answer?: StringFilter<"QuestionAnswer"> | string
    createdAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    Questionnaire?: XOR<QuestionnaireNullableRelationFilter, QuestionnaireWhereInput> | null
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }

  export type QuestionAnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionnaireId?: SortOrderInput | SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Questionnaire?: QuestionnaireOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
  }

  export type QuestionAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    OR?: QuestionAnswerWhereInput[]
    NOT?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    questionnaireId?: StringNullableFilter<"QuestionAnswer"> | string | null
    questionId?: StringFilter<"QuestionAnswer"> | string
    answer?: StringFilter<"QuestionAnswer"> | string
    createdAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    Questionnaire?: XOR<QuestionnaireNullableRelationFilter, QuestionnaireWhereInput> | null
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }, "id">

  export type QuestionAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionnaireId?: SortOrderInput | SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionAnswerCountOrderByAggregateInput
    _max?: QuestionAnswerMaxOrderByAggregateInput
    _min?: QuestionAnswerMinOrderByAggregateInput
  }

  export type QuestionAnswerScalarWhereWithAggregatesInput = {
    AND?: QuestionAnswerScalarWhereWithAggregatesInput | QuestionAnswerScalarWhereWithAggregatesInput[]
    OR?: QuestionAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuestionAnswerScalarWhereWithAggregatesInput | QuestionAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionAnswer"> | string
    questionnaireId?: StringNullableWithAggregatesFilter<"QuestionAnswer"> | string | null
    questionId?: StringWithAggregatesFilter<"QuestionAnswer"> | string
    answer?: StringWithAggregatesFilter<"QuestionAnswer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionAnswer"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    question?: StringFilter<"Question"> | string
    claimListId?: StringNullableFilter<"Question"> | string | null
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    enable?: BoolFilter<"Question"> | boolean
    claimList?: XOR<ClaimListNullableRelationFilter, ClaimListWhereInput> | null
    choices?: ChoiceListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    claimListId?: SortOrderInput | SortOrder
    type?: SortOrder
    enable?: SortOrder
    claimList?: ClaimListOrderByWithRelationInput
    choices?: ChoiceOrderByRelationAggregateInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    question?: StringFilter<"Question"> | string
    claimListId?: StringNullableFilter<"Question"> | string | null
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    enable?: BoolFilter<"Question"> | boolean
    claimList?: XOR<ClaimListNullableRelationFilter, ClaimListWhereInput> | null
    choices?: ChoiceListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    claimListId?: SortOrderInput | SortOrder
    type?: SortOrder
    enable?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    question?: StringWithAggregatesFilter<"Question"> | string
    claimListId?: StringNullableWithAggregatesFilter<"Question"> | string | null
    type?: EnumQuestionTypeWithAggregatesFilter<"Question"> | $Enums.QuestionType
    enable?: BoolWithAggregatesFilter<"Question"> | boolean
  }

  export type ChoiceWhereInput = {
    AND?: ChoiceWhereInput | ChoiceWhereInput[]
    OR?: ChoiceWhereInput[]
    NOT?: ChoiceWhereInput | ChoiceWhereInput[]
    id?: StringFilter<"Choice"> | string
    text?: StringFilter<"Choice"> | string
    questionId?: StringFilter<"Choice"> | string
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }

  export type ChoiceOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    questionId?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type ChoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChoiceWhereInput | ChoiceWhereInput[]
    OR?: ChoiceWhereInput[]
    NOT?: ChoiceWhereInput | ChoiceWhereInput[]
    text?: StringFilter<"Choice"> | string
    questionId?: StringFilter<"Choice"> | string
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }, "id">

  export type ChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    questionId?: SortOrder
    _count?: ChoiceCountOrderByAggregateInput
    _max?: ChoiceMaxOrderByAggregateInput
    _min?: ChoiceMinOrderByAggregateInput
  }

  export type ChoiceScalarWhereWithAggregatesInput = {
    AND?: ChoiceScalarWhereWithAggregatesInput | ChoiceScalarWhereWithAggregatesInput[]
    OR?: ChoiceScalarWhereWithAggregatesInput[]
    NOT?: ChoiceScalarWhereWithAggregatesInput | ChoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Choice"> | string
    text?: StringWithAggregatesFilter<"Choice"> | string
    questionId?: StringWithAggregatesFilter<"Choice"> | string
  }

  export type DefendantWhereInput = {
    AND?: DefendantWhereInput | DefendantWhereInput[]
    OR?: DefendantWhereInput[]
    NOT?: DefendantWhereInput | DefendantWhereInput[]
    id?: StringFilter<"Defendant"> | string
    claimId?: StringFilter<"Defendant"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    defendantDetails?: DefendantDetailsListRelationFilter
  }

  export type DefendantOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    claim?: ClaimOrderByWithRelationInput
    defendantDetails?: DefendantDetailsOrderByRelationAggregateInput
  }

  export type DefendantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimId?: string
    AND?: DefendantWhereInput | DefendantWhereInput[]
    OR?: DefendantWhereInput[]
    NOT?: DefendantWhereInput | DefendantWhereInput[]
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    defendantDetails?: DefendantDetailsListRelationFilter
  }, "id" | "claimId">

  export type DefendantOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    _count?: DefendantCountOrderByAggregateInput
    _max?: DefendantMaxOrderByAggregateInput
    _min?: DefendantMinOrderByAggregateInput
  }

  export type DefendantScalarWhereWithAggregatesInput = {
    AND?: DefendantScalarWhereWithAggregatesInput | DefendantScalarWhereWithAggregatesInput[]
    OR?: DefendantScalarWhereWithAggregatesInput[]
    NOT?: DefendantScalarWhereWithAggregatesInput | DefendantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Defendant"> | string
    claimId?: StringWithAggregatesFilter<"Defendant"> | string
  }

  export type DefendantDetailsWhereInput = {
    AND?: DefendantDetailsWhereInput | DefendantDetailsWhereInput[]
    OR?: DefendantDetailsWhereInput[]
    NOT?: DefendantDetailsWhereInput | DefendantDetailsWhereInput[]
    id?: StringFilter<"DefendantDetails"> | string
    defendantRole?: EnumDefendantRoleFilter<"DefendantDetails"> | $Enums.DefendantRole
    defendantAccountId?: StringFilter<"DefendantDetails"> | string
    defendantInsuranceCarrierId?: StringNullableFilter<"DefendantDetails"> | string | null
    insurancePolicyNumber?: StringNullableFilter<"DefendantDetails"> | string | null
    driverLicenseNumber?: StringNullableFilter<"DefendantDetails"> | string | null
    driverLicenseState?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleMake?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleModel?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleYear?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleColor?: StringNullableFilter<"DefendantDetails"> | string | null
    vehiclePlate?: StringNullableFilter<"DefendantDetails"> | string | null
    vehiclePosition?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleRegisteredState?: StringNullableFilter<"DefendantDetails"> | string | null
    collisionType?: EnumCollisionTypeNullableFilter<"DefendantDetails"> | $Enums.CollisionType | null
    supervisorName?: StringNullableFilter<"DefendantDetails"> | string | null
    supervisorContact?: StringNullableFilter<"DefendantDetails"> | string | null
    client?: BoolFilter<"DefendantDetails"> | boolean
    groupId?: StringNullableFilter<"DefendantDetails"> | string | null
    sort?: IntFilter<"DefendantDetails"> | number
    defendantId?: StringFilter<"DefendantDetails"> | string
    defendantAccount?: XOR<RoleRelationFilter, RoleWhereInput>
    defendantInsuranceCarrier?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    defendant?: XOR<DefendantRelationFilter, DefendantWhereInput>
  }

  export type DefendantDetailsOrderByWithRelationInput = {
    id?: SortOrder
    defendantRole?: SortOrder
    defendantAccountId?: SortOrder
    defendantInsuranceCarrierId?: SortOrderInput | SortOrder
    insurancePolicyNumber?: SortOrderInput | SortOrder
    driverLicenseNumber?: SortOrderInput | SortOrder
    driverLicenseState?: SortOrderInput | SortOrder
    vehicleMake?: SortOrderInput | SortOrder
    vehicleModel?: SortOrderInput | SortOrder
    vehicleYear?: SortOrderInput | SortOrder
    vehicleColor?: SortOrderInput | SortOrder
    vehiclePlate?: SortOrderInput | SortOrder
    vehiclePosition?: SortOrderInput | SortOrder
    vehicleRegisteredState?: SortOrderInput | SortOrder
    collisionType?: SortOrderInput | SortOrder
    supervisorName?: SortOrderInput | SortOrder
    supervisorContact?: SortOrderInput | SortOrder
    client?: SortOrder
    groupId?: SortOrderInput | SortOrder
    sort?: SortOrder
    defendantId?: SortOrder
    defendantAccount?: RoleOrderByWithRelationInput
    defendantInsuranceCarrier?: RoleOrderByWithRelationInput
    defendant?: DefendantOrderByWithRelationInput
  }

  export type DefendantDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DefendantDetailsWhereInput | DefendantDetailsWhereInput[]
    OR?: DefendantDetailsWhereInput[]
    NOT?: DefendantDetailsWhereInput | DefendantDetailsWhereInput[]
    defendantRole?: EnumDefendantRoleFilter<"DefendantDetails"> | $Enums.DefendantRole
    defendantAccountId?: StringFilter<"DefendantDetails"> | string
    defendantInsuranceCarrierId?: StringNullableFilter<"DefendantDetails"> | string | null
    insurancePolicyNumber?: StringNullableFilter<"DefendantDetails"> | string | null
    driverLicenseNumber?: StringNullableFilter<"DefendantDetails"> | string | null
    driverLicenseState?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleMake?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleModel?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleYear?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleColor?: StringNullableFilter<"DefendantDetails"> | string | null
    vehiclePlate?: StringNullableFilter<"DefendantDetails"> | string | null
    vehiclePosition?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleRegisteredState?: StringNullableFilter<"DefendantDetails"> | string | null
    collisionType?: EnumCollisionTypeNullableFilter<"DefendantDetails"> | $Enums.CollisionType | null
    supervisorName?: StringNullableFilter<"DefendantDetails"> | string | null
    supervisorContact?: StringNullableFilter<"DefendantDetails"> | string | null
    client?: BoolFilter<"DefendantDetails"> | boolean
    groupId?: StringNullableFilter<"DefendantDetails"> | string | null
    sort?: IntFilter<"DefendantDetails"> | number
    defendantId?: StringFilter<"DefendantDetails"> | string
    defendantAccount?: XOR<RoleRelationFilter, RoleWhereInput>
    defendantInsuranceCarrier?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    defendant?: XOR<DefendantRelationFilter, DefendantWhereInput>
  }, "id">

  export type DefendantDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    defendantRole?: SortOrder
    defendantAccountId?: SortOrder
    defendantInsuranceCarrierId?: SortOrderInput | SortOrder
    insurancePolicyNumber?: SortOrderInput | SortOrder
    driverLicenseNumber?: SortOrderInput | SortOrder
    driverLicenseState?: SortOrderInput | SortOrder
    vehicleMake?: SortOrderInput | SortOrder
    vehicleModel?: SortOrderInput | SortOrder
    vehicleYear?: SortOrderInput | SortOrder
    vehicleColor?: SortOrderInput | SortOrder
    vehiclePlate?: SortOrderInput | SortOrder
    vehiclePosition?: SortOrderInput | SortOrder
    vehicleRegisteredState?: SortOrderInput | SortOrder
    collisionType?: SortOrderInput | SortOrder
    supervisorName?: SortOrderInput | SortOrder
    supervisorContact?: SortOrderInput | SortOrder
    client?: SortOrder
    groupId?: SortOrderInput | SortOrder
    sort?: SortOrder
    defendantId?: SortOrder
    _count?: DefendantDetailsCountOrderByAggregateInput
    _avg?: DefendantDetailsAvgOrderByAggregateInput
    _max?: DefendantDetailsMaxOrderByAggregateInput
    _min?: DefendantDetailsMinOrderByAggregateInput
    _sum?: DefendantDetailsSumOrderByAggregateInput
  }

  export type DefendantDetailsScalarWhereWithAggregatesInput = {
    AND?: DefendantDetailsScalarWhereWithAggregatesInput | DefendantDetailsScalarWhereWithAggregatesInput[]
    OR?: DefendantDetailsScalarWhereWithAggregatesInput[]
    NOT?: DefendantDetailsScalarWhereWithAggregatesInput | DefendantDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefendantDetails"> | string
    defendantRole?: EnumDefendantRoleWithAggregatesFilter<"DefendantDetails"> | $Enums.DefendantRole
    defendantAccountId?: StringWithAggregatesFilter<"DefendantDetails"> | string
    defendantInsuranceCarrierId?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    insurancePolicyNumber?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    driverLicenseNumber?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    driverLicenseState?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    vehicleMake?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    vehicleModel?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    vehicleYear?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    vehicleColor?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    vehiclePlate?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    vehiclePosition?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    vehicleRegisteredState?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    collisionType?: EnumCollisionTypeNullableWithAggregatesFilter<"DefendantDetails"> | $Enums.CollisionType | null
    supervisorName?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    supervisorContact?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    client?: BoolWithAggregatesFilter<"DefendantDetails"> | boolean
    groupId?: StringNullableWithAggregatesFilter<"DefendantDetails"> | string | null
    sort?: IntWithAggregatesFilter<"DefendantDetails"> | number
    defendantId?: StringWithAggregatesFilter<"DefendantDetails"> | string
  }

  export type TreatmentAndInjuryWhereInput = {
    AND?: TreatmentAndInjuryWhereInput | TreatmentAndInjuryWhereInput[]
    OR?: TreatmentAndInjuryWhereInput[]
    NOT?: TreatmentAndInjuryWhereInput | TreatmentAndInjuryWhereInput[]
    id?: StringFilter<"TreatmentAndInjury"> | string
    claimId?: StringFilter<"TreatmentAndInjury"> | string
    treatmentId?: StringFilter<"TreatmentAndInjury"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    treatment?: XOR<TreatmentRelationFilter, TreatmentWhereInput>
  }

  export type TreatmentAndInjuryOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    treatmentId?: SortOrder
    claim?: ClaimOrderByWithRelationInput
    treatment?: TreatmentOrderByWithRelationInput
  }

  export type TreatmentAndInjuryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimId?: string
    treatmentId?: string
    AND?: TreatmentAndInjuryWhereInput | TreatmentAndInjuryWhereInput[]
    OR?: TreatmentAndInjuryWhereInput[]
    NOT?: TreatmentAndInjuryWhereInput | TreatmentAndInjuryWhereInput[]
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    treatment?: XOR<TreatmentRelationFilter, TreatmentWhereInput>
  }, "id" | "claimId" | "treatmentId">

  export type TreatmentAndInjuryOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    treatmentId?: SortOrder
    _count?: TreatmentAndInjuryCountOrderByAggregateInput
    _max?: TreatmentAndInjuryMaxOrderByAggregateInput
    _min?: TreatmentAndInjuryMinOrderByAggregateInput
  }

  export type TreatmentAndInjuryScalarWhereWithAggregatesInput = {
    AND?: TreatmentAndInjuryScalarWhereWithAggregatesInput | TreatmentAndInjuryScalarWhereWithAggregatesInput[]
    OR?: TreatmentAndInjuryScalarWhereWithAggregatesInput[]
    NOT?: TreatmentAndInjuryScalarWhereWithAggregatesInput | TreatmentAndInjuryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TreatmentAndInjury"> | string
    claimId?: StringWithAggregatesFilter<"TreatmentAndInjury"> | string
    treatmentId?: StringWithAggregatesFilter<"TreatmentAndInjury"> | string
  }

  export type TreatmentWhereInput = {
    AND?: TreatmentWhereInput | TreatmentWhereInput[]
    OR?: TreatmentWhereInput[]
    NOT?: TreatmentWhereInput | TreatmentWhereInput[]
    id?: StringFilter<"Treatment"> | string
    takenHospital?: BoolFilter<"Treatment"> | boolean
    isCurrentlyTreated?: BoolFilter<"Treatment"> | boolean
    hospitalId?: StringNullableFilter<"Treatment"> | string | null
    doctorId?: StringNullableFilter<"Treatment"> | string | null
    admission?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    discharge?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    lastVisit?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    otherInjuries?: StringNullableFilter<"Treatment"> | string | null
    role?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    doctor?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    injuries?: InjuryListRelationFilter
    treatmentsAndInjuries?: XOR<TreatmentAndInjuryNullableRelationFilter, TreatmentAndInjuryWhereInput> | null
  }

  export type TreatmentOrderByWithRelationInput = {
    id?: SortOrder
    takenHospital?: SortOrder
    isCurrentlyTreated?: SortOrder
    hospitalId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    admission?: SortOrderInput | SortOrder
    discharge?: SortOrderInput | SortOrder
    lastVisit?: SortOrderInput | SortOrder
    otherInjuries?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
    doctor?: RoleOrderByWithRelationInput
    injuries?: InjuryOrderByRelationAggregateInput
    treatmentsAndInjuries?: TreatmentAndInjuryOrderByWithRelationInput
  }

  export type TreatmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TreatmentWhereInput | TreatmentWhereInput[]
    OR?: TreatmentWhereInput[]
    NOT?: TreatmentWhereInput | TreatmentWhereInput[]
    takenHospital?: BoolFilter<"Treatment"> | boolean
    isCurrentlyTreated?: BoolFilter<"Treatment"> | boolean
    hospitalId?: StringNullableFilter<"Treatment"> | string | null
    doctorId?: StringNullableFilter<"Treatment"> | string | null
    admission?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    discharge?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    lastVisit?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    otherInjuries?: StringNullableFilter<"Treatment"> | string | null
    role?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    doctor?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    injuries?: InjuryListRelationFilter
    treatmentsAndInjuries?: XOR<TreatmentAndInjuryNullableRelationFilter, TreatmentAndInjuryWhereInput> | null
  }, "id">

  export type TreatmentOrderByWithAggregationInput = {
    id?: SortOrder
    takenHospital?: SortOrder
    isCurrentlyTreated?: SortOrder
    hospitalId?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    admission?: SortOrderInput | SortOrder
    discharge?: SortOrderInput | SortOrder
    lastVisit?: SortOrderInput | SortOrder
    otherInjuries?: SortOrderInput | SortOrder
    _count?: TreatmentCountOrderByAggregateInput
    _max?: TreatmentMaxOrderByAggregateInput
    _min?: TreatmentMinOrderByAggregateInput
  }

  export type TreatmentScalarWhereWithAggregatesInput = {
    AND?: TreatmentScalarWhereWithAggregatesInput | TreatmentScalarWhereWithAggregatesInput[]
    OR?: TreatmentScalarWhereWithAggregatesInput[]
    NOT?: TreatmentScalarWhereWithAggregatesInput | TreatmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Treatment"> | string
    takenHospital?: BoolWithAggregatesFilter<"Treatment"> | boolean
    isCurrentlyTreated?: BoolWithAggregatesFilter<"Treatment"> | boolean
    hospitalId?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    doctorId?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    admission?: DateTimeNullableWithAggregatesFilter<"Treatment"> | Date | string | null
    discharge?: DateTimeNullableWithAggregatesFilter<"Treatment"> | Date | string | null
    lastVisit?: DateTimeNullableWithAggregatesFilter<"Treatment"> | Date | string | null
    otherInjuries?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
  }

  export type InjuryWhereInput = {
    AND?: InjuryWhereInput | InjuryWhereInput[]
    OR?: InjuryWhereInput[]
    NOT?: InjuryWhereInput | InjuryWhereInput[]
    id?: StringFilter<"Injury"> | string
    injuryLocation?: EnumInjuryPointFilter<"Injury"> | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFilter<"Injury"> | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFilter<"Injury"> | $Enums.InjurySide
    other?: StringNullableFilter<"Injury"> | string | null
    treatmentId?: StringFilter<"Injury"> | string
    treatment?: XOR<TreatmentRelationFilter, TreatmentWhereInput>
  }

  export type InjuryOrderByWithRelationInput = {
    id?: SortOrder
    injuryLocation?: SortOrder
    injury?: SortOrder
    injuryLocationSide?: SortOrder
    other?: SortOrderInput | SortOrder
    treatmentId?: SortOrder
    treatment?: TreatmentOrderByWithRelationInput
  }

  export type InjuryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InjuryWhereInput | InjuryWhereInput[]
    OR?: InjuryWhereInput[]
    NOT?: InjuryWhereInput | InjuryWhereInput[]
    injuryLocation?: EnumInjuryPointFilter<"Injury"> | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFilter<"Injury"> | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFilter<"Injury"> | $Enums.InjurySide
    other?: StringNullableFilter<"Injury"> | string | null
    treatmentId?: StringFilter<"Injury"> | string
    treatment?: XOR<TreatmentRelationFilter, TreatmentWhereInput>
  }, "id">

  export type InjuryOrderByWithAggregationInput = {
    id?: SortOrder
    injuryLocation?: SortOrder
    injury?: SortOrder
    injuryLocationSide?: SortOrder
    other?: SortOrderInput | SortOrder
    treatmentId?: SortOrder
    _count?: InjuryCountOrderByAggregateInput
    _max?: InjuryMaxOrderByAggregateInput
    _min?: InjuryMinOrderByAggregateInput
  }

  export type InjuryScalarWhereWithAggregatesInput = {
    AND?: InjuryScalarWhereWithAggregatesInput | InjuryScalarWhereWithAggregatesInput[]
    OR?: InjuryScalarWhereWithAggregatesInput[]
    NOT?: InjuryScalarWhereWithAggregatesInput | InjuryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Injury"> | string
    injuryLocation?: EnumInjuryPointWithAggregatesFilter<"Injury"> | $Enums.InjuryPoint
    injury?: EnumInjuryTypeWithAggregatesFilter<"Injury"> | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideWithAggregatesFilter<"Injury"> | $Enums.InjurySide
    other?: StringNullableWithAggregatesFilter<"Injury"> | string | null
    treatmentId?: StringWithAggregatesFilter<"Injury"> | string
  }

  export type AccidentMediaWhereInput = {
    AND?: AccidentMediaWhereInput | AccidentMediaWhereInput[]
    OR?: AccidentMediaWhereInput[]
    NOT?: AccidentMediaWhereInput | AccidentMediaWhereInput[]
    id?: StringFilter<"AccidentMedia"> | string
    url?: StringFilter<"AccidentMedia"> | string
    type?: StringFilter<"AccidentMedia"> | string
    thumbnail?: StringNullableFilter<"AccidentMedia"> | string | null
    claimId?: StringFilter<"AccidentMedia"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
  }

  export type AccidentMediaOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    claimId?: SortOrder
    claim?: ClaimOrderByWithRelationInput
  }

  export type AccidentMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccidentMediaWhereInput | AccidentMediaWhereInput[]
    OR?: AccidentMediaWhereInput[]
    NOT?: AccidentMediaWhereInput | AccidentMediaWhereInput[]
    url?: StringFilter<"AccidentMedia"> | string
    type?: StringFilter<"AccidentMedia"> | string
    thumbnail?: StringNullableFilter<"AccidentMedia"> | string | null
    claimId?: StringFilter<"AccidentMedia"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
  }, "id">

  export type AccidentMediaOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    claimId?: SortOrder
    _count?: AccidentMediaCountOrderByAggregateInput
    _max?: AccidentMediaMaxOrderByAggregateInput
    _min?: AccidentMediaMinOrderByAggregateInput
  }

  export type AccidentMediaScalarWhereWithAggregatesInput = {
    AND?: AccidentMediaScalarWhereWithAggregatesInput | AccidentMediaScalarWhereWithAggregatesInput[]
    OR?: AccidentMediaScalarWhereWithAggregatesInput[]
    NOT?: AccidentMediaScalarWhereWithAggregatesInput | AccidentMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccidentMedia"> | string
    url?: StringWithAggregatesFilter<"AccidentMedia"> | string
    type?: StringWithAggregatesFilter<"AccidentMedia"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"AccidentMedia"> | string | null
    claimId?: StringWithAggregatesFilter<"AccidentMedia"> | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    vehicleRole?: StringNullableFilter<"Incident"> | string | null
    vehicleCount?: IntNullableFilter<"Incident"> | number | null
    busOrVehicle?: EnumBusOrVehicleNullableFilter<"Incident"> | $Enums.BusOrVehicle | null
    transportType?: EnumTransportTypeNullableFilter<"Incident"> | $Enums.TransportType | null
    rideShareCompany?: StringNullableFilter<"Incident"> | string | null
    rideShareOtherName?: StringNullableFilter<"Incident"> | string | null
    propertyType?: EnumPropertyTypeNullableFilter<"Incident"> | $Enums.PropertyType | null
    datetime?: DateTimeFilter<"Incident"> | Date | string
    location?: StringNullableFilter<"Incident"> | string | null
    workRelated?: BoolFilter<"Incident"> | boolean
    description?: StringNullableFilter<"Incident"> | string | null
    policeReportCompleted?: BoolFilter<"Incident"> | boolean
    policeStationId?: StringNullableFilter<"Incident"> | string | null
    policeOfficerId?: StringNullableFilter<"Incident"> | string | null
    reportCompleted?: BoolFilter<"Incident"> | boolean
    reportNumber?: StringNullableFilter<"Incident"> | string | null
    supportingDocument?: BoolFilter<"Incident"> | boolean
    lostEarning?: StringFilter<"Incident"> | string
    amountLoss?: StringNullableFilter<"Incident"> | string | null
    timeLoss?: StringNullableFilter<"Incident"> | string | null
    witness?: BoolFilter<"Incident"> | boolean
    priorRepresentation?: BoolFilter<"Incident"> | boolean
    priorRepresentationReason?: StringNullableFilter<"Incident"> | string | null
    lawfirmId?: StringNullableFilter<"Incident"> | string | null
    attorneyId?: StringNullableFilter<"Incident"> | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    policeStation?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    policeOfficer?: XOR<SubAccountNullableRelationFilter, SubAccountWhereInput> | null
    lawfirm?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    attorney?: XOR<SubAccountNullableRelationFilter, SubAccountWhereInput> | null
    Claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    vehicleRole?: SortOrderInput | SortOrder
    vehicleCount?: SortOrderInput | SortOrder
    busOrVehicle?: SortOrderInput | SortOrder
    transportType?: SortOrderInput | SortOrder
    rideShareCompany?: SortOrderInput | SortOrder
    rideShareOtherName?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    datetime?: SortOrder
    location?: SortOrderInput | SortOrder
    workRelated?: SortOrder
    description?: SortOrderInput | SortOrder
    policeReportCompleted?: SortOrder
    policeStationId?: SortOrderInput | SortOrder
    policeOfficerId?: SortOrderInput | SortOrder
    reportCompleted?: SortOrder
    reportNumber?: SortOrderInput | SortOrder
    supportingDocument?: SortOrder
    lostEarning?: SortOrder
    amountLoss?: SortOrderInput | SortOrder
    timeLoss?: SortOrderInput | SortOrder
    witness?: SortOrder
    priorRepresentation?: SortOrder
    priorRepresentationReason?: SortOrderInput | SortOrder
    lawfirmId?: SortOrderInput | SortOrder
    attorneyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    policeStation?: RoleOrderByWithRelationInput
    policeOfficer?: SubAccountOrderByWithRelationInput
    lawfirm?: RoleOrderByWithRelationInput
    attorney?: SubAccountOrderByWithRelationInput
    Claim?: ClaimOrderByWithRelationInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    vehicleRole?: StringNullableFilter<"Incident"> | string | null
    vehicleCount?: IntNullableFilter<"Incident"> | number | null
    busOrVehicle?: EnumBusOrVehicleNullableFilter<"Incident"> | $Enums.BusOrVehicle | null
    transportType?: EnumTransportTypeNullableFilter<"Incident"> | $Enums.TransportType | null
    rideShareCompany?: StringNullableFilter<"Incident"> | string | null
    rideShareOtherName?: StringNullableFilter<"Incident"> | string | null
    propertyType?: EnumPropertyTypeNullableFilter<"Incident"> | $Enums.PropertyType | null
    datetime?: DateTimeFilter<"Incident"> | Date | string
    location?: StringNullableFilter<"Incident"> | string | null
    workRelated?: BoolFilter<"Incident"> | boolean
    description?: StringNullableFilter<"Incident"> | string | null
    policeReportCompleted?: BoolFilter<"Incident"> | boolean
    policeStationId?: StringNullableFilter<"Incident"> | string | null
    policeOfficerId?: StringNullableFilter<"Incident"> | string | null
    reportCompleted?: BoolFilter<"Incident"> | boolean
    reportNumber?: StringNullableFilter<"Incident"> | string | null
    supportingDocument?: BoolFilter<"Incident"> | boolean
    lostEarning?: StringFilter<"Incident"> | string
    amountLoss?: StringNullableFilter<"Incident"> | string | null
    timeLoss?: StringNullableFilter<"Incident"> | string | null
    witness?: BoolFilter<"Incident"> | boolean
    priorRepresentation?: BoolFilter<"Incident"> | boolean
    priorRepresentationReason?: StringNullableFilter<"Incident"> | string | null
    lawfirmId?: StringNullableFilter<"Incident"> | string | null
    attorneyId?: StringNullableFilter<"Incident"> | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    policeStation?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    policeOfficer?: XOR<SubAccountNullableRelationFilter, SubAccountWhereInput> | null
    lawfirm?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    attorney?: XOR<SubAccountNullableRelationFilter, SubAccountWhereInput> | null
    Claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleRole?: SortOrderInput | SortOrder
    vehicleCount?: SortOrderInput | SortOrder
    busOrVehicle?: SortOrderInput | SortOrder
    transportType?: SortOrderInput | SortOrder
    rideShareCompany?: SortOrderInput | SortOrder
    rideShareOtherName?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    datetime?: SortOrder
    location?: SortOrderInput | SortOrder
    workRelated?: SortOrder
    description?: SortOrderInput | SortOrder
    policeReportCompleted?: SortOrder
    policeStationId?: SortOrderInput | SortOrder
    policeOfficerId?: SortOrderInput | SortOrder
    reportCompleted?: SortOrder
    reportNumber?: SortOrderInput | SortOrder
    supportingDocument?: SortOrder
    lostEarning?: SortOrder
    amountLoss?: SortOrderInput | SortOrder
    timeLoss?: SortOrderInput | SortOrder
    witness?: SortOrder
    priorRepresentation?: SortOrder
    priorRepresentationReason?: SortOrderInput | SortOrder
    lawfirmId?: SortOrderInput | SortOrder
    attorneyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _avg?: IncidentAvgOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
    _sum?: IncidentSumOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    vehicleRole?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    vehicleCount?: IntNullableWithAggregatesFilter<"Incident"> | number | null
    busOrVehicle?: EnumBusOrVehicleNullableWithAggregatesFilter<"Incident"> | $Enums.BusOrVehicle | null
    transportType?: EnumTransportTypeNullableWithAggregatesFilter<"Incident"> | $Enums.TransportType | null
    rideShareCompany?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    rideShareOtherName?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    propertyType?: EnumPropertyTypeNullableWithAggregatesFilter<"Incident"> | $Enums.PropertyType | null
    datetime?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    workRelated?: BoolWithAggregatesFilter<"Incident"> | boolean
    description?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    policeReportCompleted?: BoolWithAggregatesFilter<"Incident"> | boolean
    policeStationId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    policeOfficerId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    reportCompleted?: BoolWithAggregatesFilter<"Incident"> | boolean
    reportNumber?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    supportingDocument?: BoolWithAggregatesFilter<"Incident"> | boolean
    lostEarning?: StringWithAggregatesFilter<"Incident"> | string
    amountLoss?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    timeLoss?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    witness?: BoolWithAggregatesFilter<"Incident"> | boolean
    priorRepresentation?: BoolWithAggregatesFilter<"Incident"> | boolean
    priorRepresentationReason?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    lawfirmId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    attorneyId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
  }

  export type WitnessWhereInput = {
    AND?: WitnessWhereInput | WitnessWhereInput[]
    OR?: WitnessWhereInput[]
    NOT?: WitnessWhereInput | WitnessWhereInput[]
    id?: StringFilter<"Witness"> | string
    claimId?: StringFilter<"Witness"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    witnessDetails?: WitnessDetailsListRelationFilter
  }

  export type WitnessOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    claim?: ClaimOrderByWithRelationInput
    witnessDetails?: WitnessDetailsOrderByRelationAggregateInput
  }

  export type WitnessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimId?: string
    AND?: WitnessWhereInput | WitnessWhereInput[]
    OR?: WitnessWhereInput[]
    NOT?: WitnessWhereInput | WitnessWhereInput[]
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    witnessDetails?: WitnessDetailsListRelationFilter
  }, "id" | "claimId">

  export type WitnessOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    _count?: WitnessCountOrderByAggregateInput
    _max?: WitnessMaxOrderByAggregateInput
    _min?: WitnessMinOrderByAggregateInput
  }

  export type WitnessScalarWhereWithAggregatesInput = {
    AND?: WitnessScalarWhereWithAggregatesInput | WitnessScalarWhereWithAggregatesInput[]
    OR?: WitnessScalarWhereWithAggregatesInput[]
    NOT?: WitnessScalarWhereWithAggregatesInput | WitnessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Witness"> | string
    claimId?: StringWithAggregatesFilter<"Witness"> | string
  }

  export type WitnessDetailsWhereInput = {
    AND?: WitnessDetailsWhereInput | WitnessDetailsWhereInput[]
    OR?: WitnessDetailsWhereInput[]
    NOT?: WitnessDetailsWhereInput | WitnessDetailsWhereInput[]
    id?: StringFilter<"WitnessDetails"> | string
    witnessId?: StringFilter<"WitnessDetails"> | string
    roleId?: StringFilter<"WitnessDetails"> | string
    witness?: XOR<WitnessRelationFilter, WitnessWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type WitnessDetailsOrderByWithRelationInput = {
    id?: SortOrder
    witnessId?: SortOrder
    roleId?: SortOrder
    witness?: WitnessOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type WitnessDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId?: string
    AND?: WitnessDetailsWhereInput | WitnessDetailsWhereInput[]
    OR?: WitnessDetailsWhereInput[]
    NOT?: WitnessDetailsWhereInput | WitnessDetailsWhereInput[]
    witnessId?: StringFilter<"WitnessDetails"> | string
    witness?: XOR<WitnessRelationFilter, WitnessWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id" | "roleId">

  export type WitnessDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    witnessId?: SortOrder
    roleId?: SortOrder
    _count?: WitnessDetailsCountOrderByAggregateInput
    _max?: WitnessDetailsMaxOrderByAggregateInput
    _min?: WitnessDetailsMinOrderByAggregateInput
  }

  export type WitnessDetailsScalarWhereWithAggregatesInput = {
    AND?: WitnessDetailsScalarWhereWithAggregatesInput | WitnessDetailsScalarWhereWithAggregatesInput[]
    OR?: WitnessDetailsScalarWhereWithAggregatesInput[]
    NOT?: WitnessDetailsScalarWhereWithAggregatesInput | WitnessDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WitnessDetails"> | string
    witnessId?: StringWithAggregatesFilter<"WitnessDetails"> | string
    roleId?: StringWithAggregatesFilter<"WitnessDetails"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    accountId?: StringNullableFilter<"Role"> | string | null
    roletypeId?: StringFilter<"Role"> | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    roletype?: XOR<RoleTypeRelationFilter, RoleTypeWhereInput>
    clientClaims?: ClaimListRelationFilter
    injuredPartyClaims?: ClaimListRelationFilter
    healthInsuranceClaims?: ClaimListRelationFilter
    witnessDetails?: XOR<WitnessDetailsNullableRelationFilter, WitnessDetailsWhereInput> | null
    defendantAccount?: DefendantDetailsListRelationFilter
    defendantInsuranceCarrier?: DefendantDetailsListRelationFilter
    hospitalTreatments?: TreatmentListRelationFilter
    doctorTreatments?: TreatmentListRelationFilter
    lawfirmIncidents?: IncidentListRelationFilter
    policeStationIncidents?: IncidentListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    roletypeId?: SortOrder
    account?: AccountOrderByWithRelationInput
    roletype?: RoleTypeOrderByWithRelationInput
    clientClaims?: ClaimOrderByRelationAggregateInput
    injuredPartyClaims?: ClaimOrderByRelationAggregateInput
    healthInsuranceClaims?: ClaimOrderByRelationAggregateInput
    witnessDetails?: WitnessDetailsOrderByWithRelationInput
    defendantAccount?: DefendantDetailsOrderByRelationAggregateInput
    defendantInsuranceCarrier?: DefendantDetailsOrderByRelationAggregateInput
    hospitalTreatments?: TreatmentOrderByRelationAggregateInput
    doctorTreatments?: TreatmentOrderByRelationAggregateInput
    lawfirmIncidents?: IncidentOrderByRelationAggregateInput
    policeStationIncidents?: IncidentOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    accountId?: StringNullableFilter<"Role"> | string | null
    roletypeId?: StringFilter<"Role"> | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    roletype?: XOR<RoleTypeRelationFilter, RoleTypeWhereInput>
    clientClaims?: ClaimListRelationFilter
    injuredPartyClaims?: ClaimListRelationFilter
    healthInsuranceClaims?: ClaimListRelationFilter
    witnessDetails?: XOR<WitnessDetailsNullableRelationFilter, WitnessDetailsWhereInput> | null
    defendantAccount?: DefendantDetailsListRelationFilter
    defendantInsuranceCarrier?: DefendantDetailsListRelationFilter
    hospitalTreatments?: TreatmentListRelationFilter
    doctorTreatments?: TreatmentListRelationFilter
    lawfirmIncidents?: IncidentListRelationFilter
    policeStationIncidents?: IncidentListRelationFilter
  }, "id">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    roletypeId?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    accountId?: StringNullableWithAggregatesFilter<"Role"> | string | null
    roletypeId?: StringWithAggregatesFilter<"Role"> | string
  }

  export type RoleTypeWhereInput = {
    AND?: RoleTypeWhereInput | RoleTypeWhereInput[]
    OR?: RoleTypeWhereInput[]
    NOT?: RoleTypeWhereInput | RoleTypeWhereInput[]
    id?: StringFilter<"RoleType"> | string
    roleType?: StringFilter<"RoleType"> | string
    createdAt?: DateTimeFilter<"RoleType"> | Date | string
    createdBy?: StringNullableFilter<"RoleType"> | string | null
    enable?: BoolNullableFilter<"RoleType"> | boolean | null
    Role?: RoleListRelationFilter
  }

  export type RoleTypeOrderByWithRelationInput = {
    id?: SortOrder
    roleType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    Role?: RoleOrderByRelationAggregateInput
  }

  export type RoleTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleType?: string
    AND?: RoleTypeWhereInput | RoleTypeWhereInput[]
    OR?: RoleTypeWhereInput[]
    NOT?: RoleTypeWhereInput | RoleTypeWhereInput[]
    createdAt?: DateTimeFilter<"RoleType"> | Date | string
    createdBy?: StringNullableFilter<"RoleType"> | string | null
    enable?: BoolNullableFilter<"RoleType"> | boolean | null
    Role?: RoleListRelationFilter
  }, "id" | "roleType">

  export type RoleTypeOrderByWithAggregationInput = {
    id?: SortOrder
    roleType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    _count?: RoleTypeCountOrderByAggregateInput
    _max?: RoleTypeMaxOrderByAggregateInput
    _min?: RoleTypeMinOrderByAggregateInput
  }

  export type RoleTypeScalarWhereWithAggregatesInput = {
    AND?: RoleTypeScalarWhereWithAggregatesInput | RoleTypeScalarWhereWithAggregatesInput[]
    OR?: RoleTypeScalarWhereWithAggregatesInput[]
    NOT?: RoleTypeScalarWhereWithAggregatesInput | RoleTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleType"> | string
    roleType?: StringWithAggregatesFilter<"RoleType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RoleType"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"RoleType"> | string | null
    enable?: BoolNullableWithAggregatesFilter<"RoleType"> | boolean | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    firstName?: StringNullableFilter<"Account"> | string | null
    lastName?: StringNullableFilter<"Account"> | string | null
    email?: StringNullableFilter<"Account"> | string | null
    phone?: StringNullableFilter<"Account"> | string | null
    phone2?: StringNullableFilter<"Account"> | string | null
    fax?: StringNullableFilter<"Account"> | string | null
    mailingAddress?: StringNullableFilter<"Account"> | string | null
    mailingAddressBuilding?: StringNullableFilter<"Account"> | string | null
    mailingCity?: StringNullableFilter<"Account"> | string | null
    mailingState?: StringNullableFilter<"Account"> | string | null
    mailingZipCode?: StringNullableFilter<"Account"> | string | null
    billingAddressStreet?: StringNullableFilter<"Account"> | string | null
    billingAddressBuilding?: StringNullableFilter<"Account"> | string | null
    billingAddressCity?: StringNullableFilter<"Account"> | string | null
    billingAddressState?: StringNullableFilter<"Account"> | string | null
    billingAddressPostalCode?: StringNullableFilter<"Account"> | string | null
    website?: StringNullableFilter<"Account"> | string | null
    enable?: BoolNullableFilter<"Account"> | boolean | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    Role?: RoleListRelationFilter
    subAccount?: SubAccountListRelationFilter
    projectAccounts?: ProjectAccountListRelationFilter
    taskAccounts?: TaskAccountListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phone2?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    mailingAddressBuilding?: SortOrderInput | SortOrder
    mailingCity?: SortOrderInput | SortOrder
    mailingState?: SortOrderInput | SortOrder
    mailingZipCode?: SortOrderInput | SortOrder
    billingAddressStreet?: SortOrderInput | SortOrder
    billingAddressBuilding?: SortOrderInput | SortOrder
    billingAddressCity?: SortOrderInput | SortOrder
    billingAddressState?: SortOrderInput | SortOrder
    billingAddressPostalCode?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Role?: RoleOrderByRelationAggregateInput
    subAccount?: SubAccountOrderByRelationAggregateInput
    projectAccounts?: ProjectAccountOrderByRelationAggregateInput
    taskAccounts?: TaskAccountOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    firstName?: StringNullableFilter<"Account"> | string | null
    lastName?: StringNullableFilter<"Account"> | string | null
    email?: StringNullableFilter<"Account"> | string | null
    phone?: StringNullableFilter<"Account"> | string | null
    phone2?: StringNullableFilter<"Account"> | string | null
    fax?: StringNullableFilter<"Account"> | string | null
    mailingAddress?: StringNullableFilter<"Account"> | string | null
    mailingAddressBuilding?: StringNullableFilter<"Account"> | string | null
    mailingCity?: StringNullableFilter<"Account"> | string | null
    mailingState?: StringNullableFilter<"Account"> | string | null
    mailingZipCode?: StringNullableFilter<"Account"> | string | null
    billingAddressStreet?: StringNullableFilter<"Account"> | string | null
    billingAddressBuilding?: StringNullableFilter<"Account"> | string | null
    billingAddressCity?: StringNullableFilter<"Account"> | string | null
    billingAddressState?: StringNullableFilter<"Account"> | string | null
    billingAddressPostalCode?: StringNullableFilter<"Account"> | string | null
    website?: StringNullableFilter<"Account"> | string | null
    enable?: BoolNullableFilter<"Account"> | boolean | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    Role?: RoleListRelationFilter
    subAccount?: SubAccountListRelationFilter
    projectAccounts?: ProjectAccountListRelationFilter
    taskAccounts?: TaskAccountListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phone2?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    mailingAddressBuilding?: SortOrderInput | SortOrder
    mailingCity?: SortOrderInput | SortOrder
    mailingState?: SortOrderInput | SortOrder
    mailingZipCode?: SortOrderInput | SortOrder
    billingAddressStreet?: SortOrderInput | SortOrder
    billingAddressBuilding?: SortOrderInput | SortOrder
    billingAddressCity?: SortOrderInput | SortOrder
    billingAddressState?: SortOrderInput | SortOrder
    billingAddressPostalCode?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    firstName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    email?: StringNullableWithAggregatesFilter<"Account"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Account"> | string | null
    phone2?: StringNullableWithAggregatesFilter<"Account"> | string | null
    fax?: StringNullableWithAggregatesFilter<"Account"> | string | null
    mailingAddress?: StringNullableWithAggregatesFilter<"Account"> | string | null
    mailingAddressBuilding?: StringNullableWithAggregatesFilter<"Account"> | string | null
    mailingCity?: StringNullableWithAggregatesFilter<"Account"> | string | null
    mailingState?: StringNullableWithAggregatesFilter<"Account"> | string | null
    mailingZipCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    billingAddressStreet?: StringNullableWithAggregatesFilter<"Account"> | string | null
    billingAddressBuilding?: StringNullableWithAggregatesFilter<"Account"> | string | null
    billingAddressCity?: StringNullableWithAggregatesFilter<"Account"> | string | null
    billingAddressState?: StringNullableWithAggregatesFilter<"Account"> | string | null
    billingAddressPostalCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    website?: StringNullableWithAggregatesFilter<"Account"> | string | null
    enable?: BoolNullableWithAggregatesFilter<"Account"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SubAccountWhereInput = {
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    firstName?: StringNullableFilter<"SubAccount"> | string | null
    lastName?: StringNullableFilter<"SubAccount"> | string | null
    phone?: StringNullableFilter<"SubAccount"> | string | null
    accountId?: StringFilter<"SubAccount"> | string
    enable?: BoolNullableFilter<"SubAccount"> | boolean | null
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    incidents?: IncidentListRelationFilter
    policeIncidents?: IncidentListRelationFilter
  }

  export type SubAccountOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    accountId?: SortOrder
    enable?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    incidents?: IncidentOrderByRelationAggregateInput
    policeIncidents?: IncidentOrderByRelationAggregateInput
  }

  export type SubAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    firstName?: StringNullableFilter<"SubAccount"> | string | null
    lastName?: StringNullableFilter<"SubAccount"> | string | null
    phone?: StringNullableFilter<"SubAccount"> | string | null
    accountId?: StringFilter<"SubAccount"> | string
    enable?: BoolNullableFilter<"SubAccount"> | boolean | null
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    incidents?: IncidentListRelationFilter
    policeIncidents?: IncidentListRelationFilter
  }, "id">

  export type SubAccountOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    accountId?: SortOrder
    enable?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubAccountCountOrderByAggregateInput
    _max?: SubAccountMaxOrderByAggregateInput
    _min?: SubAccountMinOrderByAggregateInput
  }

  export type SubAccountScalarWhereWithAggregatesInput = {
    AND?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    OR?: SubAccountScalarWhereWithAggregatesInput[]
    NOT?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccount"> | string
    firstName?: StringNullableWithAggregatesFilter<"SubAccount"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"SubAccount"> | string | null
    phone?: StringNullableWithAggregatesFilter<"SubAccount"> | string | null
    accountId?: StringWithAggregatesFilter<"SubAccount"> | string
    enable?: BoolNullableWithAggregatesFilter<"SubAccount"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
  }

  export type CarWhereInput = {
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    id?: StringFilter<"Car"> | string
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    year?: StringFilter<"Car"> | string
  }

  export type CarOrderByWithRelationInput = {
    id?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
  }

  export type CarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    year?: StringFilter<"Car"> | string
  }, "id">

  export type CarOrderByWithAggregationInput = {
    id?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    _count?: CarCountOrderByAggregateInput
    _max?: CarMaxOrderByAggregateInput
    _min?: CarMinOrderByAggregateInput
  }

  export type CarScalarWhereWithAggregatesInput = {
    AND?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    OR?: CarScalarWhereWithAggregatesInput[]
    NOT?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Car"> | string
    make?: StringWithAggregatesFilter<"Car"> | string
    model?: StringWithAggregatesFilter<"Car"> | string
    year?: StringWithAggregatesFilter<"Car"> | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectsOwnedInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectsOwnedNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUserCreateInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectUsersInput
    user: UserCreateNestedOneWithoutProjectAssignmentsInput
  }

  export type ProjectUserUncheckedCreateInput = {
    projectId: string
    userId: string
    assignedAt?: Date | string
  }

  export type ProjectUserUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectUsersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectAssignmentsNestedInput
  }

  export type ProjectUserUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserCreateManyInput = {
    projectId: string
    userId: string
    assignedAt?: Date | string
  }

  export type ProjectUserUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAccountCreateInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectAccountsInput
    account: AccountCreateNestedOneWithoutProjectAccountsInput
  }

  export type ProjectAccountUncheckedCreateInput = {
    projectId: string
    accountId: string
    assignedAt?: Date | string
  }

  export type ProjectAccountUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutProjectAccountsNestedInput
  }

  export type ProjectAccountUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAccountCreateManyInput = {
    projectId: string
    accountId: string
    assignedAt?: Date | string
  }

  export type ProjectAccountUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAccountUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBoardsInput
    columns?: ColumnCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    columns?: ColumnUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBoardsNestedInput
    columns?: ColumnUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    columns?: ColumnUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type BoardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ColumnCreateInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutColumnsInput
    tasks?: TaskCreateNestedManyWithoutColumnInput
  }

  export type ColumnUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    boardId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutColumnsNestedInput
    tasks?: TaskUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ColumnCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    boardId: string
  }

  export type ColumnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    claimId?: string | null
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    claimId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAccountCreateInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskAccountsInput
    account: AccountCreateNestedOneWithoutTaskAccountsInput
  }

  export type TaskAccountUncheckedCreateInput = {
    taskId: string
    accountId: string
    assignedAt?: Date | string
  }

  export type TaskAccountUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskAccountsNestedInput
    account?: AccountUpdateOneRequiredWithoutTaskAccountsNestedInput
  }

  export type TaskAccountUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAccountCreateManyInput = {
    taskId: string
    accountId: string
    assignedAt?: Date | string
  }

  export type TaskAccountUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAccountUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeCreateInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskAssigneesInput
    user: UserCreateNestedOneWithoutTaskAssignmentsInput
  }

  export type TaskAssigneeUncheckedCreateInput = {
    taskId: string
    userId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskAssigneesNestedInput
    user?: UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput
  }

  export type TaskAssigneeUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeCreateManyInput = {
    taskId: string
    userId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTaskCommentsInput
  }

  export type TaskCommentUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    userId: string
  }

  export type TaskCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTaskCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCommentCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    userId: string
  }

  export type TaskCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAttachmentCreateInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    task: TaskCreateNestedOneWithoutAttachmentsInput
    uploadedBy: UserCreateNestedOneWithoutTaskAttachmentsInput
  }

  export type TaskAttachmentUncheckedCreateInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    taskId: string
    uploadedById: string
  }

  export type TaskAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutTaskAttachmentsNestedInput
  }

  export type TaskAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAttachmentCreateManyInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    taskId: string
    uploadedById: string
  }

  export type TaskAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type TaskLabelCreateInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutLabelsInput
    label: LabelCreateNestedOneWithoutTaskLabelsInput
  }

  export type TaskLabelUncheckedCreateInput = {
    taskId: string
    labelId: string
    assignedAt?: Date | string
  }

  export type TaskLabelUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutLabelsNestedInput
    label?: LabelUpdateOneRequiredWithoutTaskLabelsNestedInput
  }

  export type TaskLabelUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelCreateManyInput = {
    taskId: string
    labelId: string
    assignedAt?: Date | string
  }

  export type TaskLabelUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutLabelsCreatedInput
    taskLabels?: TaskLabelCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    taskLabels?: TaskLabelUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutLabelsCreatedNestedInput
    taskLabels?: TaskLabelUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    taskLabels?: TaskLabelUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type LabelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerifyCreateInput = {
    id?: string
    token: string
    url: string
    status?: string
    sessionId?: string | null
    errorCode?: string | null
    errorMessage?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutVerifyInput
  }

  export type VerifyUncheckedCreateInput = {
    id?: string
    token: string
    url: string
    status?: string
    sessionId?: string | null
    errorCode?: string | null
    errorMessage?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type VerifyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutVerifyNestedInput
  }

  export type VerifyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VerifyCreateManyInput = {
    id?: string
    token: string
    url: string
    status?: string
    sessionId?: string | null
    errorCode?: string | null
    errorMessage?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type VerifyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerifyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimCreateInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateManyInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectClaimCreateInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectClaimsInput
    claim: ClaimCreateNestedOneWithoutProjectClaimsInput
  }

  export type ProjectClaimUncheckedCreateInput = {
    projectId: string
    claimId: string
    assignedAt?: Date | string
  }

  export type ProjectClaimUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectClaimsNestedInput
    claim?: ClaimUpdateOneRequiredWithoutProjectClaimsNestedInput
  }

  export type ProjectClaimUncheckedUpdateInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectClaimCreateManyInput = {
    projectId: string
    claimId: string
    assignedAt?: Date | string
  }

  export type ProjectClaimUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectClaimUncheckedUpdateManyInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopCreateInput = {
    id?: string
    status?: boolean
    submitterUrl?: string | null
    submitterId?: number | null
    submittedUrl?: string | null
    createdAt?: Date | string
    claim: ClaimCreateNestedOneWithoutEnvelopInput
  }

  export type EnvelopUncheckedCreateInput = {
    id?: string
    status?: boolean
    claimId: string
    submitterUrl?: string | null
    submitterId?: number | null
    submittedUrl?: string | null
    createdAt?: Date | string
  }

  export type EnvelopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    submitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: NullableIntFieldUpdateOperationsInput | number | null
    submittedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneRequiredWithoutEnvelopNestedInput
  }

  export type EnvelopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    claimId?: StringFieldUpdateOperationsInput | string
    submitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: NullableIntFieldUpdateOperationsInput | number | null
    submittedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopCreateManyInput = {
    id?: string
    status?: boolean
    claimId: string
    submitterUrl?: string | null
    submitterId?: number | null
    submittedUrl?: string | null
    createdAt?: Date | string
  }

  export type EnvelopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    submitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: NullableIntFieldUpdateOperationsInput | number | null
    submittedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    claimId?: StringFieldUpdateOperationsInput | string
    submitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: NullableIntFieldUpdateOperationsInput | number | null
    submittedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimListCreateInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    claim?: ClaimCreateNestedManyWithoutClaimlistInput
    user?: UserCreateNestedManyWithoutClaimlistInput
    question?: QuestionCreateNestedManyWithoutClaimListInput
  }

  export type ClaimListUncheckedCreateInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    claim?: ClaimUncheckedCreateNestedManyWithoutClaimlistInput
    user?: UserUncheckedCreateNestedManyWithoutClaimlistInput
    question?: QuestionUncheckedCreateNestedManyWithoutClaimListInput
  }

  export type ClaimListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    claim?: ClaimUpdateManyWithoutClaimlistNestedInput
    user?: UserUpdateManyWithoutClaimlistNestedInput
    question?: QuestionUpdateManyWithoutClaimListNestedInput
  }

  export type ClaimListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    claim?: ClaimUncheckedUpdateManyWithoutClaimlistNestedInput
    user?: UserUncheckedUpdateManyWithoutClaimlistNestedInput
    question?: QuestionUncheckedUpdateManyWithoutClaimListNestedInput
  }

  export type ClaimListCreateManyInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type ClaimListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
    user?: UserCreateNestedManyWithoutSourceInput
  }

  export type SourceUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
    user?: UserUncheckedCreateNestedManyWithoutSourceInput
  }

  export type SourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateManyWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type SourceCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
  }

  export type SourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QuestionnaireCreateInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutQuestionnaireInput
    question?: QuestionAnswerCreateNestedManyWithoutQuestionnaireInput
  }

  export type QuestionnaireUncheckedCreateInput = {
    id?: string
    claimId: string
    question?: QuestionAnswerUncheckedCreateNestedManyWithoutQuestionnaireInput
  }

  export type QuestionnaireUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutQuestionnaireNestedInput
    question?: QuestionAnswerUpdateManyWithoutQuestionnaireNestedInput
  }

  export type QuestionnaireUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    question?: QuestionAnswerUncheckedUpdateManyWithoutQuestionnaireNestedInput
  }

  export type QuestionnaireCreateManyInput = {
    id?: string
    claimId: string
  }

  export type QuestionnaireUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionnaireUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionAnswerCreateInput = {
    id?: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Questionnaire?: QuestionnaireCreateNestedOneWithoutQuestionInput
    question: QuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateInput = {
    id?: string
    questionnaireId?: string | null
    questionId: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Questionnaire?: QuestionnaireUpdateOneWithoutQuestionNestedInput
    question?: QuestionUpdateOneRequiredWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerCreateManyInput = {
    id?: string
    questionnaireId?: string | null
    questionId: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    enable?: boolean
    claimList?: ClaimListCreateNestedOneWithoutQuestionInput
    choices?: ChoiceCreateNestedManyWithoutQuestionInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    question: string
    claimListId?: string | null
    type: $Enums.QuestionType
    enable?: boolean
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuestionInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    claimList?: ClaimListUpdateOneWithoutQuestionNestedInput
    choices?: ChoiceUpdateManyWithoutQuestionNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    claimListId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    question: string
    claimListId?: string | null
    type: $Enums.QuestionType
    enable?: boolean
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    claimListId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChoiceCreateInput = {
    id?: string
    text: string
    question: QuestionCreateNestedOneWithoutChoicesInput
  }

  export type ChoiceUncheckedCreateInput = {
    id?: string
    text: string
    questionId: string
  }

  export type ChoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    question?: QuestionUpdateOneRequiredWithoutChoicesNestedInput
  }

  export type ChoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type ChoiceCreateManyInput = {
    id?: string
    text: string
    questionId: string
  }

  export type ChoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type ChoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantCreateInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutDefendantInput
    defendantDetails?: DefendantDetailsCreateNestedManyWithoutDefendantInput
  }

  export type DefendantUncheckedCreateInput = {
    id?: string
    claimId: string
    defendantDetails?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInput
  }

  export type DefendantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutDefendantNestedInput
    defendantDetails?: DefendantDetailsUpdateManyWithoutDefendantNestedInput
  }

  export type DefendantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    defendantDetails?: DefendantDetailsUncheckedUpdateManyWithoutDefendantNestedInput
  }

  export type DefendantCreateManyInput = {
    id?: string
    claimId: string
  }

  export type DefendantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantDetailsCreateInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantAccount: RoleCreateNestedOneWithoutDefendantAccountInput
    defendantInsuranceCarrier?: RoleCreateNestedOneWithoutDefendantInsuranceCarrierInput
    defendant: DefendantCreateNestedOneWithoutDefendantDetailsInput
  }

  export type DefendantDetailsUncheckedCreateInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantAccountId: string
    defendantInsuranceCarrierId?: string | null
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantId: string
  }

  export type DefendantDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantAccount?: RoleUpdateOneRequiredWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: RoleUpdateOneWithoutDefendantInsuranceCarrierNestedInput
    defendant?: DefendantUpdateOneRequiredWithoutDefendantDetailsNestedInput
  }

  export type DefendantDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantAccountId?: StringFieldUpdateOperationsInput | string
    defendantInsuranceCarrierId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantId?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantDetailsCreateManyInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantAccountId: string
    defendantInsuranceCarrierId?: string | null
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantId: string
  }

  export type DefendantDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type DefendantDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantAccountId?: StringFieldUpdateOperationsInput | string
    defendantInsuranceCarrierId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantId?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentAndInjuryCreateInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutTreatmentsAndInjuriesInput
    treatment: TreatmentCreateNestedOneWithoutTreatmentsAndInjuriesInput
  }

  export type TreatmentAndInjuryUncheckedCreateInput = {
    id?: string
    claimId: string
    treatmentId: string
  }

  export type TreatmentAndInjuryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutTreatmentsAndInjuriesNestedInput
    treatment?: TreatmentUpdateOneRequiredWithoutTreatmentsAndInjuriesNestedInput
  }

  export type TreatmentAndInjuryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    treatmentId?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentAndInjuryCreateManyInput = {
    id?: string
    claimId: string
    treatmentId: string
  }

  export type TreatmentAndInjuryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentAndInjuryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    treatmentId?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentCreateInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    role?: RoleCreateNestedOneWithoutHospitalTreatmentsInput
    doctor?: RoleCreateNestedOneWithoutDoctorTreatmentsInput
    injuries?: InjuryCreateNestedManyWithoutTreatmentInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    hospitalId?: string | null
    doctorId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    injuries?: InjuryUncheckedCreateNestedManyWithoutTreatmentInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneWithoutHospitalTreatmentsNestedInput
    doctor?: RoleUpdateOneWithoutDoctorTreatmentsNestedInput
    injuries?: InjuryUpdateManyWithoutTreatmentNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: InjuryUncheckedUpdateManyWithoutTreatmentNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutTreatmentNestedInput
  }

  export type TreatmentCreateManyInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    hospitalId?: string | null
    doctorId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
  }

  export type TreatmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TreatmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InjuryCreateInput = {
    id?: string
    injuryLocation: $Enums.InjuryPoint
    injury: $Enums.InjuryType
    injuryLocationSide: $Enums.InjurySide
    other?: string | null
    treatment: TreatmentCreateNestedOneWithoutInjuriesInput
  }

  export type InjuryUncheckedCreateInput = {
    id?: string
    injuryLocation: $Enums.InjuryPoint
    injury: $Enums.InjuryType
    injuryLocationSide: $Enums.InjurySide
    other?: string | null
    treatmentId: string
  }

  export type InjuryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    injuryLocation?: EnumInjuryPointFieldUpdateOperationsInput | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFieldUpdateOperationsInput | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFieldUpdateOperationsInput | $Enums.InjurySide
    other?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: TreatmentUpdateOneRequiredWithoutInjuriesNestedInput
  }

  export type InjuryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    injuryLocation?: EnumInjuryPointFieldUpdateOperationsInput | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFieldUpdateOperationsInput | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFieldUpdateOperationsInput | $Enums.InjurySide
    other?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentId?: StringFieldUpdateOperationsInput | string
  }

  export type InjuryCreateManyInput = {
    id?: string
    injuryLocation: $Enums.InjuryPoint
    injury: $Enums.InjuryType
    injuryLocationSide: $Enums.InjurySide
    other?: string | null
    treatmentId: string
  }

  export type InjuryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    injuryLocation?: EnumInjuryPointFieldUpdateOperationsInput | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFieldUpdateOperationsInput | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFieldUpdateOperationsInput | $Enums.InjurySide
    other?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InjuryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    injuryLocation?: EnumInjuryPointFieldUpdateOperationsInput | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFieldUpdateOperationsInput | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFieldUpdateOperationsInput | $Enums.InjurySide
    other?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentId?: StringFieldUpdateOperationsInput | string
  }

  export type AccidentMediaCreateInput = {
    id?: string
    url: string
    type: string
    thumbnail?: string | null
    claim: ClaimCreateNestedOneWithoutMediaInput
  }

  export type AccidentMediaUncheckedCreateInput = {
    id?: string
    url: string
    type: string
    thumbnail?: string | null
    claimId: string
  }

  export type AccidentMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    claim?: ClaimUpdateOneRequiredWithoutMediaNestedInput
  }

  export type AccidentMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type AccidentMediaCreateManyInput = {
    id?: string
    url: string
    type: string
    thumbnail?: string | null
    claimId: string
  }

  export type AccidentMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccidentMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentCreateInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policeStation?: RoleCreateNestedOneWithoutPoliceStationIncidentsInput
    policeOfficer?: SubAccountCreateNestedOneWithoutPoliceIncidentsInput
    lawfirm?: RoleCreateNestedOneWithoutLawfirmIncidentsInput
    attorney?: SubAccountCreateNestedOneWithoutIncidentsInput
    Claim?: ClaimCreateNestedOneWithoutIncidentInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Claim?: ClaimUncheckedCreateNestedOneWithoutIncidentInput
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policeStation?: RoleUpdateOneWithoutPoliceStationIncidentsNestedInput
    policeOfficer?: SubAccountUpdateOneWithoutPoliceIncidentsNestedInput
    lawfirm?: RoleUpdateOneWithoutLawfirmIncidentsNestedInput
    attorney?: SubAccountUpdateOneWithoutIncidentsNestedInput
    Claim?: ClaimUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Claim?: ClaimUncheckedUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentCreateManyInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WitnessCreateInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutWitnessInput
    witnessDetails?: WitnessDetailsCreateNestedManyWithoutWitnessInput
  }

  export type WitnessUncheckedCreateInput = {
    id?: string
    claimId: string
    witnessDetails?: WitnessDetailsUncheckedCreateNestedManyWithoutWitnessInput
  }

  export type WitnessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutWitnessNestedInput
    witnessDetails?: WitnessDetailsUpdateManyWithoutWitnessNestedInput
  }

  export type WitnessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    witnessDetails?: WitnessDetailsUncheckedUpdateManyWithoutWitnessNestedInput
  }

  export type WitnessCreateManyInput = {
    id?: string
    claimId: string
  }

  export type WitnessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type WitnessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type WitnessDetailsCreateInput = {
    id?: string
    witness: WitnessCreateNestedOneWithoutWitnessDetailsInput
    role: RoleCreateNestedOneWithoutWitnessDetailsInput
  }

  export type WitnessDetailsUncheckedCreateInput = {
    id?: string
    witnessId: string
    roleId: string
  }

  export type WitnessDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    witness?: WitnessUpdateOneRequiredWithoutWitnessDetailsNestedInput
    role?: RoleUpdateOneRequiredWithoutWitnessDetailsNestedInput
  }

  export type WitnessDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    witnessId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type WitnessDetailsCreateManyInput = {
    id?: string
    witnessId: string
    roleId: string
  }

  export type WitnessDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type WitnessDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    witnessId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleTypeCreateInput = {
    id?: string
    roleType: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
    Role?: RoleCreateNestedManyWithoutRoletypeInput
  }

  export type RoleTypeUncheckedCreateInput = {
    id?: string
    roleType: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
    Role?: RoleUncheckedCreateNestedManyWithoutRoletypeInput
  }

  export type RoleTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Role?: RoleUpdateManyWithoutRoletypeNestedInput
  }

  export type RoleTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Role?: RoleUncheckedUpdateManyWithoutRoletypeNestedInput
  }

  export type RoleTypeCreateManyInput = {
    id?: string
    roleType: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
  }

  export type RoleTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RoleTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AccountCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleCreateNestedManyWithoutAccountInput
    subAccount?: SubAccountCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleUncheckedCreateNestedManyWithoutAccountInput
    subAccount?: SubAccountUncheckedCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateManyWithoutAccountNestedInput
    subAccount?: SubAccountUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUncheckedUpdateManyWithoutAccountNestedInput
    subAccount?: SubAccountUncheckedUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutSubAccountInput
    incidents?: IncidentCreateNestedManyWithoutAttorneyInput
    policeIncidents?: IncidentCreateNestedManyWithoutPoliceOfficerInput
  }

  export type SubAccountUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    accountId: string
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentUncheckedCreateNestedManyWithoutAttorneyInput
    policeIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceOfficerInput
  }

  export type SubAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSubAccountNestedInput
    incidents?: IncidentUpdateManyWithoutAttorneyNestedInput
    policeIncidents?: IncidentUpdateManyWithoutPoliceOfficerNestedInput
  }

  export type SubAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentUncheckedUpdateManyWithoutAttorneyNestedInput
    policeIncidents?: IncidentUncheckedUpdateManyWithoutPoliceOfficerNestedInput
  }

  export type SubAccountCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    accountId: string
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarCreateInput = {
    id?: string
    make: string
    model: string
    year: string
  }

  export type CarUncheckedCreateInput = {
    id?: string
    make: string
    model: string
    year: string
  }

  export type CarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type CarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type CarCreateManyInput = {
    id?: string
    make: string
    model: string
    year: string
  }

  export type CarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type CarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BoardListRelationFilter = {
    every?: BoardWhereInput
    some?: BoardWhereInput
    none?: BoardWhereInput
  }

  export type ProjectClaimListRelationFilter = {
    every?: ProjectClaimWhereInput
    some?: ProjectClaimWhereInput
    none?: ProjectClaimWhereInput
  }

  export type ProjectAccountListRelationFilter = {
    every?: ProjectAccountWhereInput
    some?: ProjectAccountWhereInput
    none?: ProjectAccountWhereInput
  }

  export type ProjectUserListRelationFilter = {
    every?: ProjectUserWhereInput
    some?: ProjectUserWhereInput
    none?: ProjectUserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectUserProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectUserCountOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectUserMaxOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectUserMinOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type ProjectAccountProjectIdAccountIdCompoundUniqueInput = {
    projectId: string
    accountId: string
  }

  export type ProjectAccountCountOrderByAggregateInput = {
    projectId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectAccountMaxOrderByAggregateInput = {
    projectId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectAccountMinOrderByAggregateInput = {
    projectId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ColumnListRelationFilter = {
    every?: ColumnWhereInput
    some?: ColumnWhereInput
    none?: ColumnWhereInput
  }

  export type ColumnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoardRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ColumnCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
  }

  export type ColumnAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ColumnMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
  }

  export type ColumnMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
  }

  export type ColumnSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ColumnRelationFilter = {
    is?: ColumnWhereInput
    isNot?: ColumnWhereInput
  }

  export type TaskAccountListRelationFilter = {
    every?: TaskAccountWhereInput
    some?: TaskAccountWhereInput
    none?: TaskAccountWhereInput
  }

  export type TaskAssigneeListRelationFilter = {
    every?: TaskAssigneeWhereInput
    some?: TaskAssigneeWhereInput
    none?: TaskAssigneeWhereInput
  }

  export type TaskCommentListRelationFilter = {
    every?: TaskCommentWhereInput
    some?: TaskCommentWhereInput
    none?: TaskCommentWhereInput
  }

  export type TaskAttachmentListRelationFilter = {
    every?: TaskAttachmentWhereInput
    some?: TaskAttachmentWhereInput
    none?: TaskAttachmentWhereInput
  }

  export type TaskLabelListRelationFilter = {
    every?: TaskLabelWhereInput
    some?: TaskLabelWhereInput
    none?: TaskLabelWhereInput
  }

  export type ClaimNullableRelationFilter = {
    is?: ClaimWhereInput | null
    isNot?: ClaimWhereInput | null
  }

  export type TaskAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAssigneeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskLabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    position?: SortOrder
    archive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    columnId?: SortOrder
    createdById?: SortOrder
    claimId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    position?: SortOrder
    archive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    columnId?: SortOrder
    createdById?: SortOrder
    claimId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    position?: SortOrder
    archive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    columnId?: SortOrder
    createdById?: SortOrder
    claimId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskAccountTaskIdAccountIdCompoundUniqueInput = {
    taskId: string
    accountId: string
  }

  export type TaskAccountCountOrderByAggregateInput = {
    taskId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAccountMaxOrderByAggregateInput = {
    taskId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAccountMinOrderByAggregateInput = {
    taskId?: SortOrder
    accountId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssigneeTaskIdUserIdCompoundUniqueInput = {
    taskId: string
    userId: string
  }

  export type TaskAssigneeCountOrderByAggregateInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssigneeMaxOrderByAggregateInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssigneeMinOrderByAggregateInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskAttachmentS3BucketS3KeyCompoundUniqueInput = {
    s3Bucket: string
    s3Key: string
  }

  export type TaskAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    isPublic?: SortOrder
    etag?: SortOrder
    checksum?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TaskAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type TaskAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    isPublic?: SortOrder
    etag?: SortOrder
    checksum?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TaskAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    s3Key?: SortOrder
    s3Bucket?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    isPublic?: SortOrder
    etag?: SortOrder
    checksum?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TaskAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type LabelRelationFilter = {
    is?: LabelWhereInput
    isNot?: LabelWhereInput
  }

  export type TaskLabelTaskIdLabelIdCompoundUniqueInput = {
    taskId: string
    labelId: string
  }

  export type TaskLabelCountOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskLabelMaxOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskLabelMinOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    assignedAt?: SortOrder
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    colour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    colour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    colour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumWereYouInjuredFilter<$PrismaModel = never> = {
    equals?: $Enums.WereYouInjured | EnumWereYouInjuredFieldRefInput<$PrismaModel>
    in?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    notIn?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    not?: NestedEnumWereYouInjuredFilter<$PrismaModel> | $Enums.WereYouInjured
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type SourceNullableRelationFilter = {
    is?: SourceWhereInput | null
    isNot?: SourceWhereInput | null
  }

  export type ClaimListRelationFilter = {
    every?: ClaimWhereInput
    some?: ClaimWhereInput
    none?: ClaimWhereInput
  }

  export type VerifyNullableRelationFilter = {
    is?: VerifyWhereInput | null
    isNot?: VerifyWhereInput | null
  }

  export type ClaimListRelationFilter = {
    is?: ClaimListWhereInput
    isNot?: ClaimListWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type LabelListRelationFilter = {
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
  }

  export type ClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    injured?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phone2?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    isUnder18?: SortOrder
    fatherFirstName?: SortOrder
    fatherLastName?: SortOrder
    motherFirstName?: SortOrder
    motherLastName?: SortOrder
    mailingAddress1?: SortOrder
    mailingAddress2?: SortOrder
    mailingCity?: SortOrder
    mailingState?: SortOrder
    mailingZipCode?: SortOrder
    isPOBoxOrDifferentAddress?: SortOrder
    physicalAddress1?: SortOrder
    physicalAddress2?: SortOrder
    physicalCity?: SortOrder
    physicalState?: SortOrder
    physicalZipCode?: SortOrder
    maritalStatus?: SortOrder
    spouseFirstName?: SortOrder
    spouseLastName?: SortOrder
    spousePhone?: SortOrder
    employmentStatus?: SortOrder
    employerName?: SortOrder
    employerTitle?: SortOrder
    employmentType?: SortOrder
    pay?: SortOrder
    schoolName?: SortOrder
    expectedGraduationYear?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationCode?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claimlistId?: SortOrder
    accountSync?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    injured?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phone2?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    isUnder18?: SortOrder
    fatherFirstName?: SortOrder
    fatherLastName?: SortOrder
    motherFirstName?: SortOrder
    motherLastName?: SortOrder
    mailingAddress1?: SortOrder
    mailingAddress2?: SortOrder
    mailingCity?: SortOrder
    mailingState?: SortOrder
    mailingZipCode?: SortOrder
    isPOBoxOrDifferentAddress?: SortOrder
    physicalAddress1?: SortOrder
    physicalAddress2?: SortOrder
    physicalCity?: SortOrder
    physicalState?: SortOrder
    physicalZipCode?: SortOrder
    maritalStatus?: SortOrder
    spouseFirstName?: SortOrder
    spouseLastName?: SortOrder
    spousePhone?: SortOrder
    employmentStatus?: SortOrder
    employerName?: SortOrder
    employerTitle?: SortOrder
    employmentType?: SortOrder
    pay?: SortOrder
    schoolName?: SortOrder
    expectedGraduationYear?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationCode?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claimlistId?: SortOrder
    accountSync?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    injured?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phone2?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    isUnder18?: SortOrder
    fatherFirstName?: SortOrder
    fatherLastName?: SortOrder
    motherFirstName?: SortOrder
    motherLastName?: SortOrder
    mailingAddress1?: SortOrder
    mailingAddress2?: SortOrder
    mailingCity?: SortOrder
    mailingState?: SortOrder
    mailingZipCode?: SortOrder
    isPOBoxOrDifferentAddress?: SortOrder
    physicalAddress1?: SortOrder
    physicalAddress2?: SortOrder
    physicalCity?: SortOrder
    physicalState?: SortOrder
    physicalZipCode?: SortOrder
    maritalStatus?: SortOrder
    spouseFirstName?: SortOrder
    spouseLastName?: SortOrder
    spousePhone?: SortOrder
    employmentStatus?: SortOrder
    employerName?: SortOrder
    employerTitle?: SortOrder
    employmentType?: SortOrder
    pay?: SortOrder
    schoolName?: SortOrder
    expectedGraduationYear?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationCode?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claimlistId?: SortOrder
    accountSync?: SortOrder
  }

  export type EnumWereYouInjuredWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WereYouInjured | EnumWereYouInjuredFieldRefInput<$PrismaModel>
    in?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    notIn?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    not?: NestedEnumWereYouInjuredWithAggregatesFilter<$PrismaModel> | $Enums.WereYouInjured
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWereYouInjuredFilter<$PrismaModel>
    _max?: NestedEnumWereYouInjuredFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type VerifyCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    url?: SortOrder
    status?: SortOrder
    sessionId?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type VerifyMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    url?: SortOrder
    status?: SortOrder
    sessionId?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type VerifyMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    url?: SortOrder
    status?: SortOrder
    sessionId?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumClaimStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClaimStatusNullableFilter<$PrismaModel> | $Enums.ClaimStatus | null
  }

  export type EnumRelationshipNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Relationship | EnumRelationshipFieldRefInput<$PrismaModel> | null
    in?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipNullableFilter<$PrismaModel> | $Enums.Relationship | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RoleNullableRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type IncidentNullableRelationFilter = {
    is?: IncidentWhereInput | null
    isNot?: IncidentWhereInput | null
  }

  export type WitnessNullableRelationFilter = {
    is?: WitnessWhereInput | null
    isNot?: WitnessWhereInput | null
  }

  export type DefendantNullableRelationFilter = {
    is?: DefendantWhereInput | null
    isNot?: DefendantWhereInput | null
  }

  export type TreatmentAndInjuryNullableRelationFilter = {
    is?: TreatmentAndInjuryWhereInput | null
    isNot?: TreatmentAndInjuryWhereInput | null
  }

  export type QuestionnaireNullableRelationFilter = {
    is?: QuestionnaireWhereInput | null
    isNot?: QuestionnaireWhereInput | null
  }

  export type EnvelopListRelationFilter = {
    every?: EnvelopWhereInput
    some?: EnvelopWhereInput
    none?: EnvelopWhereInput
  }

  export type AccidentMediaListRelationFilter = {
    every?: AccidentMediaWhereInput
    some?: AccidentMediaWhereInput
    none?: AccidentMediaWhereInput
  }

  export type EnvelopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccidentMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    injured?: SortOrder
    relationship?: SortOrder
    otherRelationship?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    isOver65?: SortOrder
    receiveMedicare?: SortOrder
    assignedCaseManager?: SortOrder
    userId?: SortOrder
    clientRoleId?: SortOrder
    injuredPartyRoleId?: SortOrder
    incidentId?: SortOrder
    healthInsuranceProviderId?: SortOrder
    claimlistId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    injured?: SortOrder
    relationship?: SortOrder
    otherRelationship?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    isOver65?: SortOrder
    assignedCaseManager?: SortOrder
    userId?: SortOrder
    clientRoleId?: SortOrder
    injuredPartyRoleId?: SortOrder
    incidentId?: SortOrder
    healthInsuranceProviderId?: SortOrder
    claimlistId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    injured?: SortOrder
    relationship?: SortOrder
    otherRelationship?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    isOver65?: SortOrder
    assignedCaseManager?: SortOrder
    userId?: SortOrder
    clientRoleId?: SortOrder
    injuredPartyRoleId?: SortOrder
    incidentId?: SortOrder
    healthInsuranceProviderId?: SortOrder
    claimlistId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClaimStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClaimStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusNullableFilter<$PrismaModel>
  }

  export type EnumRelationshipNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Relationship | EnumRelationshipFieldRefInput<$PrismaModel> | null
    in?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipNullableWithAggregatesFilter<$PrismaModel> | $Enums.Relationship | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRelationshipNullableFilter<$PrismaModel>
    _max?: NestedEnumRelationshipNullableFilter<$PrismaModel>
  }

  export type ClaimRelationFilter = {
    is?: ClaimWhereInput
    isNot?: ClaimWhereInput
  }

  export type ProjectClaimProjectIdClaimIdCompoundUniqueInput = {
    projectId: string
    claimId: string
  }

  export type ProjectClaimCountOrderByAggregateInput = {
    projectId?: SortOrder
    claimId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectClaimMaxOrderByAggregateInput = {
    projectId?: SortOrder
    claimId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectClaimMinOrderByAggregateInput = {
    projectId?: SortOrder
    claimId?: SortOrder
    assignedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnvelopCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    claimId?: SortOrder
    submitterUrl?: SortOrder
    submitterId?: SortOrder
    submittedUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnvelopAvgOrderByAggregateInput = {
    submitterId?: SortOrder
  }

  export type EnvelopMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    claimId?: SortOrder
    submitterUrl?: SortOrder
    submitterId?: SortOrder
    submittedUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnvelopMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    claimId?: SortOrder
    submitterUrl?: SortOrder
    submitterId?: SortOrder
    submittedUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnvelopSumOrderByAggregateInput = {
    submitterId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enable?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ClaimListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enable?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ClaimListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enable?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    enable?: SortOrder
  }

  export type SourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    enable?: SortOrder
  }

  export type SourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    enable?: SortOrder
  }

  export type QuestionAnswerListRelationFilter = {
    every?: QuestionAnswerWhereInput
    some?: QuestionAnswerWhereInput
    none?: QuestionAnswerWhereInput
  }

  export type QuestionAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionnaireCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type QuestionnaireMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type QuestionnaireMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type QuestionRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type QuestionAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionnaireId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionnaireId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionnaireId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type ClaimListNullableRelationFilter = {
    is?: ClaimListWhereInput | null
    isNot?: ClaimListWhereInput | null
  }

  export type ChoiceListRelationFilter = {
    every?: ChoiceWhereInput
    some?: ChoiceWhereInput
    none?: ChoiceWhereInput
  }

  export type ChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    claimListId?: SortOrder
    type?: SortOrder
    enable?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    claimListId?: SortOrder
    type?: SortOrder
    enable?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    claimListId?: SortOrder
    type?: SortOrder
    enable?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type ChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    questionId?: SortOrder
  }

  export type ChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    questionId?: SortOrder
  }

  export type ChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    questionId?: SortOrder
  }

  export type DefendantDetailsListRelationFilter = {
    every?: DefendantDetailsWhereInput
    some?: DefendantDetailsWhereInput
    none?: DefendantDetailsWhereInput
  }

  export type DefendantDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DefendantCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type DefendantMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type DefendantMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type EnumDefendantRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.DefendantRole | EnumDefendantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDefendantRoleFilter<$PrismaModel> | $Enums.DefendantRole
  }

  export type EnumCollisionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CollisionType | EnumCollisionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCollisionTypeNullableFilter<$PrismaModel> | $Enums.CollisionType | null
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type DefendantRelationFilter = {
    is?: DefendantWhereInput
    isNot?: DefendantWhereInput
  }

  export type DefendantDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    defendantRole?: SortOrder
    defendantAccountId?: SortOrder
    defendantInsuranceCarrierId?: SortOrder
    insurancePolicyNumber?: SortOrder
    driverLicenseNumber?: SortOrder
    driverLicenseState?: SortOrder
    vehicleMake?: SortOrder
    vehicleModel?: SortOrder
    vehicleYear?: SortOrder
    vehicleColor?: SortOrder
    vehiclePlate?: SortOrder
    vehiclePosition?: SortOrder
    vehicleRegisteredState?: SortOrder
    collisionType?: SortOrder
    supervisorName?: SortOrder
    supervisorContact?: SortOrder
    client?: SortOrder
    groupId?: SortOrder
    sort?: SortOrder
    defendantId?: SortOrder
  }

  export type DefendantDetailsAvgOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type DefendantDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    defendantRole?: SortOrder
    defendantAccountId?: SortOrder
    defendantInsuranceCarrierId?: SortOrder
    insurancePolicyNumber?: SortOrder
    driverLicenseNumber?: SortOrder
    driverLicenseState?: SortOrder
    vehicleMake?: SortOrder
    vehicleModel?: SortOrder
    vehicleYear?: SortOrder
    vehicleColor?: SortOrder
    vehiclePlate?: SortOrder
    vehiclePosition?: SortOrder
    vehicleRegisteredState?: SortOrder
    collisionType?: SortOrder
    supervisorName?: SortOrder
    supervisorContact?: SortOrder
    client?: SortOrder
    groupId?: SortOrder
    sort?: SortOrder
    defendantId?: SortOrder
  }

  export type DefendantDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    defendantRole?: SortOrder
    defendantAccountId?: SortOrder
    defendantInsuranceCarrierId?: SortOrder
    insurancePolicyNumber?: SortOrder
    driverLicenseNumber?: SortOrder
    driverLicenseState?: SortOrder
    vehicleMake?: SortOrder
    vehicleModel?: SortOrder
    vehicleYear?: SortOrder
    vehicleColor?: SortOrder
    vehiclePlate?: SortOrder
    vehiclePosition?: SortOrder
    vehicleRegisteredState?: SortOrder
    collisionType?: SortOrder
    supervisorName?: SortOrder
    supervisorContact?: SortOrder
    client?: SortOrder
    groupId?: SortOrder
    sort?: SortOrder
    defendantId?: SortOrder
  }

  export type DefendantDetailsSumOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type EnumDefendantRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefendantRole | EnumDefendantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDefendantRoleWithAggregatesFilter<$PrismaModel> | $Enums.DefendantRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefendantRoleFilter<$PrismaModel>
    _max?: NestedEnumDefendantRoleFilter<$PrismaModel>
  }

  export type EnumCollisionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollisionType | EnumCollisionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCollisionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CollisionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCollisionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCollisionTypeNullableFilter<$PrismaModel>
  }

  export type TreatmentRelationFilter = {
    is?: TreatmentWhereInput
    isNot?: TreatmentWhereInput
  }

  export type TreatmentAndInjuryCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    treatmentId?: SortOrder
  }

  export type TreatmentAndInjuryMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    treatmentId?: SortOrder
  }

  export type TreatmentAndInjuryMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    treatmentId?: SortOrder
  }

  export type InjuryListRelationFilter = {
    every?: InjuryWhereInput
    some?: InjuryWhereInput
    none?: InjuryWhereInput
  }

  export type InjuryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreatmentCountOrderByAggregateInput = {
    id?: SortOrder
    takenHospital?: SortOrder
    isCurrentlyTreated?: SortOrder
    hospitalId?: SortOrder
    doctorId?: SortOrder
    admission?: SortOrder
    discharge?: SortOrder
    lastVisit?: SortOrder
    otherInjuries?: SortOrder
  }

  export type TreatmentMaxOrderByAggregateInput = {
    id?: SortOrder
    takenHospital?: SortOrder
    isCurrentlyTreated?: SortOrder
    hospitalId?: SortOrder
    doctorId?: SortOrder
    admission?: SortOrder
    discharge?: SortOrder
    lastVisit?: SortOrder
    otherInjuries?: SortOrder
  }

  export type TreatmentMinOrderByAggregateInput = {
    id?: SortOrder
    takenHospital?: SortOrder
    isCurrentlyTreated?: SortOrder
    hospitalId?: SortOrder
    doctorId?: SortOrder
    admission?: SortOrder
    discharge?: SortOrder
    lastVisit?: SortOrder
    otherInjuries?: SortOrder
  }

  export type EnumInjuryPointFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryPoint | EnumInjuryPointFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryPointFilter<$PrismaModel> | $Enums.InjuryPoint
  }

  export type EnumInjuryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryType | EnumInjuryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryTypeFilter<$PrismaModel> | $Enums.InjuryType
  }

  export type EnumInjurySideFilter<$PrismaModel = never> = {
    equals?: $Enums.InjurySide | EnumInjurySideFieldRefInput<$PrismaModel>
    in?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    not?: NestedEnumInjurySideFilter<$PrismaModel> | $Enums.InjurySide
  }

  export type InjuryCountOrderByAggregateInput = {
    id?: SortOrder
    injuryLocation?: SortOrder
    injury?: SortOrder
    injuryLocationSide?: SortOrder
    other?: SortOrder
    treatmentId?: SortOrder
  }

  export type InjuryMaxOrderByAggregateInput = {
    id?: SortOrder
    injuryLocation?: SortOrder
    injury?: SortOrder
    injuryLocationSide?: SortOrder
    other?: SortOrder
    treatmentId?: SortOrder
  }

  export type InjuryMinOrderByAggregateInput = {
    id?: SortOrder
    injuryLocation?: SortOrder
    injury?: SortOrder
    injuryLocationSide?: SortOrder
    other?: SortOrder
    treatmentId?: SortOrder
  }

  export type EnumInjuryPointWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryPoint | EnumInjuryPointFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryPointWithAggregatesFilter<$PrismaModel> | $Enums.InjuryPoint
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryPointFilter<$PrismaModel>
    _max?: NestedEnumInjuryPointFilter<$PrismaModel>
  }

  export type EnumInjuryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryType | EnumInjuryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryTypeWithAggregatesFilter<$PrismaModel> | $Enums.InjuryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryTypeFilter<$PrismaModel>
    _max?: NestedEnumInjuryTypeFilter<$PrismaModel>
  }

  export type EnumInjurySideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjurySide | EnumInjurySideFieldRefInput<$PrismaModel>
    in?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    not?: NestedEnumInjurySideWithAggregatesFilter<$PrismaModel> | $Enums.InjurySide
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjurySideFilter<$PrismaModel>
    _max?: NestedEnumInjurySideFilter<$PrismaModel>
  }

  export type AccidentMediaCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    thumbnail?: SortOrder
    claimId?: SortOrder
  }

  export type AccidentMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    thumbnail?: SortOrder
    claimId?: SortOrder
  }

  export type AccidentMediaMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    thumbnail?: SortOrder
    claimId?: SortOrder
  }

  export type EnumBusOrVehicleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BusOrVehicle | EnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusOrVehicleNullableFilter<$PrismaModel> | $Enums.BusOrVehicle | null
  }

  export type EnumTransportTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TransportType | EnumTransportTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransportTypeNullableFilter<$PrismaModel> | $Enums.TransportType | null
  }

  export type EnumPropertyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableFilter<$PrismaModel> | $Enums.PropertyType | null
  }

  export type SubAccountNullableRelationFilter = {
    is?: SubAccountWhereInput | null
    isNot?: SubAccountWhereInput | null
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleRole?: SortOrder
    vehicleCount?: SortOrder
    busOrVehicle?: SortOrder
    transportType?: SortOrder
    rideShareCompany?: SortOrder
    rideShareOtherName?: SortOrder
    propertyType?: SortOrder
    datetime?: SortOrder
    location?: SortOrder
    workRelated?: SortOrder
    description?: SortOrder
    policeReportCompleted?: SortOrder
    policeStationId?: SortOrder
    policeOfficerId?: SortOrder
    reportCompleted?: SortOrder
    reportNumber?: SortOrder
    supportingDocument?: SortOrder
    lostEarning?: SortOrder
    amountLoss?: SortOrder
    timeLoss?: SortOrder
    witness?: SortOrder
    priorRepresentation?: SortOrder
    priorRepresentationReason?: SortOrder
    lawfirmId?: SortOrder
    attorneyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentAvgOrderByAggregateInput = {
    vehicleCount?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleRole?: SortOrder
    vehicleCount?: SortOrder
    busOrVehicle?: SortOrder
    transportType?: SortOrder
    rideShareCompany?: SortOrder
    rideShareOtherName?: SortOrder
    propertyType?: SortOrder
    datetime?: SortOrder
    location?: SortOrder
    workRelated?: SortOrder
    description?: SortOrder
    policeReportCompleted?: SortOrder
    policeStationId?: SortOrder
    policeOfficerId?: SortOrder
    reportCompleted?: SortOrder
    reportNumber?: SortOrder
    supportingDocument?: SortOrder
    lostEarning?: SortOrder
    amountLoss?: SortOrder
    timeLoss?: SortOrder
    witness?: SortOrder
    priorRepresentation?: SortOrder
    priorRepresentationReason?: SortOrder
    lawfirmId?: SortOrder
    attorneyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleRole?: SortOrder
    vehicleCount?: SortOrder
    busOrVehicle?: SortOrder
    transportType?: SortOrder
    rideShareCompany?: SortOrder
    rideShareOtherName?: SortOrder
    propertyType?: SortOrder
    datetime?: SortOrder
    location?: SortOrder
    workRelated?: SortOrder
    description?: SortOrder
    policeReportCompleted?: SortOrder
    policeStationId?: SortOrder
    policeOfficerId?: SortOrder
    reportCompleted?: SortOrder
    reportNumber?: SortOrder
    supportingDocument?: SortOrder
    lostEarning?: SortOrder
    amountLoss?: SortOrder
    timeLoss?: SortOrder
    witness?: SortOrder
    priorRepresentation?: SortOrder
    priorRepresentationReason?: SortOrder
    lawfirmId?: SortOrder
    attorneyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentSumOrderByAggregateInput = {
    vehicleCount?: SortOrder
  }

  export type EnumBusOrVehicleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusOrVehicle | EnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusOrVehicleNullableWithAggregatesFilter<$PrismaModel> | $Enums.BusOrVehicle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBusOrVehicleNullableFilter<$PrismaModel>
    _max?: NestedEnumBusOrVehicleNullableFilter<$PrismaModel>
  }

  export type EnumTransportTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransportType | EnumTransportTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransportTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TransportType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTransportTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTransportTypeNullableFilter<$PrismaModel>
  }

  export type EnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
  }

  export type WitnessDetailsListRelationFilter = {
    every?: WitnessDetailsWhereInput
    some?: WitnessDetailsWhereInput
    none?: WitnessDetailsWhereInput
  }

  export type WitnessDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WitnessCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type WitnessMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type WitnessMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
  }

  export type WitnessRelationFilter = {
    is?: WitnessWhereInput
    isNot?: WitnessWhereInput
  }

  export type WitnessDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    witnessId?: SortOrder
    roleId?: SortOrder
  }

  export type WitnessDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    witnessId?: SortOrder
    roleId?: SortOrder
  }

  export type WitnessDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    witnessId?: SortOrder
    roleId?: SortOrder
  }

  export type AccountNullableRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type RoleTypeRelationFilter = {
    is?: RoleTypeWhereInput
    isNot?: RoleTypeWhereInput
  }

  export type WitnessDetailsNullableRelationFilter = {
    is?: WitnessDetailsWhereInput | null
    isNot?: WitnessDetailsWhereInput | null
  }

  export type TreatmentListRelationFilter = {
    every?: TreatmentWhereInput
    some?: TreatmentWhereInput
    none?: TreatmentWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type TreatmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    roletypeId?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    roletypeId?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    roletypeId?: SortOrder
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleTypeCountOrderByAggregateInput = {
    id?: SortOrder
    roleType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    enable?: SortOrder
  }

  export type RoleTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    roleType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    enable?: SortOrder
  }

  export type RoleTypeMinOrderByAggregateInput = {
    id?: SortOrder
    roleType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    enable?: SortOrder
  }

  export type SubAccountListRelationFilter = {
    every?: SubAccountWhereInput
    some?: SubAccountWhereInput
    none?: SubAccountWhereInput
  }

  export type SubAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    fax?: SortOrder
    mailingAddress?: SortOrder
    mailingAddressBuilding?: SortOrder
    mailingCity?: SortOrder
    mailingState?: SortOrder
    mailingZipCode?: SortOrder
    billingAddressStreet?: SortOrder
    billingAddressBuilding?: SortOrder
    billingAddressCity?: SortOrder
    billingAddressState?: SortOrder
    billingAddressPostalCode?: SortOrder
    website?: SortOrder
    enable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    fax?: SortOrder
    mailingAddress?: SortOrder
    mailingAddressBuilding?: SortOrder
    mailingCity?: SortOrder
    mailingState?: SortOrder
    mailingZipCode?: SortOrder
    billingAddressStreet?: SortOrder
    billingAddressBuilding?: SortOrder
    billingAddressCity?: SortOrder
    billingAddressState?: SortOrder
    billingAddressPostalCode?: SortOrder
    website?: SortOrder
    enable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    fax?: SortOrder
    mailingAddress?: SortOrder
    mailingAddressBuilding?: SortOrder
    mailingCity?: SortOrder
    mailingState?: SortOrder
    mailingZipCode?: SortOrder
    billingAddressStreet?: SortOrder
    billingAddressBuilding?: SortOrder
    billingAddressCity?: SortOrder
    billingAddressState?: SortOrder
    billingAddressPostalCode?: SortOrder
    website?: SortOrder
    enable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubAccountCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    accountId?: SortOrder
    enable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    accountId?: SortOrder
    enable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubAccountMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    accountId?: SortOrder
    enable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarCountOrderByAggregateInput = {
    id?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
  }

  export type CarMaxOrderByAggregateInput = {
    id?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
  }

  export type CarMinOrderByAggregateInput = {
    id?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
  }

  export type UserCreateNestedOneWithoutProjectsOwnedInput = {
    create?: XOR<UserCreateWithoutProjectsOwnedInput, UserUncheckedCreateWithoutProjectsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsOwnedInput
    connect?: UserWhereUniqueInput
  }

  export type BoardCreateNestedManyWithoutProjectInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type ProjectClaimCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectClaimCreateWithoutProjectInput, ProjectClaimUncheckedCreateWithoutProjectInput> | ProjectClaimCreateWithoutProjectInput[] | ProjectClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutProjectInput | ProjectClaimCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectClaimCreateManyProjectInputEnvelope
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
  }

  export type ProjectAccountCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectAccountCreateWithoutProjectInput, ProjectAccountUncheckedCreateWithoutProjectInput> | ProjectAccountCreateWithoutProjectInput[] | ProjectAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutProjectInput | ProjectAccountCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectAccountCreateManyProjectInputEnvelope
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
  }

  export type ProjectUserCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
  }

  export type BoardUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type ProjectClaimUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectClaimCreateWithoutProjectInput, ProjectClaimUncheckedCreateWithoutProjectInput> | ProjectClaimCreateWithoutProjectInput[] | ProjectClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutProjectInput | ProjectClaimCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectClaimCreateManyProjectInputEnvelope
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
  }

  export type ProjectAccountUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectAccountCreateWithoutProjectInput, ProjectAccountUncheckedCreateWithoutProjectInput> | ProjectAccountCreateWithoutProjectInput[] | ProjectAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutProjectInput | ProjectAccountCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectAccountCreateManyProjectInputEnvelope
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
  }

  export type ProjectUserUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutProjectsOwnedNestedInput = {
    create?: XOR<UserCreateWithoutProjectsOwnedInput, UserUncheckedCreateWithoutProjectsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsOwnedInput
    upsert?: UserUpsertWithoutProjectsOwnedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsOwnedInput, UserUpdateWithoutProjectsOwnedInput>, UserUncheckedUpdateWithoutProjectsOwnedInput>
  }

  export type BoardUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutProjectInput | BoardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutProjectInput | BoardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutProjectInput | BoardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type ProjectClaimUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectClaimCreateWithoutProjectInput, ProjectClaimUncheckedCreateWithoutProjectInput> | ProjectClaimCreateWithoutProjectInput[] | ProjectClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutProjectInput | ProjectClaimCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectClaimUpsertWithWhereUniqueWithoutProjectInput | ProjectClaimUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectClaimCreateManyProjectInputEnvelope
    set?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    disconnect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    delete?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    update?: ProjectClaimUpdateWithWhereUniqueWithoutProjectInput | ProjectClaimUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectClaimUpdateManyWithWhereWithoutProjectInput | ProjectClaimUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectClaimScalarWhereInput | ProjectClaimScalarWhereInput[]
  }

  export type ProjectAccountUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectAccountCreateWithoutProjectInput, ProjectAccountUncheckedCreateWithoutProjectInput> | ProjectAccountCreateWithoutProjectInput[] | ProjectAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutProjectInput | ProjectAccountCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectAccountUpsertWithWhereUniqueWithoutProjectInput | ProjectAccountUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectAccountCreateManyProjectInputEnvelope
    set?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    disconnect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    delete?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    update?: ProjectAccountUpdateWithWhereUniqueWithoutProjectInput | ProjectAccountUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectAccountUpdateManyWithWhereWithoutProjectInput | ProjectAccountUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectAccountScalarWhereInput | ProjectAccountScalarWhereInput[]
  }

  export type ProjectUserUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUserUpsertWithWhereUniqueWithoutProjectInput | ProjectUserUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    set?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    disconnect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    delete?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    update?: ProjectUserUpdateWithWhereUniqueWithoutProjectInput | ProjectUserUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUserUpdateManyWithWhereWithoutProjectInput | ProjectUserUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
  }

  export type BoardUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutProjectInput | BoardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutProjectInput | BoardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutProjectInput | BoardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type ProjectClaimUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectClaimCreateWithoutProjectInput, ProjectClaimUncheckedCreateWithoutProjectInput> | ProjectClaimCreateWithoutProjectInput[] | ProjectClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutProjectInput | ProjectClaimCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectClaimUpsertWithWhereUniqueWithoutProjectInput | ProjectClaimUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectClaimCreateManyProjectInputEnvelope
    set?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    disconnect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    delete?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    update?: ProjectClaimUpdateWithWhereUniqueWithoutProjectInput | ProjectClaimUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectClaimUpdateManyWithWhereWithoutProjectInput | ProjectClaimUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectClaimScalarWhereInput | ProjectClaimScalarWhereInput[]
  }

  export type ProjectAccountUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectAccountCreateWithoutProjectInput, ProjectAccountUncheckedCreateWithoutProjectInput> | ProjectAccountCreateWithoutProjectInput[] | ProjectAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutProjectInput | ProjectAccountCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectAccountUpsertWithWhereUniqueWithoutProjectInput | ProjectAccountUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectAccountCreateManyProjectInputEnvelope
    set?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    disconnect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    delete?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    update?: ProjectAccountUpdateWithWhereUniqueWithoutProjectInput | ProjectAccountUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectAccountUpdateManyWithWhereWithoutProjectInput | ProjectAccountUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectAccountScalarWhereInput | ProjectAccountScalarWhereInput[]
  }

  export type ProjectUserUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUserUpsertWithWhereUniqueWithoutProjectInput | ProjectUserUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    set?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    disconnect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    delete?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    update?: ProjectUserUpdateWithWhereUniqueWithoutProjectInput | ProjectUserUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUserUpdateManyWithWhereWithoutProjectInput | ProjectUserUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectUsersInput = {
    create?: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectUsersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectAssignmentsInput = {
    create?: XOR<UserCreateWithoutProjectAssignmentsInput, UserUncheckedCreateWithoutProjectAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectUsersNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectUsersInput
    upsert?: ProjectUpsertWithoutProjectUsersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectUsersInput, ProjectUpdateWithoutProjectUsersInput>, ProjectUncheckedUpdateWithoutProjectUsersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutProjectAssignmentsInput, UserUncheckedCreateWithoutProjectAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectAssignmentsInput
    upsert?: UserUpsertWithoutProjectAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectAssignmentsInput, UserUpdateWithoutProjectAssignmentsInput>, UserUncheckedUpdateWithoutProjectAssignmentsInput>
  }

  export type ProjectCreateNestedOneWithoutProjectAccountsInput = {
    create?: XOR<ProjectCreateWithoutProjectAccountsInput, ProjectUncheckedCreateWithoutProjectAccountsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectAccountsInput
    connect?: ProjectWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutProjectAccountsInput = {
    create?: XOR<AccountCreateWithoutProjectAccountsInput, AccountUncheckedCreateWithoutProjectAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProjectAccountsInput
    connect?: AccountWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectAccountsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectAccountsInput, ProjectUncheckedCreateWithoutProjectAccountsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectAccountsInput
    upsert?: ProjectUpsertWithoutProjectAccountsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectAccountsInput, ProjectUpdateWithoutProjectAccountsInput>, ProjectUncheckedUpdateWithoutProjectAccountsInput>
  }

  export type AccountUpdateOneRequiredWithoutProjectAccountsNestedInput = {
    create?: XOR<AccountCreateWithoutProjectAccountsInput, AccountUncheckedCreateWithoutProjectAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProjectAccountsInput
    upsert?: AccountUpsertWithoutProjectAccountsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutProjectAccountsInput, AccountUpdateWithoutProjectAccountsInput>, AccountUncheckedUpdateWithoutProjectAccountsInput>
  }

  export type ProjectCreateNestedOneWithoutBoardsInput = {
    create?: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBoardsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ColumnCreateNestedManyWithoutBoardInput = {
    create?: XOR<ColumnCreateWithoutBoardInput, ColumnUncheckedCreateWithoutBoardInput> | ColumnCreateWithoutBoardInput[] | ColumnUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutBoardInput | ColumnCreateOrConnectWithoutBoardInput[]
    createMany?: ColumnCreateManyBoardInputEnvelope
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
  }

  export type ColumnUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<ColumnCreateWithoutBoardInput, ColumnUncheckedCreateWithoutBoardInput> | ColumnCreateWithoutBoardInput[] | ColumnUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutBoardInput | ColumnCreateOrConnectWithoutBoardInput[]
    createMany?: ColumnCreateManyBoardInputEnvelope
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutBoardsNestedInput = {
    create?: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBoardsInput
    upsert?: ProjectUpsertWithoutBoardsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBoardsInput, ProjectUpdateWithoutBoardsInput>, ProjectUncheckedUpdateWithoutBoardsInput>
  }

  export type ColumnUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ColumnCreateWithoutBoardInput, ColumnUncheckedCreateWithoutBoardInput> | ColumnCreateWithoutBoardInput[] | ColumnUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutBoardInput | ColumnCreateOrConnectWithoutBoardInput[]
    upsert?: ColumnUpsertWithWhereUniqueWithoutBoardInput | ColumnUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ColumnCreateManyBoardInputEnvelope
    set?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    disconnect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    delete?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    update?: ColumnUpdateWithWhereUniqueWithoutBoardInput | ColumnUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ColumnUpdateManyWithWhereWithoutBoardInput | ColumnUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
  }

  export type ColumnUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ColumnCreateWithoutBoardInput, ColumnUncheckedCreateWithoutBoardInput> | ColumnCreateWithoutBoardInput[] | ColumnUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutBoardInput | ColumnCreateOrConnectWithoutBoardInput[]
    upsert?: ColumnUpsertWithWhereUniqueWithoutBoardInput | ColumnUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ColumnCreateManyBoardInputEnvelope
    set?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    disconnect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    delete?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    update?: ColumnUpdateWithWhereUniqueWithoutBoardInput | ColumnUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ColumnUpdateManyWithWhereWithoutBoardInput | ColumnUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutColumnsInput = {
    create?: XOR<BoardCreateWithoutColumnsInput, BoardUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutColumnsInput
    connect?: BoardWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutColumnInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutColumnInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoardUpdateOneRequiredWithoutColumnsNestedInput = {
    create?: XOR<BoardCreateWithoutColumnsInput, BoardUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutColumnsInput
    upsert?: BoardUpsertWithoutColumnsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutColumnsInput, BoardUpdateWithoutColumnsInput>, BoardUncheckedUpdateWithoutColumnsInput>
  }

  export type TaskUpdateManyWithoutColumnNestedInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutColumnInput | TaskUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutColumnInput | TaskUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutColumnInput | TaskUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutColumnNestedInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutColumnInput | TaskUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutColumnInput | TaskUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutColumnInput | TaskUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ColumnCreateNestedOneWithoutTasksInput = {
    create?: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutTasksInput
    connect?: ColumnWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksCreatedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type TaskAccountCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAccountCreateWithoutTaskInput, TaskAccountUncheckedCreateWithoutTaskInput> | TaskAccountCreateWithoutTaskInput[] | TaskAccountUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutTaskInput | TaskAccountCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAccountCreateManyTaskInputEnvelope
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
  }

  export type TaskAssigneeCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type TaskCommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type TaskAttachmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type TaskLabelCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type ClaimCreateNestedOneWithoutTasksInput = {
    create?: XOR<ClaimCreateWithoutTasksInput, ClaimUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutTasksInput
    connect?: ClaimWhereUniqueInput
  }

  export type TaskAccountUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAccountCreateWithoutTaskInput, TaskAccountUncheckedCreateWithoutTaskInput> | TaskAccountCreateWithoutTaskInput[] | TaskAccountUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutTaskInput | TaskAccountCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAccountCreateManyTaskInputEnvelope
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
  }

  export type TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type TaskCommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type TaskLabelUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type EnumTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TaskPriority
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ColumnUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutTasksInput
    upsert?: ColumnUpsertWithoutTasksInput
    connect?: ColumnWhereUniqueInput
    update?: XOR<XOR<ColumnUpdateToOneWithWhereWithoutTasksInput, ColumnUpdateWithoutTasksInput>, ColumnUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneRequiredWithoutTasksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    upsert?: UserUpsertWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksCreatedInput, UserUpdateWithoutTasksCreatedInput>, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type TaskAccountUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAccountCreateWithoutTaskInput, TaskAccountUncheckedCreateWithoutTaskInput> | TaskAccountCreateWithoutTaskInput[] | TaskAccountUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutTaskInput | TaskAccountCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAccountUpsertWithWhereUniqueWithoutTaskInput | TaskAccountUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAccountCreateManyTaskInputEnvelope
    set?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    disconnect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    delete?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    update?: TaskAccountUpdateWithWhereUniqueWithoutTaskInput | TaskAccountUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAccountUpdateManyWithWhereWithoutTaskInput | TaskAccountUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAccountScalarWhereInput | TaskAccountScalarWhereInput[]
  }

  export type TaskAssigneeUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type TaskCommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutTaskInput | TaskCommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutTaskInput | TaskCommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutTaskInput | TaskCommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskAttachmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutTaskInput | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskLabelUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutTaskInput | TaskLabelUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutTaskInput | TaskLabelUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutTaskInput | TaskLabelUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type ClaimUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ClaimCreateWithoutTasksInput, ClaimUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutTasksInput
    upsert?: ClaimUpsertWithoutTasksInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutTasksInput, ClaimUpdateWithoutTasksInput>, ClaimUncheckedUpdateWithoutTasksInput>
  }

  export type TaskAccountUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAccountCreateWithoutTaskInput, TaskAccountUncheckedCreateWithoutTaskInput> | TaskAccountCreateWithoutTaskInput[] | TaskAccountUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutTaskInput | TaskAccountCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAccountUpsertWithWhereUniqueWithoutTaskInput | TaskAccountUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAccountCreateManyTaskInputEnvelope
    set?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    disconnect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    delete?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    update?: TaskAccountUpdateWithWhereUniqueWithoutTaskInput | TaskAccountUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAccountUpdateManyWithWhereWithoutTaskInput | TaskAccountUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAccountScalarWhereInput | TaskAccountScalarWhereInput[]
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type TaskCommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutTaskInput | TaskCommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutTaskInput | TaskCommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutTaskInput | TaskCommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutTaskInput | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskLabelUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutTaskInput | TaskLabelUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutTaskInput | TaskLabelUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutTaskInput | TaskLabelUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutTaskAccountsInput = {
    create?: XOR<TaskCreateWithoutTaskAccountsInput, TaskUncheckedCreateWithoutTaskAccountsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskAccountsInput
    connect?: TaskWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTaskAccountsInput = {
    create?: XOR<AccountCreateWithoutTaskAccountsInput, AccountUncheckedCreateWithoutTaskAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTaskAccountsInput
    connect?: AccountWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTaskAccountsNestedInput = {
    create?: XOR<TaskCreateWithoutTaskAccountsInput, TaskUncheckedCreateWithoutTaskAccountsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskAccountsInput
    upsert?: TaskUpsertWithoutTaskAccountsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskAccountsInput, TaskUpdateWithoutTaskAccountsInput>, TaskUncheckedUpdateWithoutTaskAccountsInput>
  }

  export type AccountUpdateOneRequiredWithoutTaskAccountsNestedInput = {
    create?: XOR<AccountCreateWithoutTaskAccountsInput, AccountUncheckedCreateWithoutTaskAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTaskAccountsInput
    upsert?: AccountUpsertWithoutTaskAccountsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTaskAccountsInput, AccountUpdateWithoutTaskAccountsInput>, AccountUncheckedUpdateWithoutTaskAccountsInput>
  }

  export type TaskCreateNestedOneWithoutTaskAssigneesInput = {
    create?: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskAssigneesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskAssignmentsInput = {
    create?: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTaskAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskAssigneesInput
    upsert?: TaskUpsertWithoutTaskAssigneesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskAssigneesInput, TaskUpdateWithoutTaskAssigneesInput>, TaskUncheckedUpdateWithoutTaskAssigneesInput>
  }

  export type UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssignmentsInput
    upsert?: UserUpsertWithoutTaskAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskAssignmentsInput, UserUpdateWithoutTaskAssignmentsInput>, UserUncheckedUpdateWithoutTaskAssignmentsInput>
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskCommentsInput = {
    create?: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTaskCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCommentsInput
    upsert?: UserUpsertWithoutTaskCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskCommentsInput, UserUpdateWithoutTaskCommentsInput>, UserUncheckedUpdateWithoutTaskCommentsInput>
  }

  export type TaskCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskAttachmentsInput = {
    create?: XOR<UserCreateWithoutTaskAttachmentsInput, UserUncheckedCreateWithoutTaskAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAttachmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    upsert?: TaskUpsertWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAttachmentsInput, TaskUpdateWithoutAttachmentsInput>, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneRequiredWithoutTaskAttachmentsNestedInput = {
    create?: XOR<UserCreateWithoutTaskAttachmentsInput, UserUncheckedCreateWithoutTaskAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAttachmentsInput
    upsert?: UserUpsertWithoutTaskAttachmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskAttachmentsInput, UserUpdateWithoutTaskAttachmentsInput>, UserUncheckedUpdateWithoutTaskAttachmentsInput>
  }

  export type TaskCreateNestedOneWithoutLabelsInput = {
    create?: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLabelsInput
    connect?: TaskWhereUniqueInput
  }

  export type LabelCreateNestedOneWithoutTaskLabelsInput = {
    create?: XOR<LabelCreateWithoutTaskLabelsInput, LabelUncheckedCreateWithoutTaskLabelsInput>
    connectOrCreate?: LabelCreateOrConnectWithoutTaskLabelsInput
    connect?: LabelWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLabelsInput
    upsert?: TaskUpsertWithoutLabelsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutLabelsInput, TaskUpdateWithoutLabelsInput>, TaskUncheckedUpdateWithoutLabelsInput>
  }

  export type LabelUpdateOneRequiredWithoutTaskLabelsNestedInput = {
    create?: XOR<LabelCreateWithoutTaskLabelsInput, LabelUncheckedCreateWithoutTaskLabelsInput>
    connectOrCreate?: LabelCreateOrConnectWithoutTaskLabelsInput
    upsert?: LabelUpsertWithoutTaskLabelsInput
    connect?: LabelWhereUniqueInput
    update?: XOR<XOR<LabelUpdateToOneWithWhereWithoutTaskLabelsInput, LabelUpdateWithoutTaskLabelsInput>, LabelUncheckedUpdateWithoutTaskLabelsInput>
  }

  export type UserCreateNestedOneWithoutLabelsCreatedInput = {
    create?: XOR<UserCreateWithoutLabelsCreatedInput, UserUncheckedCreateWithoutLabelsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabelsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type TaskLabelCreateNestedManyWithoutLabelInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type TaskLabelUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLabelsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutLabelsCreatedInput, UserUncheckedCreateWithoutLabelsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabelsCreatedInput
    upsert?: UserUpsertWithoutLabelsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabelsCreatedInput, UserUpdateWithoutLabelsCreatedInput>, UserUncheckedUpdateWithoutLabelsCreatedInput>
  }

  export type TaskLabelUpdateManyWithoutLabelNestedInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutLabelInput | TaskLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutLabelInput | TaskLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutLabelInput | TaskLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type TaskLabelUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutLabelInput | TaskLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutLabelInput | TaskLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutLabelInput | TaskLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type SourceCreateNestedOneWithoutUserInput = {
    create?: XOR<SourceCreateWithoutUserInput, SourceUncheckedCreateWithoutUserInput>
    connectOrCreate?: SourceCreateOrConnectWithoutUserInput
    connect?: SourceWhereUniqueInput
  }

  export type ClaimCreateNestedManyWithoutUserInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type VerifyCreateNestedOneWithoutUserInput = {
    create?: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerifyCreateOrConnectWithoutUserInput
    connect?: VerifyWhereUniqueInput
  }

  export type ClaimListCreateNestedOneWithoutUserInput = {
    create?: XOR<ClaimListCreateWithoutUserInput, ClaimListUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClaimListCreateOrConnectWithoutUserInput
    connect?: ClaimListWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskAssigneeCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type ProjectUserCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectUserCreateWithoutUserInput, ProjectUserUncheckedCreateWithoutUserInput> | ProjectUserCreateWithoutUserInput[] | ProjectUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutUserInput | ProjectUserCreateOrConnectWithoutUserInput[]
    createMany?: ProjectUserCreateManyUserInputEnvelope
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
  }

  export type TaskCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type LabelCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LabelCreateWithoutCreatedByInput, LabelUncheckedCreateWithoutCreatedByInput> | LabelCreateWithoutCreatedByInput[] | LabelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCreatedByInput | LabelCreateOrConnectWithoutCreatedByInput[]
    createMany?: LabelCreateManyCreatedByInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type TaskAttachmentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TaskAttachmentCreateWithoutUploadedByInput, TaskAttachmentUncheckedCreateWithoutUploadedByInput> | TaskAttachmentCreateWithoutUploadedByInput[] | TaskAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutUploadedByInput | TaskAttachmentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TaskAttachmentCreateManyUploadedByInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type VerifyUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerifyCreateOrConnectWithoutUserInput
    connect?: VerifyWhereUniqueInput
  }

  export type ProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskAssigneeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type ProjectUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectUserCreateWithoutUserInput, ProjectUserUncheckedCreateWithoutUserInput> | ProjectUserCreateWithoutUserInput[] | ProjectUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutUserInput | ProjectUserCreateOrConnectWithoutUserInput[]
    createMany?: ProjectUserCreateManyUserInputEnvelope
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
  }

  export type TaskCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type LabelUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LabelCreateWithoutCreatedByInput, LabelUncheckedCreateWithoutCreatedByInput> | LabelCreateWithoutCreatedByInput[] | LabelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCreatedByInput | LabelCreateOrConnectWithoutCreatedByInput[]
    createMany?: LabelCreateManyCreatedByInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TaskAttachmentCreateWithoutUploadedByInput, TaskAttachmentUncheckedCreateWithoutUploadedByInput> | TaskAttachmentCreateWithoutUploadedByInput[] | TaskAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutUploadedByInput | TaskAttachmentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TaskAttachmentCreateManyUploadedByInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type EnumWereYouInjuredFieldUpdateOperationsInput = {
    set?: $Enums.WereYouInjured
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type SourceUpdateOneWithoutUserNestedInput = {
    create?: XOR<SourceCreateWithoutUserInput, SourceUncheckedCreateWithoutUserInput>
    connectOrCreate?: SourceCreateOrConnectWithoutUserInput
    upsert?: SourceUpsertWithoutUserInput
    disconnect?: SourceWhereInput | boolean
    delete?: SourceWhereInput | boolean
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutUserInput, SourceUpdateWithoutUserInput>, SourceUncheckedUpdateWithoutUserInput>
  }

  export type ClaimUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutUserInput | ClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutUserInput | ClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutUserInput | ClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type VerifyUpdateOneWithoutUserNestedInput = {
    create?: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerifyCreateOrConnectWithoutUserInput
    upsert?: VerifyUpsertWithoutUserInput
    disconnect?: VerifyWhereInput | boolean
    delete?: VerifyWhereInput | boolean
    connect?: VerifyWhereUniqueInput
    update?: XOR<XOR<VerifyUpdateToOneWithWhereWithoutUserInput, VerifyUpdateWithoutUserInput>, VerifyUncheckedUpdateWithoutUserInput>
  }

  export type ClaimListUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<ClaimListCreateWithoutUserInput, ClaimListUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClaimListCreateOrConnectWithoutUserInput
    upsert?: ClaimListUpsertWithoutUserInput
    connect?: ClaimListWhereUniqueInput
    update?: XOR<XOR<ClaimListUpdateToOneWithWhereWithoutUserInput, ClaimListUpdateWithoutUserInput>, ClaimListUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssigneeUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutUserInput | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutUserInput | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutUserInput | TaskAssigneeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type ProjectUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectUserCreateWithoutUserInput, ProjectUserUncheckedCreateWithoutUserInput> | ProjectUserCreateWithoutUserInput[] | ProjectUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutUserInput | ProjectUserCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUserUpsertWithWhereUniqueWithoutUserInput | ProjectUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectUserCreateManyUserInputEnvelope
    set?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    disconnect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    delete?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    update?: ProjectUserUpdateWithWhereUniqueWithoutUserInput | ProjectUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUserUpdateManyWithWhereWithoutUserInput | ProjectUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
  }

  export type TaskCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutUserInput | TaskCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutUserInput | TaskCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutUserInput | TaskCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type LabelUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LabelCreateWithoutCreatedByInput, LabelUncheckedCreateWithoutCreatedByInput> | LabelCreateWithoutCreatedByInput[] | LabelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCreatedByInput | LabelCreateOrConnectWithoutCreatedByInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutCreatedByInput | LabelUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LabelCreateManyCreatedByInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutCreatedByInput | LabelUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutCreatedByInput | LabelUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type TaskAttachmentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutUploadedByInput, TaskAttachmentUncheckedCreateWithoutUploadedByInput> | TaskAttachmentCreateWithoutUploadedByInput[] | TaskAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutUploadedByInput | TaskAttachmentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutUploadedByInput | TaskAttachmentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TaskAttachmentCreateManyUploadedByInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutUploadedByInput | TaskAttachmentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutUploadedByInput | TaskAttachmentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutUserInput | ClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutUserInput | ClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutUserInput | ClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type VerifyUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
    connectOrCreate?: VerifyCreateOrConnectWithoutUserInput
    upsert?: VerifyUpsertWithoutUserInput
    disconnect?: VerifyWhereInput | boolean
    delete?: VerifyWhereInput | boolean
    connect?: VerifyWhereUniqueInput
    update?: XOR<XOR<VerifyUpdateToOneWithWhereWithoutUserInput, VerifyUpdateWithoutUserInput>, VerifyUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutUserInput | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutUserInput | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutUserInput | TaskAssigneeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type ProjectUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectUserCreateWithoutUserInput, ProjectUserUncheckedCreateWithoutUserInput> | ProjectUserCreateWithoutUserInput[] | ProjectUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutUserInput | ProjectUserCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUserUpsertWithWhereUniqueWithoutUserInput | ProjectUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectUserCreateManyUserInputEnvelope
    set?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    disconnect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    delete?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    update?: ProjectUserUpdateWithWhereUniqueWithoutUserInput | ProjectUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUserUpdateManyWithWhereWithoutUserInput | ProjectUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
  }

  export type TaskCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutUserInput | TaskCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutUserInput | TaskCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutUserInput | TaskCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type LabelUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LabelCreateWithoutCreatedByInput, LabelUncheckedCreateWithoutCreatedByInput> | LabelCreateWithoutCreatedByInput[] | LabelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCreatedByInput | LabelCreateOrConnectWithoutCreatedByInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutCreatedByInput | LabelUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LabelCreateManyCreatedByInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutCreatedByInput | LabelUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutCreatedByInput | LabelUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutUploadedByInput, TaskAttachmentUncheckedCreateWithoutUploadedByInput> | TaskAttachmentCreateWithoutUploadedByInput[] | TaskAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutUploadedByInput | TaskAttachmentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutUploadedByInput | TaskAttachmentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TaskAttachmentCreateManyUploadedByInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutUploadedByInput | TaskAttachmentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutUploadedByInput | TaskAttachmentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVerifyInput = {
    create?: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifyInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVerifyNestedInput = {
    create?: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifyInput
    upsert?: UserUpsertWithoutVerifyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifyInput, UserUpdateWithoutVerifyInput>, UserUncheckedUpdateWithoutVerifyInput>
  }

  export type ClaimCreatereceiveMedicareInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutClaimsInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutClientClaimsInput = {
    create?: XOR<RoleCreateWithoutClientClaimsInput, RoleUncheckedCreateWithoutClientClaimsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutClientClaimsInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutInjuredPartyClaimsInput = {
    create?: XOR<RoleCreateWithoutInjuredPartyClaimsInput, RoleUncheckedCreateWithoutInjuredPartyClaimsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutInjuredPartyClaimsInput
    connect?: RoleWhereUniqueInput
  }

  export type IncidentCreateNestedOneWithoutClaimInput = {
    create?: XOR<IncidentCreateWithoutClaimInput, IncidentUncheckedCreateWithoutClaimInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutClaimInput
    connect?: IncidentWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutHealthInsuranceClaimsInput = {
    create?: XOR<RoleCreateWithoutHealthInsuranceClaimsInput, RoleUncheckedCreateWithoutHealthInsuranceClaimsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutHealthInsuranceClaimsInput
    connect?: RoleWhereUniqueInput
  }

  export type WitnessCreateNestedOneWithoutClaimInput = {
    create?: XOR<WitnessCreateWithoutClaimInput, WitnessUncheckedCreateWithoutClaimInput>
    connectOrCreate?: WitnessCreateOrConnectWithoutClaimInput
    connect?: WitnessWhereUniqueInput
  }

  export type DefendantCreateNestedOneWithoutClaimInput = {
    create?: XOR<DefendantCreateWithoutClaimInput, DefendantUncheckedCreateWithoutClaimInput>
    connectOrCreate?: DefendantCreateOrConnectWithoutClaimInput
    connect?: DefendantWhereUniqueInput
  }

  export type TreatmentAndInjuryCreateNestedOneWithoutClaimInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutClaimInput, TreatmentAndInjuryUncheckedCreateWithoutClaimInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutClaimInput
    connect?: TreatmentAndInjuryWhereUniqueInput
  }

  export type QuestionnaireCreateNestedOneWithoutClaimInput = {
    create?: XOR<QuestionnaireCreateWithoutClaimInput, QuestionnaireUncheckedCreateWithoutClaimInput>
    connectOrCreate?: QuestionnaireCreateOrConnectWithoutClaimInput
    connect?: QuestionnaireWhereUniqueInput
  }

  export type ClaimListCreateNestedOneWithoutClaimInput = {
    create?: XOR<ClaimListCreateWithoutClaimInput, ClaimListUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ClaimListCreateOrConnectWithoutClaimInput
    connect?: ClaimListWhereUniqueInput
  }

  export type EnvelopCreateNestedManyWithoutClaimInput = {
    create?: XOR<EnvelopCreateWithoutClaimInput, EnvelopUncheckedCreateWithoutClaimInput> | EnvelopCreateWithoutClaimInput[] | EnvelopUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EnvelopCreateOrConnectWithoutClaimInput | EnvelopCreateOrConnectWithoutClaimInput[]
    createMany?: EnvelopCreateManyClaimInputEnvelope
    connect?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
  }

  export type AccidentMediaCreateNestedManyWithoutClaimInput = {
    create?: XOR<AccidentMediaCreateWithoutClaimInput, AccidentMediaUncheckedCreateWithoutClaimInput> | AccidentMediaCreateWithoutClaimInput[] | AccidentMediaUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AccidentMediaCreateOrConnectWithoutClaimInput | AccidentMediaCreateOrConnectWithoutClaimInput[]
    createMany?: AccidentMediaCreateManyClaimInputEnvelope
    connect?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutClaimInput = {
    create?: XOR<TaskCreateWithoutClaimInput, TaskUncheckedCreateWithoutClaimInput> | TaskCreateWithoutClaimInput[] | TaskUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClaimInput | TaskCreateOrConnectWithoutClaimInput[]
    createMany?: TaskCreateManyClaimInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectClaimCreateNestedManyWithoutClaimInput = {
    create?: XOR<ProjectClaimCreateWithoutClaimInput, ProjectClaimUncheckedCreateWithoutClaimInput> | ProjectClaimCreateWithoutClaimInput[] | ProjectClaimUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutClaimInput | ProjectClaimCreateOrConnectWithoutClaimInput[]
    createMany?: ProjectClaimCreateManyClaimInputEnvelope
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
  }

  export type WitnessUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<WitnessCreateWithoutClaimInput, WitnessUncheckedCreateWithoutClaimInput>
    connectOrCreate?: WitnessCreateOrConnectWithoutClaimInput
    connect?: WitnessWhereUniqueInput
  }

  export type DefendantUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<DefendantCreateWithoutClaimInput, DefendantUncheckedCreateWithoutClaimInput>
    connectOrCreate?: DefendantCreateOrConnectWithoutClaimInput
    connect?: DefendantWhereUniqueInput
  }

  export type TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutClaimInput, TreatmentAndInjuryUncheckedCreateWithoutClaimInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutClaimInput
    connect?: TreatmentAndInjuryWhereUniqueInput
  }

  export type QuestionnaireUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<QuestionnaireCreateWithoutClaimInput, QuestionnaireUncheckedCreateWithoutClaimInput>
    connectOrCreate?: QuestionnaireCreateOrConnectWithoutClaimInput
    connect?: QuestionnaireWhereUniqueInput
  }

  export type EnvelopUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<EnvelopCreateWithoutClaimInput, EnvelopUncheckedCreateWithoutClaimInput> | EnvelopCreateWithoutClaimInput[] | EnvelopUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EnvelopCreateOrConnectWithoutClaimInput | EnvelopCreateOrConnectWithoutClaimInput[]
    createMany?: EnvelopCreateManyClaimInputEnvelope
    connect?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
  }

  export type AccidentMediaUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<AccidentMediaCreateWithoutClaimInput, AccidentMediaUncheckedCreateWithoutClaimInput> | AccidentMediaCreateWithoutClaimInput[] | AccidentMediaUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AccidentMediaCreateOrConnectWithoutClaimInput | AccidentMediaCreateOrConnectWithoutClaimInput[]
    createMany?: AccidentMediaCreateManyClaimInputEnvelope
    connect?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<TaskCreateWithoutClaimInput, TaskUncheckedCreateWithoutClaimInput> | TaskCreateWithoutClaimInput[] | TaskUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClaimInput | TaskCreateOrConnectWithoutClaimInput[]
    createMany?: TaskCreateManyClaimInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectClaimUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<ProjectClaimCreateWithoutClaimInput, ProjectClaimUncheckedCreateWithoutClaimInput> | ProjectClaimCreateWithoutClaimInput[] | ProjectClaimUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutClaimInput | ProjectClaimCreateOrConnectWithoutClaimInput[]
    createMany?: ProjectClaimCreateManyClaimInputEnvelope
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
  }

  export type NullableEnumClaimStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatus | null
  }

  export type NullableEnumRelationshipFieldUpdateOperationsInput = {
    set?: $Enums.Relationship | null
  }

  export type ClaimUpdatereceiveMedicareInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    upsert?: UserUpsertWithoutClaimsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimsInput, UserUpdateWithoutClaimsInput>, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type RoleUpdateOneWithoutClientClaimsNestedInput = {
    create?: XOR<RoleCreateWithoutClientClaimsInput, RoleUncheckedCreateWithoutClientClaimsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutClientClaimsInput
    upsert?: RoleUpsertWithoutClientClaimsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutClientClaimsInput, RoleUpdateWithoutClientClaimsInput>, RoleUncheckedUpdateWithoutClientClaimsInput>
  }

  export type RoleUpdateOneWithoutInjuredPartyClaimsNestedInput = {
    create?: XOR<RoleCreateWithoutInjuredPartyClaimsInput, RoleUncheckedCreateWithoutInjuredPartyClaimsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutInjuredPartyClaimsInput
    upsert?: RoleUpsertWithoutInjuredPartyClaimsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutInjuredPartyClaimsInput, RoleUpdateWithoutInjuredPartyClaimsInput>, RoleUncheckedUpdateWithoutInjuredPartyClaimsInput>
  }

  export type IncidentUpdateOneWithoutClaimNestedInput = {
    create?: XOR<IncidentCreateWithoutClaimInput, IncidentUncheckedCreateWithoutClaimInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutClaimInput
    upsert?: IncidentUpsertWithoutClaimInput
    disconnect?: IncidentWhereInput | boolean
    delete?: IncidentWhereInput | boolean
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutClaimInput, IncidentUpdateWithoutClaimInput>, IncidentUncheckedUpdateWithoutClaimInput>
  }

  export type RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput = {
    create?: XOR<RoleCreateWithoutHealthInsuranceClaimsInput, RoleUncheckedCreateWithoutHealthInsuranceClaimsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutHealthInsuranceClaimsInput
    upsert?: RoleUpsertWithoutHealthInsuranceClaimsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutHealthInsuranceClaimsInput, RoleUpdateWithoutHealthInsuranceClaimsInput>, RoleUncheckedUpdateWithoutHealthInsuranceClaimsInput>
  }

  export type WitnessUpdateOneWithoutClaimNestedInput = {
    create?: XOR<WitnessCreateWithoutClaimInput, WitnessUncheckedCreateWithoutClaimInput>
    connectOrCreate?: WitnessCreateOrConnectWithoutClaimInput
    upsert?: WitnessUpsertWithoutClaimInput
    disconnect?: WitnessWhereInput | boolean
    delete?: WitnessWhereInput | boolean
    connect?: WitnessWhereUniqueInput
    update?: XOR<XOR<WitnessUpdateToOneWithWhereWithoutClaimInput, WitnessUpdateWithoutClaimInput>, WitnessUncheckedUpdateWithoutClaimInput>
  }

  export type DefendantUpdateOneWithoutClaimNestedInput = {
    create?: XOR<DefendantCreateWithoutClaimInput, DefendantUncheckedCreateWithoutClaimInput>
    connectOrCreate?: DefendantCreateOrConnectWithoutClaimInput
    upsert?: DefendantUpsertWithoutClaimInput
    disconnect?: DefendantWhereInput | boolean
    delete?: DefendantWhereInput | boolean
    connect?: DefendantWhereUniqueInput
    update?: XOR<XOR<DefendantUpdateToOneWithWhereWithoutClaimInput, DefendantUpdateWithoutClaimInput>, DefendantUncheckedUpdateWithoutClaimInput>
  }

  export type TreatmentAndInjuryUpdateOneWithoutClaimNestedInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutClaimInput, TreatmentAndInjuryUncheckedCreateWithoutClaimInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutClaimInput
    upsert?: TreatmentAndInjuryUpsertWithoutClaimInput
    disconnect?: TreatmentAndInjuryWhereInput | boolean
    delete?: TreatmentAndInjuryWhereInput | boolean
    connect?: TreatmentAndInjuryWhereUniqueInput
    update?: XOR<XOR<TreatmentAndInjuryUpdateToOneWithWhereWithoutClaimInput, TreatmentAndInjuryUpdateWithoutClaimInput>, TreatmentAndInjuryUncheckedUpdateWithoutClaimInput>
  }

  export type QuestionnaireUpdateOneWithoutClaimNestedInput = {
    create?: XOR<QuestionnaireCreateWithoutClaimInput, QuestionnaireUncheckedCreateWithoutClaimInput>
    connectOrCreate?: QuestionnaireCreateOrConnectWithoutClaimInput
    upsert?: QuestionnaireUpsertWithoutClaimInput
    disconnect?: QuestionnaireWhereInput | boolean
    delete?: QuestionnaireWhereInput | boolean
    connect?: QuestionnaireWhereUniqueInput
    update?: XOR<XOR<QuestionnaireUpdateToOneWithWhereWithoutClaimInput, QuestionnaireUpdateWithoutClaimInput>, QuestionnaireUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimListUpdateOneRequiredWithoutClaimNestedInput = {
    create?: XOR<ClaimListCreateWithoutClaimInput, ClaimListUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ClaimListCreateOrConnectWithoutClaimInput
    upsert?: ClaimListUpsertWithoutClaimInput
    connect?: ClaimListWhereUniqueInput
    update?: XOR<XOR<ClaimListUpdateToOneWithWhereWithoutClaimInput, ClaimListUpdateWithoutClaimInput>, ClaimListUncheckedUpdateWithoutClaimInput>
  }

  export type EnvelopUpdateManyWithoutClaimNestedInput = {
    create?: XOR<EnvelopCreateWithoutClaimInput, EnvelopUncheckedCreateWithoutClaimInput> | EnvelopCreateWithoutClaimInput[] | EnvelopUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EnvelopCreateOrConnectWithoutClaimInput | EnvelopCreateOrConnectWithoutClaimInput[]
    upsert?: EnvelopUpsertWithWhereUniqueWithoutClaimInput | EnvelopUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: EnvelopCreateManyClaimInputEnvelope
    set?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    disconnect?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    delete?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    connect?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    update?: EnvelopUpdateWithWhereUniqueWithoutClaimInput | EnvelopUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: EnvelopUpdateManyWithWhereWithoutClaimInput | EnvelopUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: EnvelopScalarWhereInput | EnvelopScalarWhereInput[]
  }

  export type AccidentMediaUpdateManyWithoutClaimNestedInput = {
    create?: XOR<AccidentMediaCreateWithoutClaimInput, AccidentMediaUncheckedCreateWithoutClaimInput> | AccidentMediaCreateWithoutClaimInput[] | AccidentMediaUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AccidentMediaCreateOrConnectWithoutClaimInput | AccidentMediaCreateOrConnectWithoutClaimInput[]
    upsert?: AccidentMediaUpsertWithWhereUniqueWithoutClaimInput | AccidentMediaUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: AccidentMediaCreateManyClaimInputEnvelope
    set?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    disconnect?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    delete?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    connect?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    update?: AccidentMediaUpdateWithWhereUniqueWithoutClaimInput | AccidentMediaUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: AccidentMediaUpdateManyWithWhereWithoutClaimInput | AccidentMediaUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: AccidentMediaScalarWhereInput | AccidentMediaScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutClaimNestedInput = {
    create?: XOR<TaskCreateWithoutClaimInput, TaskUncheckedCreateWithoutClaimInput> | TaskCreateWithoutClaimInput[] | TaskUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClaimInput | TaskCreateOrConnectWithoutClaimInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClaimInput | TaskUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: TaskCreateManyClaimInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClaimInput | TaskUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClaimInput | TaskUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectClaimUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ProjectClaimCreateWithoutClaimInput, ProjectClaimUncheckedCreateWithoutClaimInput> | ProjectClaimCreateWithoutClaimInput[] | ProjectClaimUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutClaimInput | ProjectClaimCreateOrConnectWithoutClaimInput[]
    upsert?: ProjectClaimUpsertWithWhereUniqueWithoutClaimInput | ProjectClaimUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ProjectClaimCreateManyClaimInputEnvelope
    set?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    disconnect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    delete?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    update?: ProjectClaimUpdateWithWhereUniqueWithoutClaimInput | ProjectClaimUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ProjectClaimUpdateManyWithWhereWithoutClaimInput | ProjectClaimUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ProjectClaimScalarWhereInput | ProjectClaimScalarWhereInput[]
  }

  export type WitnessUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<WitnessCreateWithoutClaimInput, WitnessUncheckedCreateWithoutClaimInput>
    connectOrCreate?: WitnessCreateOrConnectWithoutClaimInput
    upsert?: WitnessUpsertWithoutClaimInput
    disconnect?: WitnessWhereInput | boolean
    delete?: WitnessWhereInput | boolean
    connect?: WitnessWhereUniqueInput
    update?: XOR<XOR<WitnessUpdateToOneWithWhereWithoutClaimInput, WitnessUpdateWithoutClaimInput>, WitnessUncheckedUpdateWithoutClaimInput>
  }

  export type DefendantUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<DefendantCreateWithoutClaimInput, DefendantUncheckedCreateWithoutClaimInput>
    connectOrCreate?: DefendantCreateOrConnectWithoutClaimInput
    upsert?: DefendantUpsertWithoutClaimInput
    disconnect?: DefendantWhereInput | boolean
    delete?: DefendantWhereInput | boolean
    connect?: DefendantWhereUniqueInput
    update?: XOR<XOR<DefendantUpdateToOneWithWhereWithoutClaimInput, DefendantUpdateWithoutClaimInput>, DefendantUncheckedUpdateWithoutClaimInput>
  }

  export type TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutClaimInput, TreatmentAndInjuryUncheckedCreateWithoutClaimInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutClaimInput
    upsert?: TreatmentAndInjuryUpsertWithoutClaimInput
    disconnect?: TreatmentAndInjuryWhereInput | boolean
    delete?: TreatmentAndInjuryWhereInput | boolean
    connect?: TreatmentAndInjuryWhereUniqueInput
    update?: XOR<XOR<TreatmentAndInjuryUpdateToOneWithWhereWithoutClaimInput, TreatmentAndInjuryUpdateWithoutClaimInput>, TreatmentAndInjuryUncheckedUpdateWithoutClaimInput>
  }

  export type QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<QuestionnaireCreateWithoutClaimInput, QuestionnaireUncheckedCreateWithoutClaimInput>
    connectOrCreate?: QuestionnaireCreateOrConnectWithoutClaimInput
    upsert?: QuestionnaireUpsertWithoutClaimInput
    disconnect?: QuestionnaireWhereInput | boolean
    delete?: QuestionnaireWhereInput | boolean
    connect?: QuestionnaireWhereUniqueInput
    update?: XOR<XOR<QuestionnaireUpdateToOneWithWhereWithoutClaimInput, QuestionnaireUpdateWithoutClaimInput>, QuestionnaireUncheckedUpdateWithoutClaimInput>
  }

  export type EnvelopUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<EnvelopCreateWithoutClaimInput, EnvelopUncheckedCreateWithoutClaimInput> | EnvelopCreateWithoutClaimInput[] | EnvelopUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EnvelopCreateOrConnectWithoutClaimInput | EnvelopCreateOrConnectWithoutClaimInput[]
    upsert?: EnvelopUpsertWithWhereUniqueWithoutClaimInput | EnvelopUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: EnvelopCreateManyClaimInputEnvelope
    set?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    disconnect?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    delete?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    connect?: EnvelopWhereUniqueInput | EnvelopWhereUniqueInput[]
    update?: EnvelopUpdateWithWhereUniqueWithoutClaimInput | EnvelopUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: EnvelopUpdateManyWithWhereWithoutClaimInput | EnvelopUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: EnvelopScalarWhereInput | EnvelopScalarWhereInput[]
  }

  export type AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<AccidentMediaCreateWithoutClaimInput, AccidentMediaUncheckedCreateWithoutClaimInput> | AccidentMediaCreateWithoutClaimInput[] | AccidentMediaUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AccidentMediaCreateOrConnectWithoutClaimInput | AccidentMediaCreateOrConnectWithoutClaimInput[]
    upsert?: AccidentMediaUpsertWithWhereUniqueWithoutClaimInput | AccidentMediaUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: AccidentMediaCreateManyClaimInputEnvelope
    set?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    disconnect?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    delete?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    connect?: AccidentMediaWhereUniqueInput | AccidentMediaWhereUniqueInput[]
    update?: AccidentMediaUpdateWithWhereUniqueWithoutClaimInput | AccidentMediaUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: AccidentMediaUpdateManyWithWhereWithoutClaimInput | AccidentMediaUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: AccidentMediaScalarWhereInput | AccidentMediaScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<TaskCreateWithoutClaimInput, TaskUncheckedCreateWithoutClaimInput> | TaskCreateWithoutClaimInput[] | TaskUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClaimInput | TaskCreateOrConnectWithoutClaimInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClaimInput | TaskUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: TaskCreateManyClaimInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClaimInput | TaskUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClaimInput | TaskUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ProjectClaimCreateWithoutClaimInput, ProjectClaimUncheckedCreateWithoutClaimInput> | ProjectClaimCreateWithoutClaimInput[] | ProjectClaimUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ProjectClaimCreateOrConnectWithoutClaimInput | ProjectClaimCreateOrConnectWithoutClaimInput[]
    upsert?: ProjectClaimUpsertWithWhereUniqueWithoutClaimInput | ProjectClaimUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ProjectClaimCreateManyClaimInputEnvelope
    set?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    disconnect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    delete?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    connect?: ProjectClaimWhereUniqueInput | ProjectClaimWhereUniqueInput[]
    update?: ProjectClaimUpdateWithWhereUniqueWithoutClaimInput | ProjectClaimUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ProjectClaimUpdateManyWithWhereWithoutClaimInput | ProjectClaimUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ProjectClaimScalarWhereInput | ProjectClaimScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectClaimsInput = {
    create?: XOR<ProjectCreateWithoutProjectClaimsInput, ProjectUncheckedCreateWithoutProjectClaimsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectClaimsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ClaimCreateNestedOneWithoutProjectClaimsInput = {
    create?: XOR<ClaimCreateWithoutProjectClaimsInput, ClaimUncheckedCreateWithoutProjectClaimsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutProjectClaimsInput
    connect?: ClaimWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectClaimsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectClaimsInput, ProjectUncheckedCreateWithoutProjectClaimsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectClaimsInput
    upsert?: ProjectUpsertWithoutProjectClaimsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectClaimsInput, ProjectUpdateWithoutProjectClaimsInput>, ProjectUncheckedUpdateWithoutProjectClaimsInput>
  }

  export type ClaimUpdateOneRequiredWithoutProjectClaimsNestedInput = {
    create?: XOR<ClaimCreateWithoutProjectClaimsInput, ClaimUncheckedCreateWithoutProjectClaimsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutProjectClaimsInput
    upsert?: ClaimUpsertWithoutProjectClaimsInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutProjectClaimsInput, ClaimUpdateWithoutProjectClaimsInput>, ClaimUncheckedUpdateWithoutProjectClaimsInput>
  }

  export type ClaimCreateNestedOneWithoutEnvelopInput = {
    create?: XOR<ClaimCreateWithoutEnvelopInput, ClaimUncheckedCreateWithoutEnvelopInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutEnvelopInput
    connect?: ClaimWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClaimUpdateOneRequiredWithoutEnvelopNestedInput = {
    create?: XOR<ClaimCreateWithoutEnvelopInput, ClaimUncheckedCreateWithoutEnvelopInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutEnvelopInput
    upsert?: ClaimUpsertWithoutEnvelopInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutEnvelopInput, ClaimUpdateWithoutEnvelopInput>, ClaimUncheckedUpdateWithoutEnvelopInput>
  }

  export type ClaimCreateNestedManyWithoutClaimlistInput = {
    create?: XOR<ClaimCreateWithoutClaimlistInput, ClaimUncheckedCreateWithoutClaimlistInput> | ClaimCreateWithoutClaimlistInput[] | ClaimUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimlistInput | ClaimCreateOrConnectWithoutClaimlistInput[]
    createMany?: ClaimCreateManyClaimlistInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutClaimlistInput = {
    create?: XOR<UserCreateWithoutClaimlistInput, UserUncheckedCreateWithoutClaimlistInput> | UserCreateWithoutClaimlistInput[] | UserUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClaimlistInput | UserCreateOrConnectWithoutClaimlistInput[]
    createMany?: UserCreateManyClaimlistInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutClaimListInput = {
    create?: XOR<QuestionCreateWithoutClaimListInput, QuestionUncheckedCreateWithoutClaimListInput> | QuestionCreateWithoutClaimListInput[] | QuestionUncheckedCreateWithoutClaimListInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutClaimListInput | QuestionCreateOrConnectWithoutClaimListInput[]
    createMany?: QuestionCreateManyClaimListInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutClaimlistInput = {
    create?: XOR<ClaimCreateWithoutClaimlistInput, ClaimUncheckedCreateWithoutClaimlistInput> | ClaimCreateWithoutClaimlistInput[] | ClaimUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimlistInput | ClaimCreateOrConnectWithoutClaimlistInput[]
    createMany?: ClaimCreateManyClaimlistInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClaimlistInput = {
    create?: XOR<UserCreateWithoutClaimlistInput, UserUncheckedCreateWithoutClaimlistInput> | UserCreateWithoutClaimlistInput[] | UserUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClaimlistInput | UserCreateOrConnectWithoutClaimlistInput[]
    createMany?: UserCreateManyClaimlistInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutClaimListInput = {
    create?: XOR<QuestionCreateWithoutClaimListInput, QuestionUncheckedCreateWithoutClaimListInput> | QuestionCreateWithoutClaimListInput[] | QuestionUncheckedCreateWithoutClaimListInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutClaimListInput | QuestionCreateOrConnectWithoutClaimListInput[]
    createMany?: QuestionCreateManyClaimListInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ClaimUpdateManyWithoutClaimlistNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimlistInput, ClaimUncheckedCreateWithoutClaimlistInput> | ClaimCreateWithoutClaimlistInput[] | ClaimUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimlistInput | ClaimCreateOrConnectWithoutClaimlistInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutClaimlistInput | ClaimUpsertWithWhereUniqueWithoutClaimlistInput[]
    createMany?: ClaimCreateManyClaimlistInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutClaimlistInput | ClaimUpdateWithWhereUniqueWithoutClaimlistInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutClaimlistInput | ClaimUpdateManyWithWhereWithoutClaimlistInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type UserUpdateManyWithoutClaimlistNestedInput = {
    create?: XOR<UserCreateWithoutClaimlistInput, UserUncheckedCreateWithoutClaimlistInput> | UserCreateWithoutClaimlistInput[] | UserUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClaimlistInput | UserCreateOrConnectWithoutClaimlistInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClaimlistInput | UserUpsertWithWhereUniqueWithoutClaimlistInput[]
    createMany?: UserCreateManyClaimlistInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClaimlistInput | UserUpdateWithWhereUniqueWithoutClaimlistInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClaimlistInput | UserUpdateManyWithWhereWithoutClaimlistInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutClaimListNestedInput = {
    create?: XOR<QuestionCreateWithoutClaimListInput, QuestionUncheckedCreateWithoutClaimListInput> | QuestionCreateWithoutClaimListInput[] | QuestionUncheckedCreateWithoutClaimListInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutClaimListInput | QuestionCreateOrConnectWithoutClaimListInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutClaimListInput | QuestionUpsertWithWhereUniqueWithoutClaimListInput[]
    createMany?: QuestionCreateManyClaimListInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutClaimListInput | QuestionUpdateWithWhereUniqueWithoutClaimListInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutClaimListInput | QuestionUpdateManyWithWhereWithoutClaimListInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutClaimlistNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimlistInput, ClaimUncheckedCreateWithoutClaimlistInput> | ClaimCreateWithoutClaimlistInput[] | ClaimUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimlistInput | ClaimCreateOrConnectWithoutClaimlistInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutClaimlistInput | ClaimUpsertWithWhereUniqueWithoutClaimlistInput[]
    createMany?: ClaimCreateManyClaimlistInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutClaimlistInput | ClaimUpdateWithWhereUniqueWithoutClaimlistInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutClaimlistInput | ClaimUpdateManyWithWhereWithoutClaimlistInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClaimlistNestedInput = {
    create?: XOR<UserCreateWithoutClaimlistInput, UserUncheckedCreateWithoutClaimlistInput> | UserCreateWithoutClaimlistInput[] | UserUncheckedCreateWithoutClaimlistInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClaimlistInput | UserCreateOrConnectWithoutClaimlistInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClaimlistInput | UserUpsertWithWhereUniqueWithoutClaimlistInput[]
    createMany?: UserCreateManyClaimlistInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClaimlistInput | UserUpdateWithWhereUniqueWithoutClaimlistInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClaimlistInput | UserUpdateManyWithWhereWithoutClaimlistInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutClaimListNestedInput = {
    create?: XOR<QuestionCreateWithoutClaimListInput, QuestionUncheckedCreateWithoutClaimListInput> | QuestionCreateWithoutClaimListInput[] | QuestionUncheckedCreateWithoutClaimListInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutClaimListInput | QuestionCreateOrConnectWithoutClaimListInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutClaimListInput | QuestionUpsertWithWhereUniqueWithoutClaimListInput[]
    createMany?: QuestionCreateManyClaimListInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutClaimListInput | QuestionUpdateWithWhereUniqueWithoutClaimListInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutClaimListInput | QuestionUpdateManyWithWhereWithoutClaimListInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutSourceInput = {
    create?: XOR<UserCreateWithoutSourceInput, UserUncheckedCreateWithoutSourceInput> | UserCreateWithoutSourceInput[] | UserUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSourceInput | UserCreateOrConnectWithoutSourceInput[]
    createMany?: UserCreateManySourceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<UserCreateWithoutSourceInput, UserUncheckedCreateWithoutSourceInput> | UserCreateWithoutSourceInput[] | UserUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSourceInput | UserCreateOrConnectWithoutSourceInput[]
    createMany?: UserCreateManySourceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutSourceNestedInput = {
    create?: XOR<UserCreateWithoutSourceInput, UserUncheckedCreateWithoutSourceInput> | UserCreateWithoutSourceInput[] | UserUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSourceInput | UserCreateOrConnectWithoutSourceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSourceInput | UserUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: UserCreateManySourceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSourceInput | UserUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSourceInput | UserUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<UserCreateWithoutSourceInput, UserUncheckedCreateWithoutSourceInput> | UserCreateWithoutSourceInput[] | UserUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSourceInput | UserCreateOrConnectWithoutSourceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSourceInput | UserUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: UserCreateManySourceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSourceInput | UserUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSourceInput | UserUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClaimCreateNestedOneWithoutQuestionnaireInput = {
    create?: XOR<ClaimCreateWithoutQuestionnaireInput, ClaimUncheckedCreateWithoutQuestionnaireInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutQuestionnaireInput
    connect?: ClaimWhereUniqueInput
  }

  export type QuestionAnswerCreateNestedManyWithoutQuestionnaireInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionnaireInput, QuestionAnswerUncheckedCreateWithoutQuestionnaireInput> | QuestionAnswerCreateWithoutQuestionnaireInput[] | QuestionAnswerUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionnaireInput | QuestionAnswerCreateOrConnectWithoutQuestionnaireInput[]
    createMany?: QuestionAnswerCreateManyQuestionnaireInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutQuestionnaireInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionnaireInput, QuestionAnswerUncheckedCreateWithoutQuestionnaireInput> | QuestionAnswerCreateWithoutQuestionnaireInput[] | QuestionAnswerUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionnaireInput | QuestionAnswerCreateOrConnectWithoutQuestionnaireInput[]
    createMany?: QuestionAnswerCreateManyQuestionnaireInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type ClaimUpdateOneRequiredWithoutQuestionnaireNestedInput = {
    create?: XOR<ClaimCreateWithoutQuestionnaireInput, ClaimUncheckedCreateWithoutQuestionnaireInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutQuestionnaireInput
    upsert?: ClaimUpsertWithoutQuestionnaireInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutQuestionnaireInput, ClaimUpdateWithoutQuestionnaireInput>, ClaimUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type QuestionAnswerUpdateManyWithoutQuestionnaireNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionnaireInput, QuestionAnswerUncheckedCreateWithoutQuestionnaireInput> | QuestionAnswerCreateWithoutQuestionnaireInput[] | QuestionAnswerUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionnaireInput | QuestionAnswerCreateOrConnectWithoutQuestionnaireInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutQuestionnaireInput | QuestionAnswerUpsertWithWhereUniqueWithoutQuestionnaireInput[]
    createMany?: QuestionAnswerCreateManyQuestionnaireInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutQuestionnaireInput | QuestionAnswerUpdateWithWhereUniqueWithoutQuestionnaireInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutQuestionnaireInput | QuestionAnswerUpdateManyWithWhereWithoutQuestionnaireInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutQuestionnaireNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionnaireInput, QuestionAnswerUncheckedCreateWithoutQuestionnaireInput> | QuestionAnswerCreateWithoutQuestionnaireInput[] | QuestionAnswerUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionnaireInput | QuestionAnswerCreateOrConnectWithoutQuestionnaireInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutQuestionnaireInput | QuestionAnswerUpsertWithWhereUniqueWithoutQuestionnaireInput[]
    createMany?: QuestionAnswerCreateManyQuestionnaireInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutQuestionnaireInput | QuestionAnswerUpdateWithWhereUniqueWithoutQuestionnaireInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutQuestionnaireInput | QuestionAnswerUpdateManyWithWhereWithoutQuestionnaireInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuestionnaireCreateNestedOneWithoutQuestionInput = {
    create?: XOR<QuestionnaireCreateWithoutQuestionInput, QuestionnaireUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: QuestionnaireCreateOrConnectWithoutQuestionInput
    connect?: QuestionnaireWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<QuestionCreateWithoutQuestionAnswerInput, QuestionUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionAnswerInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionnaireUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<QuestionnaireCreateWithoutQuestionInput, QuestionnaireUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: QuestionnaireCreateOrConnectWithoutQuestionInput
    upsert?: QuestionnaireUpsertWithoutQuestionInput
    disconnect?: QuestionnaireWhereInput | boolean
    delete?: QuestionnaireWhereInput | boolean
    connect?: QuestionnaireWhereUniqueInput
    update?: XOR<XOR<QuestionnaireUpdateToOneWithWhereWithoutQuestionInput, QuestionnaireUpdateWithoutQuestionInput>, QuestionnaireUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionUpdateOneRequiredWithoutQuestionAnswerNestedInput = {
    create?: XOR<QuestionCreateWithoutQuestionAnswerInput, QuestionUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionAnswerInput
    upsert?: QuestionUpsertWithoutQuestionAnswerInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutQuestionAnswerInput, QuestionUpdateWithoutQuestionAnswerInput>, QuestionUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type ClaimListCreateNestedOneWithoutQuestionInput = {
    create?: XOR<ClaimListCreateWithoutQuestionInput, ClaimListUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: ClaimListCreateOrConnectWithoutQuestionInput
    connect?: ClaimListWhereUniqueInput
  }

  export type ChoiceCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
  }

  export type QuestionAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type ChoiceUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type ClaimListUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<ClaimListCreateWithoutQuestionInput, ClaimListUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: ClaimListCreateOrConnectWithoutQuestionInput
    upsert?: ClaimListUpsertWithoutQuestionInput
    disconnect?: ClaimListWhereInput | boolean
    delete?: ClaimListWhereInput | boolean
    connect?: ClaimListWhereUniqueInput
    update?: XOR<XOR<ClaimListUpdateToOneWithWhereWithoutQuestionInput, ClaimListUpdateWithoutQuestionInput>, ClaimListUncheckedUpdateWithoutQuestionInput>
  }

  export type ChoiceUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    upsert?: ChoiceUpsertWithWhereUniqueWithoutQuestionInput | ChoiceUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    set?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    disconnect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    delete?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    update?: ChoiceUpdateWithWhereUniqueWithoutQuestionInput | ChoiceUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ChoiceUpdateManyWithWhereWithoutQuestionInput | ChoiceUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
  }

  export type QuestionAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutQuestionInput | QuestionAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type ChoiceUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    upsert?: ChoiceUpsertWithWhereUniqueWithoutQuestionInput | ChoiceUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    set?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    disconnect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    delete?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    update?: ChoiceUpdateWithWhereUniqueWithoutQuestionInput | ChoiceUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ChoiceUpdateManyWithWhereWithoutQuestionInput | ChoiceUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput> | QuestionAnswerCreateWithoutQuestionInput[] | QuestionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutQuestionInput | QuestionAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionAnswerCreateManyQuestionInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutQuestionInput | QuestionAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutChoicesInput = {
    create?: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutChoicesInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutChoicesNestedInput = {
    create?: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutChoicesInput
    upsert?: QuestionUpsertWithoutChoicesInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutChoicesInput, QuestionUpdateWithoutChoicesInput>, QuestionUncheckedUpdateWithoutChoicesInput>
  }

  export type ClaimCreateNestedOneWithoutDefendantInput = {
    create?: XOR<ClaimCreateWithoutDefendantInput, ClaimUncheckedCreateWithoutDefendantInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutDefendantInput
    connect?: ClaimWhereUniqueInput
  }

  export type DefendantDetailsCreateNestedManyWithoutDefendantInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInput, DefendantDetailsUncheckedCreateWithoutDefendantInput> | DefendantDetailsCreateWithoutDefendantInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInput | DefendantDetailsCreateOrConnectWithoutDefendantInput[]
    createMany?: DefendantDetailsCreateManyDefendantInputEnvelope
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
  }

  export type DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInput, DefendantDetailsUncheckedCreateWithoutDefendantInput> | DefendantDetailsCreateWithoutDefendantInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInput | DefendantDetailsCreateOrConnectWithoutDefendantInput[]
    createMany?: DefendantDetailsCreateManyDefendantInputEnvelope
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
  }

  export type ClaimUpdateOneRequiredWithoutDefendantNestedInput = {
    create?: XOR<ClaimCreateWithoutDefendantInput, ClaimUncheckedCreateWithoutDefendantInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutDefendantInput
    upsert?: ClaimUpsertWithoutDefendantInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutDefendantInput, ClaimUpdateWithoutDefendantInput>, ClaimUncheckedUpdateWithoutDefendantInput>
  }

  export type DefendantDetailsUpdateManyWithoutDefendantNestedInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInput, DefendantDetailsUncheckedCreateWithoutDefendantInput> | DefendantDetailsCreateWithoutDefendantInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInput | DefendantDetailsCreateOrConnectWithoutDefendantInput[]
    upsert?: DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInput | DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInput[]
    createMany?: DefendantDetailsCreateManyDefendantInputEnvelope
    set?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    disconnect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    delete?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    update?: DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInput | DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInput[]
    updateMany?: DefendantDetailsUpdateManyWithWhereWithoutDefendantInput | DefendantDetailsUpdateManyWithWhereWithoutDefendantInput[]
    deleteMany?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
  }

  export type DefendantDetailsUncheckedUpdateManyWithoutDefendantNestedInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInput, DefendantDetailsUncheckedCreateWithoutDefendantInput> | DefendantDetailsCreateWithoutDefendantInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInput | DefendantDetailsCreateOrConnectWithoutDefendantInput[]
    upsert?: DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInput | DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInput[]
    createMany?: DefendantDetailsCreateManyDefendantInputEnvelope
    set?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    disconnect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    delete?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    update?: DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInput | DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInput[]
    updateMany?: DefendantDetailsUpdateManyWithWhereWithoutDefendantInput | DefendantDetailsUpdateManyWithWhereWithoutDefendantInput[]
    deleteMany?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutDefendantAccountInput = {
    create?: XOR<RoleCreateWithoutDefendantAccountInput, RoleUncheckedCreateWithoutDefendantAccountInput>
    connectOrCreate?: RoleCreateOrConnectWithoutDefendantAccountInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutDefendantInsuranceCarrierInput = {
    create?: XOR<RoleCreateWithoutDefendantInsuranceCarrierInput, RoleUncheckedCreateWithoutDefendantInsuranceCarrierInput>
    connectOrCreate?: RoleCreateOrConnectWithoutDefendantInsuranceCarrierInput
    connect?: RoleWhereUniqueInput
  }

  export type DefendantCreateNestedOneWithoutDefendantDetailsInput = {
    create?: XOR<DefendantCreateWithoutDefendantDetailsInput, DefendantUncheckedCreateWithoutDefendantDetailsInput>
    connectOrCreate?: DefendantCreateOrConnectWithoutDefendantDetailsInput
    connect?: DefendantWhereUniqueInput
  }

  export type EnumDefendantRoleFieldUpdateOperationsInput = {
    set?: $Enums.DefendantRole
  }

  export type NullableEnumCollisionTypeFieldUpdateOperationsInput = {
    set?: $Enums.CollisionType | null
  }

  export type RoleUpdateOneRequiredWithoutDefendantAccountNestedInput = {
    create?: XOR<RoleCreateWithoutDefendantAccountInput, RoleUncheckedCreateWithoutDefendantAccountInput>
    connectOrCreate?: RoleCreateOrConnectWithoutDefendantAccountInput
    upsert?: RoleUpsertWithoutDefendantAccountInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutDefendantAccountInput, RoleUpdateWithoutDefendantAccountInput>, RoleUncheckedUpdateWithoutDefendantAccountInput>
  }

  export type RoleUpdateOneWithoutDefendantInsuranceCarrierNestedInput = {
    create?: XOR<RoleCreateWithoutDefendantInsuranceCarrierInput, RoleUncheckedCreateWithoutDefendantInsuranceCarrierInput>
    connectOrCreate?: RoleCreateOrConnectWithoutDefendantInsuranceCarrierInput
    upsert?: RoleUpsertWithoutDefendantInsuranceCarrierInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutDefendantInsuranceCarrierInput, RoleUpdateWithoutDefendantInsuranceCarrierInput>, RoleUncheckedUpdateWithoutDefendantInsuranceCarrierInput>
  }

  export type DefendantUpdateOneRequiredWithoutDefendantDetailsNestedInput = {
    create?: XOR<DefendantCreateWithoutDefendantDetailsInput, DefendantUncheckedCreateWithoutDefendantDetailsInput>
    connectOrCreate?: DefendantCreateOrConnectWithoutDefendantDetailsInput
    upsert?: DefendantUpsertWithoutDefendantDetailsInput
    connect?: DefendantWhereUniqueInput
    update?: XOR<XOR<DefendantUpdateToOneWithWhereWithoutDefendantDetailsInput, DefendantUpdateWithoutDefendantDetailsInput>, DefendantUncheckedUpdateWithoutDefendantDetailsInput>
  }

  export type ClaimCreateNestedOneWithoutTreatmentsAndInjuriesInput = {
    create?: XOR<ClaimCreateWithoutTreatmentsAndInjuriesInput, ClaimUncheckedCreateWithoutTreatmentsAndInjuriesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutTreatmentsAndInjuriesInput
    connect?: ClaimWhereUniqueInput
  }

  export type TreatmentCreateNestedOneWithoutTreatmentsAndInjuriesInput = {
    create?: XOR<TreatmentCreateWithoutTreatmentsAndInjuriesInput, TreatmentUncheckedCreateWithoutTreatmentsAndInjuriesInput>
    connectOrCreate?: TreatmentCreateOrConnectWithoutTreatmentsAndInjuriesInput
    connect?: TreatmentWhereUniqueInput
  }

  export type ClaimUpdateOneRequiredWithoutTreatmentsAndInjuriesNestedInput = {
    create?: XOR<ClaimCreateWithoutTreatmentsAndInjuriesInput, ClaimUncheckedCreateWithoutTreatmentsAndInjuriesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutTreatmentsAndInjuriesInput
    upsert?: ClaimUpsertWithoutTreatmentsAndInjuriesInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutTreatmentsAndInjuriesInput, ClaimUpdateWithoutTreatmentsAndInjuriesInput>, ClaimUncheckedUpdateWithoutTreatmentsAndInjuriesInput>
  }

  export type TreatmentUpdateOneRequiredWithoutTreatmentsAndInjuriesNestedInput = {
    create?: XOR<TreatmentCreateWithoutTreatmentsAndInjuriesInput, TreatmentUncheckedCreateWithoutTreatmentsAndInjuriesInput>
    connectOrCreate?: TreatmentCreateOrConnectWithoutTreatmentsAndInjuriesInput
    upsert?: TreatmentUpsertWithoutTreatmentsAndInjuriesInput
    connect?: TreatmentWhereUniqueInput
    update?: XOR<XOR<TreatmentUpdateToOneWithWhereWithoutTreatmentsAndInjuriesInput, TreatmentUpdateWithoutTreatmentsAndInjuriesInput>, TreatmentUncheckedUpdateWithoutTreatmentsAndInjuriesInput>
  }

  export type RoleCreateNestedOneWithoutHospitalTreatmentsInput = {
    create?: XOR<RoleCreateWithoutHospitalTreatmentsInput, RoleUncheckedCreateWithoutHospitalTreatmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutHospitalTreatmentsInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutDoctorTreatmentsInput = {
    create?: XOR<RoleCreateWithoutDoctorTreatmentsInput, RoleUncheckedCreateWithoutDoctorTreatmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutDoctorTreatmentsInput
    connect?: RoleWhereUniqueInput
  }

  export type InjuryCreateNestedManyWithoutTreatmentInput = {
    create?: XOR<InjuryCreateWithoutTreatmentInput, InjuryUncheckedCreateWithoutTreatmentInput> | InjuryCreateWithoutTreatmentInput[] | InjuryUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: InjuryCreateOrConnectWithoutTreatmentInput | InjuryCreateOrConnectWithoutTreatmentInput[]
    createMany?: InjuryCreateManyTreatmentInputEnvelope
    connect?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
  }

  export type TreatmentAndInjuryCreateNestedOneWithoutTreatmentInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutTreatmentInput, TreatmentAndInjuryUncheckedCreateWithoutTreatmentInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutTreatmentInput
    connect?: TreatmentAndInjuryWhereUniqueInput
  }

  export type InjuryUncheckedCreateNestedManyWithoutTreatmentInput = {
    create?: XOR<InjuryCreateWithoutTreatmentInput, InjuryUncheckedCreateWithoutTreatmentInput> | InjuryCreateWithoutTreatmentInput[] | InjuryUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: InjuryCreateOrConnectWithoutTreatmentInput | InjuryCreateOrConnectWithoutTreatmentInput[]
    createMany?: InjuryCreateManyTreatmentInputEnvelope
    connect?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
  }

  export type TreatmentAndInjuryUncheckedCreateNestedOneWithoutTreatmentInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutTreatmentInput, TreatmentAndInjuryUncheckedCreateWithoutTreatmentInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutTreatmentInput
    connect?: TreatmentAndInjuryWhereUniqueInput
  }

  export type RoleUpdateOneWithoutHospitalTreatmentsNestedInput = {
    create?: XOR<RoleCreateWithoutHospitalTreatmentsInput, RoleUncheckedCreateWithoutHospitalTreatmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutHospitalTreatmentsInput
    upsert?: RoleUpsertWithoutHospitalTreatmentsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutHospitalTreatmentsInput, RoleUpdateWithoutHospitalTreatmentsInput>, RoleUncheckedUpdateWithoutHospitalTreatmentsInput>
  }

  export type RoleUpdateOneWithoutDoctorTreatmentsNestedInput = {
    create?: XOR<RoleCreateWithoutDoctorTreatmentsInput, RoleUncheckedCreateWithoutDoctorTreatmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutDoctorTreatmentsInput
    upsert?: RoleUpsertWithoutDoctorTreatmentsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutDoctorTreatmentsInput, RoleUpdateWithoutDoctorTreatmentsInput>, RoleUncheckedUpdateWithoutDoctorTreatmentsInput>
  }

  export type InjuryUpdateManyWithoutTreatmentNestedInput = {
    create?: XOR<InjuryCreateWithoutTreatmentInput, InjuryUncheckedCreateWithoutTreatmentInput> | InjuryCreateWithoutTreatmentInput[] | InjuryUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: InjuryCreateOrConnectWithoutTreatmentInput | InjuryCreateOrConnectWithoutTreatmentInput[]
    upsert?: InjuryUpsertWithWhereUniqueWithoutTreatmentInput | InjuryUpsertWithWhereUniqueWithoutTreatmentInput[]
    createMany?: InjuryCreateManyTreatmentInputEnvelope
    set?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    disconnect?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    delete?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    connect?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    update?: InjuryUpdateWithWhereUniqueWithoutTreatmentInput | InjuryUpdateWithWhereUniqueWithoutTreatmentInput[]
    updateMany?: InjuryUpdateManyWithWhereWithoutTreatmentInput | InjuryUpdateManyWithWhereWithoutTreatmentInput[]
    deleteMany?: InjuryScalarWhereInput | InjuryScalarWhereInput[]
  }

  export type TreatmentAndInjuryUpdateOneWithoutTreatmentNestedInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutTreatmentInput, TreatmentAndInjuryUncheckedCreateWithoutTreatmentInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutTreatmentInput
    upsert?: TreatmentAndInjuryUpsertWithoutTreatmentInput
    disconnect?: TreatmentAndInjuryWhereInput | boolean
    delete?: TreatmentAndInjuryWhereInput | boolean
    connect?: TreatmentAndInjuryWhereUniqueInput
    update?: XOR<XOR<TreatmentAndInjuryUpdateToOneWithWhereWithoutTreatmentInput, TreatmentAndInjuryUpdateWithoutTreatmentInput>, TreatmentAndInjuryUncheckedUpdateWithoutTreatmentInput>
  }

  export type InjuryUncheckedUpdateManyWithoutTreatmentNestedInput = {
    create?: XOR<InjuryCreateWithoutTreatmentInput, InjuryUncheckedCreateWithoutTreatmentInput> | InjuryCreateWithoutTreatmentInput[] | InjuryUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: InjuryCreateOrConnectWithoutTreatmentInput | InjuryCreateOrConnectWithoutTreatmentInput[]
    upsert?: InjuryUpsertWithWhereUniqueWithoutTreatmentInput | InjuryUpsertWithWhereUniqueWithoutTreatmentInput[]
    createMany?: InjuryCreateManyTreatmentInputEnvelope
    set?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    disconnect?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    delete?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    connect?: InjuryWhereUniqueInput | InjuryWhereUniqueInput[]
    update?: InjuryUpdateWithWhereUniqueWithoutTreatmentInput | InjuryUpdateWithWhereUniqueWithoutTreatmentInput[]
    updateMany?: InjuryUpdateManyWithWhereWithoutTreatmentInput | InjuryUpdateManyWithWhereWithoutTreatmentInput[]
    deleteMany?: InjuryScalarWhereInput | InjuryScalarWhereInput[]
  }

  export type TreatmentAndInjuryUncheckedUpdateOneWithoutTreatmentNestedInput = {
    create?: XOR<TreatmentAndInjuryCreateWithoutTreatmentInput, TreatmentAndInjuryUncheckedCreateWithoutTreatmentInput>
    connectOrCreate?: TreatmentAndInjuryCreateOrConnectWithoutTreatmentInput
    upsert?: TreatmentAndInjuryUpsertWithoutTreatmentInput
    disconnect?: TreatmentAndInjuryWhereInput | boolean
    delete?: TreatmentAndInjuryWhereInput | boolean
    connect?: TreatmentAndInjuryWhereUniqueInput
    update?: XOR<XOR<TreatmentAndInjuryUpdateToOneWithWhereWithoutTreatmentInput, TreatmentAndInjuryUpdateWithoutTreatmentInput>, TreatmentAndInjuryUncheckedUpdateWithoutTreatmentInput>
  }

  export type TreatmentCreateNestedOneWithoutInjuriesInput = {
    create?: XOR<TreatmentCreateWithoutInjuriesInput, TreatmentUncheckedCreateWithoutInjuriesInput>
    connectOrCreate?: TreatmentCreateOrConnectWithoutInjuriesInput
    connect?: TreatmentWhereUniqueInput
  }

  export type EnumInjuryPointFieldUpdateOperationsInput = {
    set?: $Enums.InjuryPoint
  }

  export type EnumInjuryTypeFieldUpdateOperationsInput = {
    set?: $Enums.InjuryType
  }

  export type EnumInjurySideFieldUpdateOperationsInput = {
    set?: $Enums.InjurySide
  }

  export type TreatmentUpdateOneRequiredWithoutInjuriesNestedInput = {
    create?: XOR<TreatmentCreateWithoutInjuriesInput, TreatmentUncheckedCreateWithoutInjuriesInput>
    connectOrCreate?: TreatmentCreateOrConnectWithoutInjuriesInput
    upsert?: TreatmentUpsertWithoutInjuriesInput
    connect?: TreatmentWhereUniqueInput
    update?: XOR<XOR<TreatmentUpdateToOneWithWhereWithoutInjuriesInput, TreatmentUpdateWithoutInjuriesInput>, TreatmentUncheckedUpdateWithoutInjuriesInput>
  }

  export type ClaimCreateNestedOneWithoutMediaInput = {
    create?: XOR<ClaimCreateWithoutMediaInput, ClaimUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutMediaInput
    connect?: ClaimWhereUniqueInput
  }

  export type ClaimUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ClaimCreateWithoutMediaInput, ClaimUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutMediaInput
    upsert?: ClaimUpsertWithoutMediaInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutMediaInput, ClaimUpdateWithoutMediaInput>, ClaimUncheckedUpdateWithoutMediaInput>
  }

  export type RoleCreateNestedOneWithoutPoliceStationIncidentsInput = {
    create?: XOR<RoleCreateWithoutPoliceStationIncidentsInput, RoleUncheckedCreateWithoutPoliceStationIncidentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPoliceStationIncidentsInput
    connect?: RoleWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutPoliceIncidentsInput = {
    create?: XOR<SubAccountCreateWithoutPoliceIncidentsInput, SubAccountUncheckedCreateWithoutPoliceIncidentsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPoliceIncidentsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutLawfirmIncidentsInput = {
    create?: XOR<RoleCreateWithoutLawfirmIncidentsInput, RoleUncheckedCreateWithoutLawfirmIncidentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutLawfirmIncidentsInput
    connect?: RoleWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<SubAccountCreateWithoutIncidentsInput, SubAccountUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutIncidentsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type ClaimCreateNestedOneWithoutIncidentInput = {
    create?: XOR<ClaimCreateWithoutIncidentInput, ClaimUncheckedCreateWithoutIncidentInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutIncidentInput
    connect?: ClaimWhereUniqueInput
  }

  export type ClaimUncheckedCreateNestedOneWithoutIncidentInput = {
    create?: XOR<ClaimCreateWithoutIncidentInput, ClaimUncheckedCreateWithoutIncidentInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutIncidentInput
    connect?: ClaimWhereUniqueInput
  }

  export type NullableEnumBusOrVehicleFieldUpdateOperationsInput = {
    set?: $Enums.BusOrVehicle | null
  }

  export type NullableEnumTransportTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransportType | null
  }

  export type NullableEnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType | null
  }

  export type RoleUpdateOneWithoutPoliceStationIncidentsNestedInput = {
    create?: XOR<RoleCreateWithoutPoliceStationIncidentsInput, RoleUncheckedCreateWithoutPoliceStationIncidentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPoliceStationIncidentsInput
    upsert?: RoleUpsertWithoutPoliceStationIncidentsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPoliceStationIncidentsInput, RoleUpdateWithoutPoliceStationIncidentsInput>, RoleUncheckedUpdateWithoutPoliceStationIncidentsInput>
  }

  export type SubAccountUpdateOneWithoutPoliceIncidentsNestedInput = {
    create?: XOR<SubAccountCreateWithoutPoliceIncidentsInput, SubAccountUncheckedCreateWithoutPoliceIncidentsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPoliceIncidentsInput
    upsert?: SubAccountUpsertWithoutPoliceIncidentsInput
    disconnect?: SubAccountWhereInput | boolean
    delete?: SubAccountWhereInput | boolean
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutPoliceIncidentsInput, SubAccountUpdateWithoutPoliceIncidentsInput>, SubAccountUncheckedUpdateWithoutPoliceIncidentsInput>
  }

  export type RoleUpdateOneWithoutLawfirmIncidentsNestedInput = {
    create?: XOR<RoleCreateWithoutLawfirmIncidentsInput, RoleUncheckedCreateWithoutLawfirmIncidentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutLawfirmIncidentsInput
    upsert?: RoleUpsertWithoutLawfirmIncidentsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutLawfirmIncidentsInput, RoleUpdateWithoutLawfirmIncidentsInput>, RoleUncheckedUpdateWithoutLawfirmIncidentsInput>
  }

  export type SubAccountUpdateOneWithoutIncidentsNestedInput = {
    create?: XOR<SubAccountCreateWithoutIncidentsInput, SubAccountUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutIncidentsInput
    upsert?: SubAccountUpsertWithoutIncidentsInput
    disconnect?: SubAccountWhereInput | boolean
    delete?: SubAccountWhereInput | boolean
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutIncidentsInput, SubAccountUpdateWithoutIncidentsInput>, SubAccountUncheckedUpdateWithoutIncidentsInput>
  }

  export type ClaimUpdateOneWithoutIncidentNestedInput = {
    create?: XOR<ClaimCreateWithoutIncidentInput, ClaimUncheckedCreateWithoutIncidentInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutIncidentInput
    upsert?: ClaimUpsertWithoutIncidentInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutIncidentInput, ClaimUpdateWithoutIncidentInput>, ClaimUncheckedUpdateWithoutIncidentInput>
  }

  export type ClaimUncheckedUpdateOneWithoutIncidentNestedInput = {
    create?: XOR<ClaimCreateWithoutIncidentInput, ClaimUncheckedCreateWithoutIncidentInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutIncidentInput
    upsert?: ClaimUpsertWithoutIncidentInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutIncidentInput, ClaimUpdateWithoutIncidentInput>, ClaimUncheckedUpdateWithoutIncidentInput>
  }

  export type ClaimCreateNestedOneWithoutWitnessInput = {
    create?: XOR<ClaimCreateWithoutWitnessInput, ClaimUncheckedCreateWithoutWitnessInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutWitnessInput
    connect?: ClaimWhereUniqueInput
  }

  export type WitnessDetailsCreateNestedManyWithoutWitnessInput = {
    create?: XOR<WitnessDetailsCreateWithoutWitnessInput, WitnessDetailsUncheckedCreateWithoutWitnessInput> | WitnessDetailsCreateWithoutWitnessInput[] | WitnessDetailsUncheckedCreateWithoutWitnessInput[]
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutWitnessInput | WitnessDetailsCreateOrConnectWithoutWitnessInput[]
    createMany?: WitnessDetailsCreateManyWitnessInputEnvelope
    connect?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
  }

  export type WitnessDetailsUncheckedCreateNestedManyWithoutWitnessInput = {
    create?: XOR<WitnessDetailsCreateWithoutWitnessInput, WitnessDetailsUncheckedCreateWithoutWitnessInput> | WitnessDetailsCreateWithoutWitnessInput[] | WitnessDetailsUncheckedCreateWithoutWitnessInput[]
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutWitnessInput | WitnessDetailsCreateOrConnectWithoutWitnessInput[]
    createMany?: WitnessDetailsCreateManyWitnessInputEnvelope
    connect?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
  }

  export type ClaimUpdateOneRequiredWithoutWitnessNestedInput = {
    create?: XOR<ClaimCreateWithoutWitnessInput, ClaimUncheckedCreateWithoutWitnessInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutWitnessInput
    upsert?: ClaimUpsertWithoutWitnessInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutWitnessInput, ClaimUpdateWithoutWitnessInput>, ClaimUncheckedUpdateWithoutWitnessInput>
  }

  export type WitnessDetailsUpdateManyWithoutWitnessNestedInput = {
    create?: XOR<WitnessDetailsCreateWithoutWitnessInput, WitnessDetailsUncheckedCreateWithoutWitnessInput> | WitnessDetailsCreateWithoutWitnessInput[] | WitnessDetailsUncheckedCreateWithoutWitnessInput[]
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutWitnessInput | WitnessDetailsCreateOrConnectWithoutWitnessInput[]
    upsert?: WitnessDetailsUpsertWithWhereUniqueWithoutWitnessInput | WitnessDetailsUpsertWithWhereUniqueWithoutWitnessInput[]
    createMany?: WitnessDetailsCreateManyWitnessInputEnvelope
    set?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    disconnect?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    delete?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    connect?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    update?: WitnessDetailsUpdateWithWhereUniqueWithoutWitnessInput | WitnessDetailsUpdateWithWhereUniqueWithoutWitnessInput[]
    updateMany?: WitnessDetailsUpdateManyWithWhereWithoutWitnessInput | WitnessDetailsUpdateManyWithWhereWithoutWitnessInput[]
    deleteMany?: WitnessDetailsScalarWhereInput | WitnessDetailsScalarWhereInput[]
  }

  export type WitnessDetailsUncheckedUpdateManyWithoutWitnessNestedInput = {
    create?: XOR<WitnessDetailsCreateWithoutWitnessInput, WitnessDetailsUncheckedCreateWithoutWitnessInput> | WitnessDetailsCreateWithoutWitnessInput[] | WitnessDetailsUncheckedCreateWithoutWitnessInput[]
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutWitnessInput | WitnessDetailsCreateOrConnectWithoutWitnessInput[]
    upsert?: WitnessDetailsUpsertWithWhereUniqueWithoutWitnessInput | WitnessDetailsUpsertWithWhereUniqueWithoutWitnessInput[]
    createMany?: WitnessDetailsCreateManyWitnessInputEnvelope
    set?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    disconnect?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    delete?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    connect?: WitnessDetailsWhereUniqueInput | WitnessDetailsWhereUniqueInput[]
    update?: WitnessDetailsUpdateWithWhereUniqueWithoutWitnessInput | WitnessDetailsUpdateWithWhereUniqueWithoutWitnessInput[]
    updateMany?: WitnessDetailsUpdateManyWithWhereWithoutWitnessInput | WitnessDetailsUpdateManyWithWhereWithoutWitnessInput[]
    deleteMany?: WitnessDetailsScalarWhereInput | WitnessDetailsScalarWhereInput[]
  }

  export type WitnessCreateNestedOneWithoutWitnessDetailsInput = {
    create?: XOR<WitnessCreateWithoutWitnessDetailsInput, WitnessUncheckedCreateWithoutWitnessDetailsInput>
    connectOrCreate?: WitnessCreateOrConnectWithoutWitnessDetailsInput
    connect?: WitnessWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutWitnessDetailsInput = {
    create?: XOR<RoleCreateWithoutWitnessDetailsInput, RoleUncheckedCreateWithoutWitnessDetailsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutWitnessDetailsInput
    connect?: RoleWhereUniqueInput
  }

  export type WitnessUpdateOneRequiredWithoutWitnessDetailsNestedInput = {
    create?: XOR<WitnessCreateWithoutWitnessDetailsInput, WitnessUncheckedCreateWithoutWitnessDetailsInput>
    connectOrCreate?: WitnessCreateOrConnectWithoutWitnessDetailsInput
    upsert?: WitnessUpsertWithoutWitnessDetailsInput
    connect?: WitnessWhereUniqueInput
    update?: XOR<XOR<WitnessUpdateToOneWithWhereWithoutWitnessDetailsInput, WitnessUpdateWithoutWitnessDetailsInput>, WitnessUncheckedUpdateWithoutWitnessDetailsInput>
  }

  export type RoleUpdateOneRequiredWithoutWitnessDetailsNestedInput = {
    create?: XOR<RoleCreateWithoutWitnessDetailsInput, RoleUncheckedCreateWithoutWitnessDetailsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutWitnessDetailsInput
    upsert?: RoleUpsertWithoutWitnessDetailsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutWitnessDetailsInput, RoleUpdateWithoutWitnessDetailsInput>, RoleUncheckedUpdateWithoutWitnessDetailsInput>
  }

  export type AccountCreateNestedOneWithoutRoleInput = {
    create?: XOR<AccountCreateWithoutRoleInput, AccountUncheckedCreateWithoutRoleInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRoleInput
    connect?: AccountWhereUniqueInput
  }

  export type RoleTypeCreateNestedOneWithoutRoleInput = {
    create?: XOR<RoleTypeCreateWithoutRoleInput, RoleTypeUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleTypeCreateOrConnectWithoutRoleInput
    connect?: RoleTypeWhereUniqueInput
  }

  export type ClaimCreateNestedManyWithoutClientRoleInput = {
    create?: XOR<ClaimCreateWithoutClientRoleInput, ClaimUncheckedCreateWithoutClientRoleInput> | ClaimCreateWithoutClientRoleInput[] | ClaimUncheckedCreateWithoutClientRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClientRoleInput | ClaimCreateOrConnectWithoutClientRoleInput[]
    createMany?: ClaimCreateManyClientRoleInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimCreateNestedManyWithoutInjuredPartyRoleInput = {
    create?: XOR<ClaimCreateWithoutInjuredPartyRoleInput, ClaimUncheckedCreateWithoutInjuredPartyRoleInput> | ClaimCreateWithoutInjuredPartyRoleInput[] | ClaimUncheckedCreateWithoutInjuredPartyRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInjuredPartyRoleInput | ClaimCreateOrConnectWithoutInjuredPartyRoleInput[]
    createMany?: ClaimCreateManyInjuredPartyRoleInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimCreateNestedManyWithoutHealthInsuranceProviderInput = {
    create?: XOR<ClaimCreateWithoutHealthInsuranceProviderInput, ClaimUncheckedCreateWithoutHealthInsuranceProviderInput> | ClaimCreateWithoutHealthInsuranceProviderInput[] | ClaimUncheckedCreateWithoutHealthInsuranceProviderInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutHealthInsuranceProviderInput | ClaimCreateOrConnectWithoutHealthInsuranceProviderInput[]
    createMany?: ClaimCreateManyHealthInsuranceProviderInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type WitnessDetailsCreateNestedOneWithoutRoleInput = {
    create?: XOR<WitnessDetailsCreateWithoutRoleInput, WitnessDetailsUncheckedCreateWithoutRoleInput>
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutRoleInput
    connect?: WitnessDetailsWhereUniqueInput
  }

  export type DefendantDetailsCreateNestedManyWithoutDefendantAccountInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantAccountInput, DefendantDetailsUncheckedCreateWithoutDefendantAccountInput> | DefendantDetailsCreateWithoutDefendantAccountInput[] | DefendantDetailsUncheckedCreateWithoutDefendantAccountInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantAccountInput | DefendantDetailsCreateOrConnectWithoutDefendantAccountInput[]
    createMany?: DefendantDetailsCreateManyDefendantAccountInputEnvelope
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
  }

  export type DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput> | DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput | DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput[]
    createMany?: DefendantDetailsCreateManyDefendantInsuranceCarrierInputEnvelope
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
  }

  export type TreatmentCreateNestedManyWithoutRoleInput = {
    create?: XOR<TreatmentCreateWithoutRoleInput, TreatmentUncheckedCreateWithoutRoleInput> | TreatmentCreateWithoutRoleInput[] | TreatmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutRoleInput | TreatmentCreateOrConnectWithoutRoleInput[]
    createMany?: TreatmentCreateManyRoleInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type TreatmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    createMany?: TreatmentCreateManyDoctorInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutLawfirmInput = {
    create?: XOR<IncidentCreateWithoutLawfirmInput, IncidentUncheckedCreateWithoutLawfirmInput> | IncidentCreateWithoutLawfirmInput[] | IncidentUncheckedCreateWithoutLawfirmInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLawfirmInput | IncidentCreateOrConnectWithoutLawfirmInput[]
    createMany?: IncidentCreateManyLawfirmInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutPoliceStationInput = {
    create?: XOR<IncidentCreateWithoutPoliceStationInput, IncidentUncheckedCreateWithoutPoliceStationInput> | IncidentCreateWithoutPoliceStationInput[] | IncidentUncheckedCreateWithoutPoliceStationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceStationInput | IncidentCreateOrConnectWithoutPoliceStationInput[]
    createMany?: IncidentCreateManyPoliceStationInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutClientRoleInput = {
    create?: XOR<ClaimCreateWithoutClientRoleInput, ClaimUncheckedCreateWithoutClientRoleInput> | ClaimCreateWithoutClientRoleInput[] | ClaimUncheckedCreateWithoutClientRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClientRoleInput | ClaimCreateOrConnectWithoutClientRoleInput[]
    createMany?: ClaimCreateManyClientRoleInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput = {
    create?: XOR<ClaimCreateWithoutInjuredPartyRoleInput, ClaimUncheckedCreateWithoutInjuredPartyRoleInput> | ClaimCreateWithoutInjuredPartyRoleInput[] | ClaimUncheckedCreateWithoutInjuredPartyRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInjuredPartyRoleInput | ClaimCreateOrConnectWithoutInjuredPartyRoleInput[]
    createMany?: ClaimCreateManyInjuredPartyRoleInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput = {
    create?: XOR<ClaimCreateWithoutHealthInsuranceProviderInput, ClaimUncheckedCreateWithoutHealthInsuranceProviderInput> | ClaimCreateWithoutHealthInsuranceProviderInput[] | ClaimUncheckedCreateWithoutHealthInsuranceProviderInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutHealthInsuranceProviderInput | ClaimCreateOrConnectWithoutHealthInsuranceProviderInput[]
    createMany?: ClaimCreateManyHealthInsuranceProviderInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput = {
    create?: XOR<WitnessDetailsCreateWithoutRoleInput, WitnessDetailsUncheckedCreateWithoutRoleInput>
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutRoleInput
    connect?: WitnessDetailsWhereUniqueInput
  }

  export type DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantAccountInput, DefendantDetailsUncheckedCreateWithoutDefendantAccountInput> | DefendantDetailsCreateWithoutDefendantAccountInput[] | DefendantDetailsUncheckedCreateWithoutDefendantAccountInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantAccountInput | DefendantDetailsCreateOrConnectWithoutDefendantAccountInput[]
    createMany?: DefendantDetailsCreateManyDefendantAccountInputEnvelope
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
  }

  export type DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput> | DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput | DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput[]
    createMany?: DefendantDetailsCreateManyDefendantInsuranceCarrierInputEnvelope
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<TreatmentCreateWithoutRoleInput, TreatmentUncheckedCreateWithoutRoleInput> | TreatmentCreateWithoutRoleInput[] | TreatmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutRoleInput | TreatmentCreateOrConnectWithoutRoleInput[]
    createMany?: TreatmentCreateManyRoleInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    createMany?: TreatmentCreateManyDoctorInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutLawfirmInput = {
    create?: XOR<IncidentCreateWithoutLawfirmInput, IncidentUncheckedCreateWithoutLawfirmInput> | IncidentCreateWithoutLawfirmInput[] | IncidentUncheckedCreateWithoutLawfirmInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLawfirmInput | IncidentCreateOrConnectWithoutLawfirmInput[]
    createMany?: IncidentCreateManyLawfirmInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutPoliceStationInput = {
    create?: XOR<IncidentCreateWithoutPoliceStationInput, IncidentUncheckedCreateWithoutPoliceStationInput> | IncidentCreateWithoutPoliceStationInput[] | IncidentUncheckedCreateWithoutPoliceStationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceStationInput | IncidentCreateOrConnectWithoutPoliceStationInput[]
    createMany?: IncidentCreateManyPoliceStationInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type AccountUpdateOneWithoutRoleNestedInput = {
    create?: XOR<AccountCreateWithoutRoleInput, AccountUncheckedCreateWithoutRoleInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRoleInput
    upsert?: AccountUpsertWithoutRoleInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutRoleInput, AccountUpdateWithoutRoleInput>, AccountUncheckedUpdateWithoutRoleInput>
  }

  export type RoleTypeUpdateOneRequiredWithoutRoleNestedInput = {
    create?: XOR<RoleTypeCreateWithoutRoleInput, RoleTypeUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleTypeCreateOrConnectWithoutRoleInput
    upsert?: RoleTypeUpsertWithoutRoleInput
    connect?: RoleTypeWhereUniqueInput
    update?: XOR<XOR<RoleTypeUpdateToOneWithWhereWithoutRoleInput, RoleTypeUpdateWithoutRoleInput>, RoleTypeUncheckedUpdateWithoutRoleInput>
  }

  export type ClaimUpdateManyWithoutClientRoleNestedInput = {
    create?: XOR<ClaimCreateWithoutClientRoleInput, ClaimUncheckedCreateWithoutClientRoleInput> | ClaimCreateWithoutClientRoleInput[] | ClaimUncheckedCreateWithoutClientRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClientRoleInput | ClaimCreateOrConnectWithoutClientRoleInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutClientRoleInput | ClaimUpsertWithWhereUniqueWithoutClientRoleInput[]
    createMany?: ClaimCreateManyClientRoleInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutClientRoleInput | ClaimUpdateWithWhereUniqueWithoutClientRoleInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutClientRoleInput | ClaimUpdateManyWithWhereWithoutClientRoleInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUpdateManyWithoutInjuredPartyRoleNestedInput = {
    create?: XOR<ClaimCreateWithoutInjuredPartyRoleInput, ClaimUncheckedCreateWithoutInjuredPartyRoleInput> | ClaimCreateWithoutInjuredPartyRoleInput[] | ClaimUncheckedCreateWithoutInjuredPartyRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInjuredPartyRoleInput | ClaimCreateOrConnectWithoutInjuredPartyRoleInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutInjuredPartyRoleInput | ClaimUpsertWithWhereUniqueWithoutInjuredPartyRoleInput[]
    createMany?: ClaimCreateManyInjuredPartyRoleInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutInjuredPartyRoleInput | ClaimUpdateWithWhereUniqueWithoutInjuredPartyRoleInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutInjuredPartyRoleInput | ClaimUpdateManyWithWhereWithoutInjuredPartyRoleInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput = {
    create?: XOR<ClaimCreateWithoutHealthInsuranceProviderInput, ClaimUncheckedCreateWithoutHealthInsuranceProviderInput> | ClaimCreateWithoutHealthInsuranceProviderInput[] | ClaimUncheckedCreateWithoutHealthInsuranceProviderInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutHealthInsuranceProviderInput | ClaimCreateOrConnectWithoutHealthInsuranceProviderInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutHealthInsuranceProviderInput | ClaimUpsertWithWhereUniqueWithoutHealthInsuranceProviderInput[]
    createMany?: ClaimCreateManyHealthInsuranceProviderInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutHealthInsuranceProviderInput | ClaimUpdateWithWhereUniqueWithoutHealthInsuranceProviderInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutHealthInsuranceProviderInput | ClaimUpdateManyWithWhereWithoutHealthInsuranceProviderInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type WitnessDetailsUpdateOneWithoutRoleNestedInput = {
    create?: XOR<WitnessDetailsCreateWithoutRoleInput, WitnessDetailsUncheckedCreateWithoutRoleInput>
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutRoleInput
    upsert?: WitnessDetailsUpsertWithoutRoleInput
    disconnect?: WitnessDetailsWhereInput | boolean
    delete?: WitnessDetailsWhereInput | boolean
    connect?: WitnessDetailsWhereUniqueInput
    update?: XOR<XOR<WitnessDetailsUpdateToOneWithWhereWithoutRoleInput, WitnessDetailsUpdateWithoutRoleInput>, WitnessDetailsUncheckedUpdateWithoutRoleInput>
  }

  export type DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantAccountInput, DefendantDetailsUncheckedCreateWithoutDefendantAccountInput> | DefendantDetailsCreateWithoutDefendantAccountInput[] | DefendantDetailsUncheckedCreateWithoutDefendantAccountInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantAccountInput | DefendantDetailsCreateOrConnectWithoutDefendantAccountInput[]
    upsert?: DefendantDetailsUpsertWithWhereUniqueWithoutDefendantAccountInput | DefendantDetailsUpsertWithWhereUniqueWithoutDefendantAccountInput[]
    createMany?: DefendantDetailsCreateManyDefendantAccountInputEnvelope
    set?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    disconnect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    delete?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    update?: DefendantDetailsUpdateWithWhereUniqueWithoutDefendantAccountInput | DefendantDetailsUpdateWithWhereUniqueWithoutDefendantAccountInput[]
    updateMany?: DefendantDetailsUpdateManyWithWhereWithoutDefendantAccountInput | DefendantDetailsUpdateManyWithWhereWithoutDefendantAccountInput[]
    deleteMany?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
  }

  export type DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput> | DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput | DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput[]
    upsert?: DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInsuranceCarrierInput | DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInsuranceCarrierInput[]
    createMany?: DefendantDetailsCreateManyDefendantInsuranceCarrierInputEnvelope
    set?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    disconnect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    delete?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    update?: DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInsuranceCarrierInput | DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInsuranceCarrierInput[]
    updateMany?: DefendantDetailsUpdateManyWithWhereWithoutDefendantInsuranceCarrierInput | DefendantDetailsUpdateManyWithWhereWithoutDefendantInsuranceCarrierInput[]
    deleteMany?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
  }

  export type TreatmentUpdateManyWithoutRoleNestedInput = {
    create?: XOR<TreatmentCreateWithoutRoleInput, TreatmentUncheckedCreateWithoutRoleInput> | TreatmentCreateWithoutRoleInput[] | TreatmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutRoleInput | TreatmentCreateOrConnectWithoutRoleInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutRoleInput | TreatmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: TreatmentCreateManyRoleInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutRoleInput | TreatmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutRoleInput | TreatmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type TreatmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutDoctorInput | TreatmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: TreatmentCreateManyDoctorInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutDoctorInput | TreatmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutDoctorInput | TreatmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutLawfirmNestedInput = {
    create?: XOR<IncidentCreateWithoutLawfirmInput, IncidentUncheckedCreateWithoutLawfirmInput> | IncidentCreateWithoutLawfirmInput[] | IncidentUncheckedCreateWithoutLawfirmInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLawfirmInput | IncidentCreateOrConnectWithoutLawfirmInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutLawfirmInput | IncidentUpsertWithWhereUniqueWithoutLawfirmInput[]
    createMany?: IncidentCreateManyLawfirmInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutLawfirmInput | IncidentUpdateWithWhereUniqueWithoutLawfirmInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutLawfirmInput | IncidentUpdateManyWithWhereWithoutLawfirmInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutPoliceStationNestedInput = {
    create?: XOR<IncidentCreateWithoutPoliceStationInput, IncidentUncheckedCreateWithoutPoliceStationInput> | IncidentCreateWithoutPoliceStationInput[] | IncidentUncheckedCreateWithoutPoliceStationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceStationInput | IncidentCreateOrConnectWithoutPoliceStationInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutPoliceStationInput | IncidentUpsertWithWhereUniqueWithoutPoliceStationInput[]
    createMany?: IncidentCreateManyPoliceStationInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutPoliceStationInput | IncidentUpdateWithWhereUniqueWithoutPoliceStationInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutPoliceStationInput | IncidentUpdateManyWithWhereWithoutPoliceStationInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutClientRoleNestedInput = {
    create?: XOR<ClaimCreateWithoutClientRoleInput, ClaimUncheckedCreateWithoutClientRoleInput> | ClaimCreateWithoutClientRoleInput[] | ClaimUncheckedCreateWithoutClientRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClientRoleInput | ClaimCreateOrConnectWithoutClientRoleInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutClientRoleInput | ClaimUpsertWithWhereUniqueWithoutClientRoleInput[]
    createMany?: ClaimCreateManyClientRoleInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutClientRoleInput | ClaimUpdateWithWhereUniqueWithoutClientRoleInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutClientRoleInput | ClaimUpdateManyWithWhereWithoutClientRoleInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput = {
    create?: XOR<ClaimCreateWithoutInjuredPartyRoleInput, ClaimUncheckedCreateWithoutInjuredPartyRoleInput> | ClaimCreateWithoutInjuredPartyRoleInput[] | ClaimUncheckedCreateWithoutInjuredPartyRoleInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInjuredPartyRoleInput | ClaimCreateOrConnectWithoutInjuredPartyRoleInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutInjuredPartyRoleInput | ClaimUpsertWithWhereUniqueWithoutInjuredPartyRoleInput[]
    createMany?: ClaimCreateManyInjuredPartyRoleInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutInjuredPartyRoleInput | ClaimUpdateWithWhereUniqueWithoutInjuredPartyRoleInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutInjuredPartyRoleInput | ClaimUpdateManyWithWhereWithoutInjuredPartyRoleInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput = {
    create?: XOR<ClaimCreateWithoutHealthInsuranceProviderInput, ClaimUncheckedCreateWithoutHealthInsuranceProviderInput> | ClaimCreateWithoutHealthInsuranceProviderInput[] | ClaimUncheckedCreateWithoutHealthInsuranceProviderInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutHealthInsuranceProviderInput | ClaimCreateOrConnectWithoutHealthInsuranceProviderInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutHealthInsuranceProviderInput | ClaimUpsertWithWhereUniqueWithoutHealthInsuranceProviderInput[]
    createMany?: ClaimCreateManyHealthInsuranceProviderInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutHealthInsuranceProviderInput | ClaimUpdateWithWhereUniqueWithoutHealthInsuranceProviderInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutHealthInsuranceProviderInput | ClaimUpdateManyWithWhereWithoutHealthInsuranceProviderInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput = {
    create?: XOR<WitnessDetailsCreateWithoutRoleInput, WitnessDetailsUncheckedCreateWithoutRoleInput>
    connectOrCreate?: WitnessDetailsCreateOrConnectWithoutRoleInput
    upsert?: WitnessDetailsUpsertWithoutRoleInput
    disconnect?: WitnessDetailsWhereInput | boolean
    delete?: WitnessDetailsWhereInput | boolean
    connect?: WitnessDetailsWhereUniqueInput
    update?: XOR<XOR<WitnessDetailsUpdateToOneWithWhereWithoutRoleInput, WitnessDetailsUpdateWithoutRoleInput>, WitnessDetailsUncheckedUpdateWithoutRoleInput>
  }

  export type DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantAccountInput, DefendantDetailsUncheckedCreateWithoutDefendantAccountInput> | DefendantDetailsCreateWithoutDefendantAccountInput[] | DefendantDetailsUncheckedCreateWithoutDefendantAccountInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantAccountInput | DefendantDetailsCreateOrConnectWithoutDefendantAccountInput[]
    upsert?: DefendantDetailsUpsertWithWhereUniqueWithoutDefendantAccountInput | DefendantDetailsUpsertWithWhereUniqueWithoutDefendantAccountInput[]
    createMany?: DefendantDetailsCreateManyDefendantAccountInputEnvelope
    set?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    disconnect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    delete?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    update?: DefendantDetailsUpdateWithWhereUniqueWithoutDefendantAccountInput | DefendantDetailsUpdateWithWhereUniqueWithoutDefendantAccountInput[]
    updateMany?: DefendantDetailsUpdateManyWithWhereWithoutDefendantAccountInput | DefendantDetailsUpdateManyWithWhereWithoutDefendantAccountInput[]
    deleteMany?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
  }

  export type DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput = {
    create?: XOR<DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput> | DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput[] | DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput[]
    connectOrCreate?: DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput | DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput[]
    upsert?: DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInsuranceCarrierInput | DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInsuranceCarrierInput[]
    createMany?: DefendantDetailsCreateManyDefendantInsuranceCarrierInputEnvelope
    set?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    disconnect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    delete?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    connect?: DefendantDetailsWhereUniqueInput | DefendantDetailsWhereUniqueInput[]
    update?: DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInsuranceCarrierInput | DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInsuranceCarrierInput[]
    updateMany?: DefendantDetailsUpdateManyWithWhereWithoutDefendantInsuranceCarrierInput | DefendantDetailsUpdateManyWithWhereWithoutDefendantInsuranceCarrierInput[]
    deleteMany?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<TreatmentCreateWithoutRoleInput, TreatmentUncheckedCreateWithoutRoleInput> | TreatmentCreateWithoutRoleInput[] | TreatmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutRoleInput | TreatmentCreateOrConnectWithoutRoleInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutRoleInput | TreatmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: TreatmentCreateManyRoleInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutRoleInput | TreatmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutRoleInput | TreatmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutDoctorInput | TreatmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: TreatmentCreateManyDoctorInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutDoctorInput | TreatmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutDoctorInput | TreatmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutLawfirmNestedInput = {
    create?: XOR<IncidentCreateWithoutLawfirmInput, IncidentUncheckedCreateWithoutLawfirmInput> | IncidentCreateWithoutLawfirmInput[] | IncidentUncheckedCreateWithoutLawfirmInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLawfirmInput | IncidentCreateOrConnectWithoutLawfirmInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutLawfirmInput | IncidentUpsertWithWhereUniqueWithoutLawfirmInput[]
    createMany?: IncidentCreateManyLawfirmInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutLawfirmInput | IncidentUpdateWithWhereUniqueWithoutLawfirmInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutLawfirmInput | IncidentUpdateManyWithWhereWithoutLawfirmInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput = {
    create?: XOR<IncidentCreateWithoutPoliceStationInput, IncidentUncheckedCreateWithoutPoliceStationInput> | IncidentCreateWithoutPoliceStationInput[] | IncidentUncheckedCreateWithoutPoliceStationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceStationInput | IncidentCreateOrConnectWithoutPoliceStationInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutPoliceStationInput | IncidentUpsertWithWhereUniqueWithoutPoliceStationInput[]
    createMany?: IncidentCreateManyPoliceStationInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutPoliceStationInput | IncidentUpdateWithWhereUniqueWithoutPoliceStationInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutPoliceStationInput | IncidentUpdateManyWithWhereWithoutPoliceStationInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type RoleCreateNestedManyWithoutRoletypeInput = {
    create?: XOR<RoleCreateWithoutRoletypeInput, RoleUncheckedCreateWithoutRoletypeInput> | RoleCreateWithoutRoletypeInput[] | RoleUncheckedCreateWithoutRoletypeInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutRoletypeInput | RoleCreateOrConnectWithoutRoletypeInput[]
    createMany?: RoleCreateManyRoletypeInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutRoletypeInput = {
    create?: XOR<RoleCreateWithoutRoletypeInput, RoleUncheckedCreateWithoutRoletypeInput> | RoleCreateWithoutRoletypeInput[] | RoleUncheckedCreateWithoutRoletypeInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutRoletypeInput | RoleCreateOrConnectWithoutRoletypeInput[]
    createMany?: RoleCreateManyRoletypeInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUpdateManyWithoutRoletypeNestedInput = {
    create?: XOR<RoleCreateWithoutRoletypeInput, RoleUncheckedCreateWithoutRoletypeInput> | RoleCreateWithoutRoletypeInput[] | RoleUncheckedCreateWithoutRoletypeInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutRoletypeInput | RoleCreateOrConnectWithoutRoletypeInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutRoletypeInput | RoleUpsertWithWhereUniqueWithoutRoletypeInput[]
    createMany?: RoleCreateManyRoletypeInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutRoletypeInput | RoleUpdateWithWhereUniqueWithoutRoletypeInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutRoletypeInput | RoleUpdateManyWithWhereWithoutRoletypeInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutRoletypeNestedInput = {
    create?: XOR<RoleCreateWithoutRoletypeInput, RoleUncheckedCreateWithoutRoletypeInput> | RoleCreateWithoutRoletypeInput[] | RoleUncheckedCreateWithoutRoletypeInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutRoletypeInput | RoleCreateOrConnectWithoutRoletypeInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutRoletypeInput | RoleUpsertWithWhereUniqueWithoutRoletypeInput[]
    createMany?: RoleCreateManyRoletypeInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutRoletypeInput | RoleUpdateWithWhereUniqueWithoutRoletypeInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutRoletypeInput | RoleUpdateManyWithWhereWithoutRoletypeInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type RoleCreateNestedManyWithoutAccountInput = {
    create?: XOR<RoleCreateWithoutAccountInput, RoleUncheckedCreateWithoutAccountInput> | RoleCreateWithoutAccountInput[] | RoleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutAccountInput | RoleCreateOrConnectWithoutAccountInput[]
    createMany?: RoleCreateManyAccountInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type SubAccountCreateNestedManyWithoutAccountInput = {
    create?: XOR<SubAccountCreateWithoutAccountInput, SubAccountUncheckedCreateWithoutAccountInput> | SubAccountCreateWithoutAccountInput[] | SubAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAccountInput | SubAccountCreateOrConnectWithoutAccountInput[]
    createMany?: SubAccountCreateManyAccountInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type ProjectAccountCreateNestedManyWithoutAccountInput = {
    create?: XOR<ProjectAccountCreateWithoutAccountInput, ProjectAccountUncheckedCreateWithoutAccountInput> | ProjectAccountCreateWithoutAccountInput[] | ProjectAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutAccountInput | ProjectAccountCreateOrConnectWithoutAccountInput[]
    createMany?: ProjectAccountCreateManyAccountInputEnvelope
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
  }

  export type TaskAccountCreateNestedManyWithoutAccountInput = {
    create?: XOR<TaskAccountCreateWithoutAccountInput, TaskAccountUncheckedCreateWithoutAccountInput> | TaskAccountCreateWithoutAccountInput[] | TaskAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutAccountInput | TaskAccountCreateOrConnectWithoutAccountInput[]
    createMany?: TaskAccountCreateManyAccountInputEnvelope
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<RoleCreateWithoutAccountInput, RoleUncheckedCreateWithoutAccountInput> | RoleCreateWithoutAccountInput[] | RoleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutAccountInput | RoleCreateOrConnectWithoutAccountInput[]
    createMany?: RoleCreateManyAccountInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type SubAccountUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<SubAccountCreateWithoutAccountInput, SubAccountUncheckedCreateWithoutAccountInput> | SubAccountCreateWithoutAccountInput[] | SubAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAccountInput | SubAccountCreateOrConnectWithoutAccountInput[]
    createMany?: SubAccountCreateManyAccountInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type ProjectAccountUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ProjectAccountCreateWithoutAccountInput, ProjectAccountUncheckedCreateWithoutAccountInput> | ProjectAccountCreateWithoutAccountInput[] | ProjectAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutAccountInput | ProjectAccountCreateOrConnectWithoutAccountInput[]
    createMany?: ProjectAccountCreateManyAccountInputEnvelope
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
  }

  export type TaskAccountUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TaskAccountCreateWithoutAccountInput, TaskAccountUncheckedCreateWithoutAccountInput> | TaskAccountCreateWithoutAccountInput[] | TaskAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutAccountInput | TaskAccountCreateOrConnectWithoutAccountInput[]
    createMany?: TaskAccountCreateManyAccountInputEnvelope
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
  }

  export type RoleUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RoleCreateWithoutAccountInput, RoleUncheckedCreateWithoutAccountInput> | RoleCreateWithoutAccountInput[] | RoleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutAccountInput | RoleCreateOrConnectWithoutAccountInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutAccountInput | RoleUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RoleCreateManyAccountInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutAccountInput | RoleUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutAccountInput | RoleUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type SubAccountUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SubAccountCreateWithoutAccountInput, SubAccountUncheckedCreateWithoutAccountInput> | SubAccountCreateWithoutAccountInput[] | SubAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAccountInput | SubAccountCreateOrConnectWithoutAccountInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutAccountInput | SubAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SubAccountCreateManyAccountInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutAccountInput | SubAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutAccountInput | SubAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type ProjectAccountUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ProjectAccountCreateWithoutAccountInput, ProjectAccountUncheckedCreateWithoutAccountInput> | ProjectAccountCreateWithoutAccountInput[] | ProjectAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutAccountInput | ProjectAccountCreateOrConnectWithoutAccountInput[]
    upsert?: ProjectAccountUpsertWithWhereUniqueWithoutAccountInput | ProjectAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ProjectAccountCreateManyAccountInputEnvelope
    set?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    disconnect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    delete?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    update?: ProjectAccountUpdateWithWhereUniqueWithoutAccountInput | ProjectAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ProjectAccountUpdateManyWithWhereWithoutAccountInput | ProjectAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ProjectAccountScalarWhereInput | ProjectAccountScalarWhereInput[]
  }

  export type TaskAccountUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TaskAccountCreateWithoutAccountInput, TaskAccountUncheckedCreateWithoutAccountInput> | TaskAccountCreateWithoutAccountInput[] | TaskAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutAccountInput | TaskAccountCreateOrConnectWithoutAccountInput[]
    upsert?: TaskAccountUpsertWithWhereUniqueWithoutAccountInput | TaskAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TaskAccountCreateManyAccountInputEnvelope
    set?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    disconnect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    delete?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    update?: TaskAccountUpdateWithWhereUniqueWithoutAccountInput | TaskAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TaskAccountUpdateManyWithWhereWithoutAccountInput | TaskAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TaskAccountScalarWhereInput | TaskAccountScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RoleCreateWithoutAccountInput, RoleUncheckedCreateWithoutAccountInput> | RoleCreateWithoutAccountInput[] | RoleUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutAccountInput | RoleCreateOrConnectWithoutAccountInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutAccountInput | RoleUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RoleCreateManyAccountInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutAccountInput | RoleUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutAccountInput | RoleUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type SubAccountUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SubAccountCreateWithoutAccountInput, SubAccountUncheckedCreateWithoutAccountInput> | SubAccountCreateWithoutAccountInput[] | SubAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAccountInput | SubAccountCreateOrConnectWithoutAccountInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutAccountInput | SubAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SubAccountCreateManyAccountInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutAccountInput | SubAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutAccountInput | SubAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type ProjectAccountUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ProjectAccountCreateWithoutAccountInput, ProjectAccountUncheckedCreateWithoutAccountInput> | ProjectAccountCreateWithoutAccountInput[] | ProjectAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProjectAccountCreateOrConnectWithoutAccountInput | ProjectAccountCreateOrConnectWithoutAccountInput[]
    upsert?: ProjectAccountUpsertWithWhereUniqueWithoutAccountInput | ProjectAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ProjectAccountCreateManyAccountInputEnvelope
    set?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    disconnect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    delete?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    connect?: ProjectAccountWhereUniqueInput | ProjectAccountWhereUniqueInput[]
    update?: ProjectAccountUpdateWithWhereUniqueWithoutAccountInput | ProjectAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ProjectAccountUpdateManyWithWhereWithoutAccountInput | ProjectAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ProjectAccountScalarWhereInput | ProjectAccountScalarWhereInput[]
  }

  export type TaskAccountUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TaskAccountCreateWithoutAccountInput, TaskAccountUncheckedCreateWithoutAccountInput> | TaskAccountCreateWithoutAccountInput[] | TaskAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaskAccountCreateOrConnectWithoutAccountInput | TaskAccountCreateOrConnectWithoutAccountInput[]
    upsert?: TaskAccountUpsertWithWhereUniqueWithoutAccountInput | TaskAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TaskAccountCreateManyAccountInputEnvelope
    set?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    disconnect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    delete?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    connect?: TaskAccountWhereUniqueInput | TaskAccountWhereUniqueInput[]
    update?: TaskAccountUpdateWithWhereUniqueWithoutAccountInput | TaskAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TaskAccountUpdateManyWithWhereWithoutAccountInput | TaskAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TaskAccountScalarWhereInput | TaskAccountScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutSubAccountInput = {
    create?: XOR<AccountCreateWithoutSubAccountInput, AccountUncheckedCreateWithoutSubAccountInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSubAccountInput
    connect?: AccountWhereUniqueInput
  }

  export type IncidentCreateNestedManyWithoutAttorneyInput = {
    create?: XOR<IncidentCreateWithoutAttorneyInput, IncidentUncheckedCreateWithoutAttorneyInput> | IncidentCreateWithoutAttorneyInput[] | IncidentUncheckedCreateWithoutAttorneyInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAttorneyInput | IncidentCreateOrConnectWithoutAttorneyInput[]
    createMany?: IncidentCreateManyAttorneyInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutPoliceOfficerInput = {
    create?: XOR<IncidentCreateWithoutPoliceOfficerInput, IncidentUncheckedCreateWithoutPoliceOfficerInput> | IncidentCreateWithoutPoliceOfficerInput[] | IncidentUncheckedCreateWithoutPoliceOfficerInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceOfficerInput | IncidentCreateOrConnectWithoutPoliceOfficerInput[]
    createMany?: IncidentCreateManyPoliceOfficerInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutAttorneyInput = {
    create?: XOR<IncidentCreateWithoutAttorneyInput, IncidentUncheckedCreateWithoutAttorneyInput> | IncidentCreateWithoutAttorneyInput[] | IncidentUncheckedCreateWithoutAttorneyInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAttorneyInput | IncidentCreateOrConnectWithoutAttorneyInput[]
    createMany?: IncidentCreateManyAttorneyInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutPoliceOfficerInput = {
    create?: XOR<IncidentCreateWithoutPoliceOfficerInput, IncidentUncheckedCreateWithoutPoliceOfficerInput> | IncidentCreateWithoutPoliceOfficerInput[] | IncidentUncheckedCreateWithoutPoliceOfficerInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceOfficerInput | IncidentCreateOrConnectWithoutPoliceOfficerInput[]
    createMany?: IncidentCreateManyPoliceOfficerInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutSubAccountNestedInput = {
    create?: XOR<AccountCreateWithoutSubAccountInput, AccountUncheckedCreateWithoutSubAccountInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSubAccountInput
    upsert?: AccountUpsertWithoutSubAccountInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSubAccountInput, AccountUpdateWithoutSubAccountInput>, AccountUncheckedUpdateWithoutSubAccountInput>
  }

  export type IncidentUpdateManyWithoutAttorneyNestedInput = {
    create?: XOR<IncidentCreateWithoutAttorneyInput, IncidentUncheckedCreateWithoutAttorneyInput> | IncidentCreateWithoutAttorneyInput[] | IncidentUncheckedCreateWithoutAttorneyInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAttorneyInput | IncidentCreateOrConnectWithoutAttorneyInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutAttorneyInput | IncidentUpsertWithWhereUniqueWithoutAttorneyInput[]
    createMany?: IncidentCreateManyAttorneyInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutAttorneyInput | IncidentUpdateWithWhereUniqueWithoutAttorneyInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutAttorneyInput | IncidentUpdateManyWithWhereWithoutAttorneyInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutPoliceOfficerNestedInput = {
    create?: XOR<IncidentCreateWithoutPoliceOfficerInput, IncidentUncheckedCreateWithoutPoliceOfficerInput> | IncidentCreateWithoutPoliceOfficerInput[] | IncidentUncheckedCreateWithoutPoliceOfficerInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceOfficerInput | IncidentCreateOrConnectWithoutPoliceOfficerInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutPoliceOfficerInput | IncidentUpsertWithWhereUniqueWithoutPoliceOfficerInput[]
    createMany?: IncidentCreateManyPoliceOfficerInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutPoliceOfficerInput | IncidentUpdateWithWhereUniqueWithoutPoliceOfficerInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutPoliceOfficerInput | IncidentUpdateManyWithWhereWithoutPoliceOfficerInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutAttorneyNestedInput = {
    create?: XOR<IncidentCreateWithoutAttorneyInput, IncidentUncheckedCreateWithoutAttorneyInput> | IncidentCreateWithoutAttorneyInput[] | IncidentUncheckedCreateWithoutAttorneyInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAttorneyInput | IncidentCreateOrConnectWithoutAttorneyInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutAttorneyInput | IncidentUpsertWithWhereUniqueWithoutAttorneyInput[]
    createMany?: IncidentCreateManyAttorneyInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutAttorneyInput | IncidentUpdateWithWhereUniqueWithoutAttorneyInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutAttorneyInput | IncidentUpdateManyWithWhereWithoutAttorneyInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutPoliceOfficerNestedInput = {
    create?: XOR<IncidentCreateWithoutPoliceOfficerInput, IncidentUncheckedCreateWithoutPoliceOfficerInput> | IncidentCreateWithoutPoliceOfficerInput[] | IncidentUncheckedCreateWithoutPoliceOfficerInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutPoliceOfficerInput | IncidentCreateOrConnectWithoutPoliceOfficerInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutPoliceOfficerInput | IncidentUpsertWithWhereUniqueWithoutPoliceOfficerInput[]
    createMany?: IncidentCreateManyPoliceOfficerInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutPoliceOfficerInput | IncidentUpdateWithWhereUniqueWithoutPoliceOfficerInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutPoliceOfficerInput | IncidentUpdateManyWithWhereWithoutPoliceOfficerInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumWereYouInjuredFilter<$PrismaModel = never> = {
    equals?: $Enums.WereYouInjured | EnumWereYouInjuredFieldRefInput<$PrismaModel>
    in?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    notIn?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    not?: NestedEnumWereYouInjuredFilter<$PrismaModel> | $Enums.WereYouInjured
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumWereYouInjuredWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WereYouInjured | EnumWereYouInjuredFieldRefInput<$PrismaModel>
    in?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    notIn?: $Enums.WereYouInjured[] | ListEnumWereYouInjuredFieldRefInput<$PrismaModel>
    not?: NestedEnumWereYouInjuredWithAggregatesFilter<$PrismaModel> | $Enums.WereYouInjured
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWereYouInjuredFilter<$PrismaModel>
    _max?: NestedEnumWereYouInjuredFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClaimStatusNullableFilter<$PrismaModel> | $Enums.ClaimStatus | null
  }

  export type NestedEnumRelationshipNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Relationship | EnumRelationshipFieldRefInput<$PrismaModel> | null
    in?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipNullableFilter<$PrismaModel> | $Enums.Relationship | null
  }

  export type NestedEnumClaimStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClaimStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumRelationshipNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Relationship | EnumRelationshipFieldRefInput<$PrismaModel> | null
    in?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Relationship[] | ListEnumRelationshipFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipNullableWithAggregatesFilter<$PrismaModel> | $Enums.Relationship | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRelationshipNullableFilter<$PrismaModel>
    _max?: NestedEnumRelationshipNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumDefendantRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.DefendantRole | EnumDefendantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDefendantRoleFilter<$PrismaModel> | $Enums.DefendantRole
  }

  export type NestedEnumCollisionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CollisionType | EnumCollisionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCollisionTypeNullableFilter<$PrismaModel> | $Enums.CollisionType | null
  }

  export type NestedEnumDefendantRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefendantRole | EnumDefendantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefendantRole[] | ListEnumDefendantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDefendantRoleWithAggregatesFilter<$PrismaModel> | $Enums.DefendantRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefendantRoleFilter<$PrismaModel>
    _max?: NestedEnumDefendantRoleFilter<$PrismaModel>
  }

  export type NestedEnumCollisionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollisionType | EnumCollisionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CollisionType[] | ListEnumCollisionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCollisionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CollisionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCollisionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCollisionTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumInjuryPointFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryPoint | EnumInjuryPointFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryPointFilter<$PrismaModel> | $Enums.InjuryPoint
  }

  export type NestedEnumInjuryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryType | EnumInjuryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryTypeFilter<$PrismaModel> | $Enums.InjuryType
  }

  export type NestedEnumInjurySideFilter<$PrismaModel = never> = {
    equals?: $Enums.InjurySide | EnumInjurySideFieldRefInput<$PrismaModel>
    in?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    not?: NestedEnumInjurySideFilter<$PrismaModel> | $Enums.InjurySide
  }

  export type NestedEnumInjuryPointWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryPoint | EnumInjuryPointFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryPoint[] | ListEnumInjuryPointFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryPointWithAggregatesFilter<$PrismaModel> | $Enums.InjuryPoint
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryPointFilter<$PrismaModel>
    _max?: NestedEnumInjuryPointFilter<$PrismaModel>
  }

  export type NestedEnumInjuryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryType | EnumInjuryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryType[] | ListEnumInjuryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryTypeWithAggregatesFilter<$PrismaModel> | $Enums.InjuryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryTypeFilter<$PrismaModel>
    _max?: NestedEnumInjuryTypeFilter<$PrismaModel>
  }

  export type NestedEnumInjurySideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjurySide | EnumInjurySideFieldRefInput<$PrismaModel>
    in?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjurySide[] | ListEnumInjurySideFieldRefInput<$PrismaModel>
    not?: NestedEnumInjurySideWithAggregatesFilter<$PrismaModel> | $Enums.InjurySide
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjurySideFilter<$PrismaModel>
    _max?: NestedEnumInjurySideFilter<$PrismaModel>
  }

  export type NestedEnumBusOrVehicleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BusOrVehicle | EnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusOrVehicleNullableFilter<$PrismaModel> | $Enums.BusOrVehicle | null
  }

  export type NestedEnumTransportTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TransportType | EnumTransportTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransportTypeNullableFilter<$PrismaModel> | $Enums.TransportType | null
  }

  export type NestedEnumPropertyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableFilter<$PrismaModel> | $Enums.PropertyType | null
  }

  export type NestedEnumBusOrVehicleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusOrVehicle | EnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusOrVehicle[] | ListEnumBusOrVehicleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusOrVehicleNullableWithAggregatesFilter<$PrismaModel> | $Enums.BusOrVehicle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBusOrVehicleNullableFilter<$PrismaModel>
    _max?: NestedEnumBusOrVehicleNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransportTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransportType | EnumTransportTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransportType[] | ListEnumTransportTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransportTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TransportType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTransportTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTransportTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutProjectsOwnedInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutProjectsOwnedInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutProjectsOwnedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsOwnedInput, UserUncheckedCreateWithoutProjectsOwnedInput>
  }

  export type BoardCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: ColumnCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: ColumnUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutProjectInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput>
  }

  export type BoardCreateManyProjectInputEnvelope = {
    data: BoardCreateManyProjectInput | BoardCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectClaimCreateWithoutProjectInput = {
    assignedAt?: Date | string
    claim: ClaimCreateNestedOneWithoutProjectClaimsInput
  }

  export type ProjectClaimUncheckedCreateWithoutProjectInput = {
    claimId: string
    assignedAt?: Date | string
  }

  export type ProjectClaimCreateOrConnectWithoutProjectInput = {
    where: ProjectClaimWhereUniqueInput
    create: XOR<ProjectClaimCreateWithoutProjectInput, ProjectClaimUncheckedCreateWithoutProjectInput>
  }

  export type ProjectClaimCreateManyProjectInputEnvelope = {
    data: ProjectClaimCreateManyProjectInput | ProjectClaimCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectAccountCreateWithoutProjectInput = {
    assignedAt?: Date | string
    account: AccountCreateNestedOneWithoutProjectAccountsInput
  }

  export type ProjectAccountUncheckedCreateWithoutProjectInput = {
    accountId: string
    assignedAt?: Date | string
  }

  export type ProjectAccountCreateOrConnectWithoutProjectInput = {
    where: ProjectAccountWhereUniqueInput
    create: XOR<ProjectAccountCreateWithoutProjectInput, ProjectAccountUncheckedCreateWithoutProjectInput>
  }

  export type ProjectAccountCreateManyProjectInputEnvelope = {
    data: ProjectAccountCreateManyProjectInput | ProjectAccountCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUserCreateWithoutProjectInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectAssignmentsInput
  }

  export type ProjectUserUncheckedCreateWithoutProjectInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type ProjectUserCreateOrConnectWithoutProjectInput = {
    where: ProjectUserWhereUniqueInput
    create: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUserCreateManyProjectInputEnvelope = {
    data: ProjectUserCreateManyProjectInput | ProjectUserCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsOwnedInput = {
    update: XOR<UserUpdateWithoutProjectsOwnedInput, UserUncheckedUpdateWithoutProjectsOwnedInput>
    create: XOR<UserCreateWithoutProjectsOwnedInput, UserUncheckedCreateWithoutProjectsOwnedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsOwnedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsOwnedInput, UserUncheckedUpdateWithoutProjectsOwnedInput>
  }

  export type UserUpdateWithoutProjectsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type BoardUpsertWithWhereUniqueWithoutProjectInput = {
    where: BoardWhereUniqueInput
    update: XOR<BoardUpdateWithoutProjectInput, BoardUncheckedUpdateWithoutProjectInput>
    create: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput>
  }

  export type BoardUpdateWithWhereUniqueWithoutProjectInput = {
    where: BoardWhereUniqueInput
    data: XOR<BoardUpdateWithoutProjectInput, BoardUncheckedUpdateWithoutProjectInput>
  }

  export type BoardUpdateManyWithWhereWithoutProjectInput = {
    where: BoardScalarWhereInput
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyWithoutProjectInput>
  }

  export type BoardScalarWhereInput = {
    AND?: BoardScalarWhereInput | BoardScalarWhereInput[]
    OR?: BoardScalarWhereInput[]
    NOT?: BoardScalarWhereInput | BoardScalarWhereInput[]
    id?: StringFilter<"Board"> | string
    title?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    projectId?: StringFilter<"Board"> | string
  }

  export type ProjectClaimUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectClaimWhereUniqueInput
    update: XOR<ProjectClaimUpdateWithoutProjectInput, ProjectClaimUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectClaimCreateWithoutProjectInput, ProjectClaimUncheckedCreateWithoutProjectInput>
  }

  export type ProjectClaimUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectClaimWhereUniqueInput
    data: XOR<ProjectClaimUpdateWithoutProjectInput, ProjectClaimUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectClaimUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectClaimScalarWhereInput
    data: XOR<ProjectClaimUpdateManyMutationInput, ProjectClaimUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectClaimScalarWhereInput = {
    AND?: ProjectClaimScalarWhereInput | ProjectClaimScalarWhereInput[]
    OR?: ProjectClaimScalarWhereInput[]
    NOT?: ProjectClaimScalarWhereInput | ProjectClaimScalarWhereInput[]
    projectId?: StringFilter<"ProjectClaim"> | string
    claimId?: StringFilter<"ProjectClaim"> | string
    assignedAt?: DateTimeFilter<"ProjectClaim"> | Date | string
  }

  export type ProjectAccountUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectAccountWhereUniqueInput
    update: XOR<ProjectAccountUpdateWithoutProjectInput, ProjectAccountUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectAccountCreateWithoutProjectInput, ProjectAccountUncheckedCreateWithoutProjectInput>
  }

  export type ProjectAccountUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectAccountWhereUniqueInput
    data: XOR<ProjectAccountUpdateWithoutProjectInput, ProjectAccountUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectAccountUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectAccountScalarWhereInput
    data: XOR<ProjectAccountUpdateManyMutationInput, ProjectAccountUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectAccountScalarWhereInput = {
    AND?: ProjectAccountScalarWhereInput | ProjectAccountScalarWhereInput[]
    OR?: ProjectAccountScalarWhereInput[]
    NOT?: ProjectAccountScalarWhereInput | ProjectAccountScalarWhereInput[]
    projectId?: StringFilter<"ProjectAccount"> | string
    accountId?: StringFilter<"ProjectAccount"> | string
    assignedAt?: DateTimeFilter<"ProjectAccount"> | Date | string
  }

  export type ProjectUserUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectUserWhereUniqueInput
    update: XOR<ProjectUserUpdateWithoutProjectInput, ProjectUserUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUserUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectUserWhereUniqueInput
    data: XOR<ProjectUserUpdateWithoutProjectInput, ProjectUserUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectUserUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectUserScalarWhereInput
    data: XOR<ProjectUserUpdateManyMutationInput, ProjectUserUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectUserScalarWhereInput = {
    AND?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
    OR?: ProjectUserScalarWhereInput[]
    NOT?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
    projectId?: StringFilter<"ProjectUser"> | string
    userId?: StringFilter<"ProjectUser"> | string
    assignedAt?: DateTimeFilter<"ProjectUser"> | Date | string
  }

  export type ProjectCreateWithoutProjectUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectsOwnedInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectUsersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
  }

  export type UserCreateWithoutProjectAssignmentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutProjectAssignmentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutProjectAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectAssignmentsInput, UserUncheckedCreateWithoutProjectAssignmentsInput>
  }

  export type ProjectUpsertWithoutProjectUsersInput = {
    update: XOR<ProjectUpdateWithoutProjectUsersInput, ProjectUncheckedUpdateWithoutProjectUsersInput>
    create: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectUsersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectUsersInput, ProjectUncheckedUpdateWithoutProjectUsersInput>
  }

  export type ProjectUpdateWithoutProjectUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectsOwnedNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectAssignmentsInput = {
    update: XOR<UserUpdateWithoutProjectAssignmentsInput, UserUncheckedUpdateWithoutProjectAssignmentsInput>
    create: XOR<UserCreateWithoutProjectAssignmentsInput, UserUncheckedCreateWithoutProjectAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectAssignmentsInput, UserUncheckedUpdateWithoutProjectAssignmentsInput>
  }

  export type UserUpdateWithoutProjectAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ProjectCreateWithoutProjectAccountsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectsOwnedInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectAccountsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectAccountsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectAccountsInput, ProjectUncheckedCreateWithoutProjectAccountsInput>
  }

  export type AccountCreateWithoutProjectAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleCreateNestedManyWithoutAccountInput
    subAccount?: SubAccountCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutProjectAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleUncheckedCreateNestedManyWithoutAccountInput
    subAccount?: SubAccountUncheckedCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutProjectAccountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutProjectAccountsInput, AccountUncheckedCreateWithoutProjectAccountsInput>
  }

  export type ProjectUpsertWithoutProjectAccountsInput = {
    update: XOR<ProjectUpdateWithoutProjectAccountsInput, ProjectUncheckedUpdateWithoutProjectAccountsInput>
    create: XOR<ProjectCreateWithoutProjectAccountsInput, ProjectUncheckedCreateWithoutProjectAccountsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectAccountsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectAccountsInput, ProjectUncheckedUpdateWithoutProjectAccountsInput>
  }

  export type ProjectUpdateWithoutProjectAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectsOwnedNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AccountUpsertWithoutProjectAccountsInput = {
    update: XOR<AccountUpdateWithoutProjectAccountsInput, AccountUncheckedUpdateWithoutProjectAccountsInput>
    create: XOR<AccountCreateWithoutProjectAccountsInput, AccountUncheckedCreateWithoutProjectAccountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutProjectAccountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutProjectAccountsInput, AccountUncheckedUpdateWithoutProjectAccountsInput>
  }

  export type AccountUpdateWithoutProjectAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateManyWithoutAccountNestedInput
    subAccount?: SubAccountUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutProjectAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUncheckedUpdateManyWithoutAccountNestedInput
    subAccount?: SubAccountUncheckedUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ProjectCreateWithoutBoardsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectsOwnedInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBoardsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBoardsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
  }

  export type ColumnCreateWithoutBoardInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutColumnInput
  }

  export type ColumnUncheckedCreateWithoutBoardInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnCreateOrConnectWithoutBoardInput = {
    where: ColumnWhereUniqueInput
    create: XOR<ColumnCreateWithoutBoardInput, ColumnUncheckedCreateWithoutBoardInput>
  }

  export type ColumnCreateManyBoardInputEnvelope = {
    data: ColumnCreateManyBoardInput | ColumnCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutBoardsInput = {
    update: XOR<ProjectUpdateWithoutBoardsInput, ProjectUncheckedUpdateWithoutBoardsInput>
    create: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBoardsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBoardsInput, ProjectUncheckedUpdateWithoutBoardsInput>
  }

  export type ProjectUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectsOwnedNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ColumnUpsertWithWhereUniqueWithoutBoardInput = {
    where: ColumnWhereUniqueInput
    update: XOR<ColumnUpdateWithoutBoardInput, ColumnUncheckedUpdateWithoutBoardInput>
    create: XOR<ColumnCreateWithoutBoardInput, ColumnUncheckedCreateWithoutBoardInput>
  }

  export type ColumnUpdateWithWhereUniqueWithoutBoardInput = {
    where: ColumnWhereUniqueInput
    data: XOR<ColumnUpdateWithoutBoardInput, ColumnUncheckedUpdateWithoutBoardInput>
  }

  export type ColumnUpdateManyWithWhereWithoutBoardInput = {
    where: ColumnScalarWhereInput
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyWithoutBoardInput>
  }

  export type ColumnScalarWhereInput = {
    AND?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
    OR?: ColumnScalarWhereInput[]
    NOT?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
    id?: StringFilter<"Column"> | string
    title?: StringFilter<"Column"> | string
    description?: StringNullableFilter<"Column"> | string | null
    order?: IntFilter<"Column"> | number
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
    boardId?: StringFilter<"Column"> | string
  }

  export type BoardCreateWithoutColumnsInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBoardsInput
  }

  export type BoardUncheckedCreateWithoutColumnsInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type BoardCreateOrConnectWithoutColumnsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutColumnsInput, BoardUncheckedCreateWithoutColumnsInput>
  }

  export type TaskCreateWithoutColumnInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutColumnInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    claimId?: string | null
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutColumnInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput>
  }

  export type TaskCreateManyColumnInputEnvelope = {
    data: TaskCreateManyColumnInput | TaskCreateManyColumnInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithoutColumnsInput = {
    update: XOR<BoardUpdateWithoutColumnsInput, BoardUncheckedUpdateWithoutColumnsInput>
    create: XOR<BoardCreateWithoutColumnsInput, BoardUncheckedCreateWithoutColumnsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutColumnsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutColumnsInput, BoardUncheckedUpdateWithoutColumnsInput>
  }

  export type BoardUpdateWithoutColumnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBoardsNestedInput
  }

  export type BoardUncheckedUpdateWithoutColumnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpsertWithWhereUniqueWithoutColumnInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutColumnInput, TaskUncheckedUpdateWithoutColumnInput>
    create: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutColumnInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutColumnInput, TaskUncheckedUpdateWithoutColumnInput>
  }

  export type TaskUpdateManyWithWhereWithoutColumnInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutColumnInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    status?: StringFilter<"Task"> | string
    position?: IntFilter<"Task"> | number
    archive?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    columnId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    claimId?: StringNullableFilter<"Task"> | string | null
  }

  export type ColumnCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutColumnsInput
  }

  export type ColumnUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    boardId: string
  }

  export type ColumnCreateOrConnectWithoutTasksInput = {
    where: ColumnWhereUniqueInput
    create: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksCreatedInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutTasksCreatedInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTasksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
  }

  export type TaskAccountCreateWithoutTaskInput = {
    assignedAt?: Date | string
    account: AccountCreateNestedOneWithoutTaskAccountsInput
  }

  export type TaskAccountUncheckedCreateWithoutTaskInput = {
    accountId: string
    assignedAt?: Date | string
  }

  export type TaskAccountCreateOrConnectWithoutTaskInput = {
    where: TaskAccountWhereUniqueInput
    create: XOR<TaskAccountCreateWithoutTaskInput, TaskAccountUncheckedCreateWithoutTaskInput>
  }

  export type TaskAccountCreateManyTaskInputEnvelope = {
    data: TaskAccountCreateManyTaskInput | TaskAccountCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssigneeCreateWithoutTaskInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutTaskAssignmentsInput
  }

  export type TaskAssigneeUncheckedCreateWithoutTaskInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeCreateOrConnectWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeCreateManyTaskInputEnvelope = {
    data: TaskAssigneeCreateManyTaskInput | TaskAssigneeCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskCommentCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTaskCommentsInput
  }

  export type TaskCommentUncheckedCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type TaskCommentCreateOrConnectWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    create: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput>
  }

  export type TaskCommentCreateManyTaskInputEnvelope = {
    data: TaskCommentCreateManyTaskInput | TaskCommentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskAttachmentCreateWithoutTaskInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    uploadedBy: UserCreateNestedOneWithoutTaskAttachmentsInput
  }

  export type TaskAttachmentUncheckedCreateWithoutTaskInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    uploadedById: string
  }

  export type TaskAttachmentCreateOrConnectWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    create: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAttachmentCreateManyTaskInputEnvelope = {
    data: TaskAttachmentCreateManyTaskInput | TaskAttachmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskLabelCreateWithoutTaskInput = {
    assignedAt?: Date | string
    label: LabelCreateNestedOneWithoutTaskLabelsInput
  }

  export type TaskLabelUncheckedCreateWithoutTaskInput = {
    labelId: string
    assignedAt?: Date | string
  }

  export type TaskLabelCreateOrConnectWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    create: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput>
  }

  export type TaskLabelCreateManyTaskInputEnvelope = {
    data: TaskLabelCreateManyTaskInput | TaskLabelCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutTasksInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutTasksInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutTasksInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutTasksInput, ClaimUncheckedCreateWithoutTasksInput>
  }

  export type ColumnUpsertWithoutTasksInput = {
    update: XOR<ColumnUpdateWithoutTasksInput, ColumnUncheckedUpdateWithoutTasksInput>
    create: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
    where?: ColumnWhereInput
  }

  export type ColumnUpdateToOneWithWhereWithoutTasksInput = {
    where?: ColumnWhereInput
    data: XOR<ColumnUpdateWithoutTasksInput, ColumnUncheckedUpdateWithoutTasksInput>
  }

  export type ColumnUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutColumnsNestedInput
  }

  export type ColumnUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutTasksCreatedInput = {
    update: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TaskAccountUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAccountWhereUniqueInput
    update: XOR<TaskAccountUpdateWithoutTaskInput, TaskAccountUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAccountCreateWithoutTaskInput, TaskAccountUncheckedCreateWithoutTaskInput>
  }

  export type TaskAccountUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAccountWhereUniqueInput
    data: XOR<TaskAccountUpdateWithoutTaskInput, TaskAccountUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAccountUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAccountScalarWhereInput
    data: XOR<TaskAccountUpdateManyMutationInput, TaskAccountUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAccountScalarWhereInput = {
    AND?: TaskAccountScalarWhereInput | TaskAccountScalarWhereInput[]
    OR?: TaskAccountScalarWhereInput[]
    NOT?: TaskAccountScalarWhereInput | TaskAccountScalarWhereInput[]
    taskId?: StringFilter<"TaskAccount"> | string
    accountId?: StringFilter<"TaskAccount"> | string
    assignedAt?: DateTimeFilter<"TaskAccount"> | Date | string
  }

  export type TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    update: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    data: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssigneeScalarWhereInput
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAssigneeScalarWhereInput = {
    AND?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    OR?: TaskAssigneeScalarWhereInput[]
    NOT?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    taskId?: StringFilter<"TaskAssignee"> | string
    userId?: StringFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeFilter<"TaskAssignee"> | Date | string
  }

  export type TaskCommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    update: XOR<TaskCommentUpdateWithoutTaskInput, TaskCommentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput>
  }

  export type TaskCommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    data: XOR<TaskCommentUpdateWithoutTaskInput, TaskCommentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCommentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCommentScalarWhereInput
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCommentScalarWhereInput = {
    AND?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
    OR?: TaskCommentScalarWhereInput[]
    NOT?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
    id?: StringFilter<"TaskComment"> | string
    content?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
    updatedAt?: DateTimeFilter<"TaskComment"> | Date | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
  }

  export type TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    update: XOR<TaskAttachmentUpdateWithoutTaskInput, TaskAttachmentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    data: XOR<TaskAttachmentUpdateWithoutTaskInput, TaskAttachmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAttachmentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAttachmentScalarWhereInput
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAttachmentScalarWhereInput = {
    AND?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
    OR?: TaskAttachmentScalarWhereInput[]
    NOT?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
    id?: StringFilter<"TaskAttachment"> | string
    fileName?: StringFilter<"TaskAttachment"> | string
    originalName?: StringFilter<"TaskAttachment"> | string
    s3Key?: StringFilter<"TaskAttachment"> | string
    s3Bucket?: StringFilter<"TaskAttachment"> | string
    fileSize?: IntFilter<"TaskAttachment"> | number
    mimeType?: StringFilter<"TaskAttachment"> | string
    uploadedAt?: DateTimeFilter<"TaskAttachment"> | Date | string
    isPublic?: BoolFilter<"TaskAttachment"> | boolean
    etag?: StringNullableFilter<"TaskAttachment"> | string | null
    checksum?: StringNullableFilter<"TaskAttachment"> | string | null
    taskId?: StringFilter<"TaskAttachment"> | string
    uploadedById?: StringFilter<"TaskAttachment"> | string
  }

  export type TaskLabelUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    update: XOR<TaskLabelUpdateWithoutTaskInput, TaskLabelUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput>
  }

  export type TaskLabelUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    data: XOR<TaskLabelUpdateWithoutTaskInput, TaskLabelUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLabelUpdateManyWithWhereWithoutTaskInput = {
    where: TaskLabelScalarWhereInput
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskLabelScalarWhereInput = {
    AND?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
    OR?: TaskLabelScalarWhereInput[]
    NOT?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
    taskId?: StringFilter<"TaskLabel"> | string
    labelId?: StringFilter<"TaskLabel"> | string
    assignedAt?: DateTimeFilter<"TaskLabel"> | Date | string
  }

  export type ClaimUpsertWithoutTasksInput = {
    update: XOR<ClaimUpdateWithoutTasksInput, ClaimUncheckedUpdateWithoutTasksInput>
    create: XOR<ClaimCreateWithoutTasksInput, ClaimUncheckedCreateWithoutTasksInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutTasksInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutTasksInput, ClaimUncheckedUpdateWithoutTasksInput>
  }

  export type ClaimUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type TaskCreateWithoutTaskAccountsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTaskAccountsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    claimId?: string | null
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskAccountsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskAccountsInput, TaskUncheckedCreateWithoutTaskAccountsInput>
  }

  export type AccountCreateWithoutTaskAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleCreateNestedManyWithoutAccountInput
    subAccount?: SubAccountCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutTaskAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleUncheckedCreateNestedManyWithoutAccountInput
    subAccount?: SubAccountUncheckedCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutTaskAccountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTaskAccountsInput, AccountUncheckedCreateWithoutTaskAccountsInput>
  }

  export type TaskUpsertWithoutTaskAccountsInput = {
    update: XOR<TaskUpdateWithoutTaskAccountsInput, TaskUncheckedUpdateWithoutTaskAccountsInput>
    create: XOR<TaskCreateWithoutTaskAccountsInput, TaskUncheckedCreateWithoutTaskAccountsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskAccountsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskAccountsInput, TaskUncheckedUpdateWithoutTaskAccountsInput>
  }

  export type TaskUpdateWithoutTaskAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type AccountUpsertWithoutTaskAccountsInput = {
    update: XOR<AccountUpdateWithoutTaskAccountsInput, AccountUncheckedUpdateWithoutTaskAccountsInput>
    create: XOR<AccountCreateWithoutTaskAccountsInput, AccountUncheckedCreateWithoutTaskAccountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTaskAccountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTaskAccountsInput, AccountUncheckedUpdateWithoutTaskAccountsInput>
  }

  export type AccountUpdateWithoutTaskAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateManyWithoutAccountNestedInput
    subAccount?: SubAccountUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTaskAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUncheckedUpdateManyWithoutAccountNestedInput
    subAccount?: SubAccountUncheckedUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type TaskCreateWithoutTaskAssigneesInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTaskAssigneesInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    claimId?: string | null
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskAssigneesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
  }

  export type UserCreateWithoutTaskAssignmentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutTaskAssignmentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTaskAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
  }

  export type TaskUpsertWithoutTaskAssigneesInput = {
    update: XOR<TaskUpdateWithoutTaskAssigneesInput, TaskUncheckedUpdateWithoutTaskAssigneesInput>
    create: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskAssigneesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskAssigneesInput, TaskUncheckedUpdateWithoutTaskAssigneesInput>
  }

  export type TaskUpdateWithoutTaskAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskAssignmentsInput = {
    update: XOR<UserUpdateWithoutTaskAssignmentsInput, UserUncheckedUpdateWithoutTaskAssignmentsInput>
    create: XOR<UserCreateWithoutTaskAssignmentsInput, UserUncheckedCreateWithoutTaskAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskAssignmentsInput, UserUncheckedUpdateWithoutTaskAssignmentsInput>
  }

  export type UserUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TaskCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    claimId?: string | null
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTaskCommentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutTaskCommentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTaskCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskCommentsInput = {
    update: XOR<UserUpdateWithoutTaskCommentsInput, UserUncheckedUpdateWithoutTaskCommentsInput>
    create: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskCommentsInput, UserUncheckedUpdateWithoutTaskCommentsInput>
  }

  export type UserUpdateWithoutTaskCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TaskCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    claimId?: string | null
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAttachmentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutTaskAttachmentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTaskAttachmentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTaskAttachmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskAttachmentsInput, UserUncheckedCreateWithoutTaskAttachmentsInput>
  }

  export type TaskUpsertWithoutAttachmentsInput = {
    update: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskAttachmentsInput = {
    update: XOR<UserUpdateWithoutTaskAttachmentsInput, UserUncheckedUpdateWithoutTaskAttachmentsInput>
    create: XOR<UserCreateWithoutTaskAttachmentsInput, UserUncheckedCreateWithoutTaskAttachmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskAttachmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskAttachmentsInput, UserUncheckedUpdateWithoutTaskAttachmentsInput>
  }

  export type UserUpdateWithoutTaskAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type TaskCreateWithoutLabelsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutLabelsInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    claimId?: string | null
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutLabelsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
  }

  export type LabelCreateWithoutTaskLabelsInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutLabelsCreatedInput
  }

  export type LabelUncheckedCreateWithoutTaskLabelsInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type LabelCreateOrConnectWithoutTaskLabelsInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutTaskLabelsInput, LabelUncheckedCreateWithoutTaskLabelsInput>
  }

  export type TaskUpsertWithoutLabelsInput = {
    update: XOR<TaskUpdateWithoutLabelsInput, TaskUncheckedUpdateWithoutLabelsInput>
    create: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutLabelsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutLabelsInput, TaskUncheckedUpdateWithoutLabelsInput>
  }

  export type TaskUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type LabelUpsertWithoutTaskLabelsInput = {
    update: XOR<LabelUpdateWithoutTaskLabelsInput, LabelUncheckedUpdateWithoutTaskLabelsInput>
    create: XOR<LabelCreateWithoutTaskLabelsInput, LabelUncheckedCreateWithoutTaskLabelsInput>
    where?: LabelWhereInput
  }

  export type LabelUpdateToOneWithWhereWithoutTaskLabelsInput = {
    where?: LabelWhereInput
    data: XOR<LabelUpdateWithoutTaskLabelsInput, LabelUncheckedUpdateWithoutTaskLabelsInput>
  }

  export type LabelUpdateWithoutTaskLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutLabelsCreatedNestedInput
  }

  export type LabelUncheckedUpdateWithoutTaskLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutLabelsCreatedInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutLabelsCreatedInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutLabelsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabelsCreatedInput, UserUncheckedCreateWithoutLabelsCreatedInput>
  }

  export type TaskLabelCreateWithoutLabelInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutLabelsInput
  }

  export type TaskLabelUncheckedCreateWithoutLabelInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskLabelCreateOrConnectWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    create: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput>
  }

  export type TaskLabelCreateManyLabelInputEnvelope = {
    data: TaskLabelCreateManyLabelInput | TaskLabelCreateManyLabelInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLabelsCreatedInput = {
    update: XOR<UserUpdateWithoutLabelsCreatedInput, UserUncheckedUpdateWithoutLabelsCreatedInput>
    create: XOR<UserCreateWithoutLabelsCreatedInput, UserUncheckedCreateWithoutLabelsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabelsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabelsCreatedInput, UserUncheckedUpdateWithoutLabelsCreatedInput>
  }

  export type UserUpdateWithoutLabelsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLabelsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TaskLabelUpsertWithWhereUniqueWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    update: XOR<TaskLabelUpdateWithoutLabelInput, TaskLabelUncheckedUpdateWithoutLabelInput>
    create: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput>
  }

  export type TaskLabelUpdateWithWhereUniqueWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    data: XOR<TaskLabelUpdateWithoutLabelInput, TaskLabelUncheckedUpdateWithoutLabelInput>
  }

  export type TaskLabelUpdateManyWithWhereWithoutLabelInput = {
    where: TaskLabelScalarWhereInput
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyWithoutLabelInput>
  }

  export type SourceCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
  }

  export type SourceUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
  }

  export type SourceCreateOrConnectWithoutUserInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutUserInput, SourceUncheckedCreateWithoutUserInput>
  }

  export type ClaimCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutUserInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput>
  }

  export type ClaimCreateManyUserInputEnvelope = {
    data: ClaimCreateManyUserInput | ClaimCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerifyCreateWithoutUserInput = {
    id?: string
    token: string
    url: string
    status?: string
    sessionId?: string | null
    errorCode?: string | null
    errorMessage?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type VerifyUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    url: string
    status?: string
    sessionId?: string | null
    errorCode?: string | null
    errorMessage?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type VerifyCreateOrConnectWithoutUserInput = {
    where: VerifyWhereUniqueInput
    create: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
  }

  export type ClaimListCreateWithoutUserInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    claim?: ClaimCreateNestedManyWithoutClaimlistInput
    question?: QuestionCreateNestedManyWithoutClaimListInput
  }

  export type ClaimListUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    claim?: ClaimUncheckedCreateNestedManyWithoutClaimlistInput
    question?: QuestionUncheckedCreateNestedManyWithoutClaimListInput
  }

  export type ClaimListCreateOrConnectWithoutUserInput = {
    where: ClaimListWhereUniqueInput
    create: XOR<ClaimListCreateWithoutUserInput, ClaimListUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    boards?: BoardCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectCreateManyOwnerInputEnvelope = {
    data: ProjectCreateManyOwnerInput | ProjectCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    claim?: ClaimCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    claimId?: string | null
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskCreateManyCreatedByInputEnvelope = {
    data: TaskCreateManyCreatedByInput | TaskCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssigneeCreateWithoutUserInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskAssigneesInput
  }

  export type TaskAssigneeUncheckedCreateWithoutUserInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeCreateOrConnectWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
  }

  export type TaskAssigneeCreateManyUserInputEnvelope = {
    data: TaskAssigneeCreateManyUserInput | TaskAssigneeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUserCreateWithoutUserInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectUsersInput
  }

  export type ProjectUserUncheckedCreateWithoutUserInput = {
    projectId: string
    assignedAt?: Date | string
  }

  export type ProjectUserCreateOrConnectWithoutUserInput = {
    where: ProjectUserWhereUniqueInput
    create: XOR<ProjectUserCreateWithoutUserInput, ProjectUserUncheckedCreateWithoutUserInput>
  }

  export type ProjectUserCreateManyUserInputEnvelope = {
    data: ProjectUserCreateManyUserInput | ProjectUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
  }

  export type TaskCommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
  }

  export type TaskCommentCreateOrConnectWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    create: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput>
  }

  export type TaskCommentCreateManyUserInputEnvelope = {
    data: TaskCommentCreateManyUserInput | TaskCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LabelCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    taskLabels?: TaskLabelCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    taskLabels?: TaskLabelUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelCreateOrConnectWithoutCreatedByInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutCreatedByInput, LabelUncheckedCreateWithoutCreatedByInput>
  }

  export type LabelCreateManyCreatedByInputEnvelope = {
    data: LabelCreateManyCreatedByInput | LabelCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TaskAttachmentCreateWithoutUploadedByInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    task: TaskCreateNestedOneWithoutAttachmentsInput
  }

  export type TaskAttachmentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    taskId: string
  }

  export type TaskAttachmentCreateOrConnectWithoutUploadedByInput = {
    where: TaskAttachmentWhereUniqueInput
    create: XOR<TaskAttachmentCreateWithoutUploadedByInput, TaskAttachmentUncheckedCreateWithoutUploadedByInput>
  }

  export type TaskAttachmentCreateManyUploadedByInputEnvelope = {
    data: TaskAttachmentCreateManyUploadedByInput | TaskAttachmentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type SourceUpsertWithoutUserInput = {
    update: XOR<SourceUpdateWithoutUserInput, SourceUncheckedUpdateWithoutUserInput>
    create: XOR<SourceCreateWithoutUserInput, SourceUncheckedCreateWithoutUserInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutUserInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutUserInput, SourceUncheckedUpdateWithoutUserInput>
  }

  export type SourceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ClaimUpsertWithWhereUniqueWithoutUserInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutUserInput, ClaimUncheckedUpdateWithoutUserInput>
    create: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutUserInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutUserInput, ClaimUncheckedUpdateWithoutUserInput>
  }

  export type ClaimUpdateManyWithWhereWithoutUserInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutUserInput>
  }

  export type ClaimScalarWhereInput = {
    AND?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    OR?: ClaimScalarWhereInput[]
    NOT?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    id?: StringFilter<"Claim"> | string
    status?: EnumClaimStatusNullableFilter<"Claim"> | $Enums.ClaimStatus | null
    injured?: BoolNullableFilter<"Claim"> | boolean | null
    relationship?: EnumRelationshipNullableFilter<"Claim"> | $Enums.Relationship | null
    otherRelationship?: StringNullableFilter<"Claim"> | string | null
    healthInsurance?: BoolNullableFilter<"Claim"> | boolean | null
    healthInsuranceNumber?: StringNullableFilter<"Claim"> | string | null
    isOver65?: BoolNullableFilter<"Claim"> | boolean | null
    receiveMedicare?: StringNullableListFilter<"Claim">
    assignedCaseManager?: StringNullableFilter<"Claim"> | string | null
    userId?: StringFilter<"Claim"> | string
    clientRoleId?: StringNullableFilter<"Claim"> | string | null
    injuredPartyRoleId?: StringNullableFilter<"Claim"> | string | null
    incidentId?: StringNullableFilter<"Claim"> | string | null
    healthInsuranceProviderId?: StringNullableFilter<"Claim"> | string | null
    claimlistId?: StringFilter<"Claim"> | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
  }

  export type VerifyUpsertWithoutUserInput = {
    update: XOR<VerifyUpdateWithoutUserInput, VerifyUncheckedUpdateWithoutUserInput>
    create: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
    where?: VerifyWhereInput
  }

  export type VerifyUpdateToOneWithWhereWithoutUserInput = {
    where?: VerifyWhereInput
    data: XOR<VerifyUpdateWithoutUserInput, VerifyUncheckedUpdateWithoutUserInput>
  }

  export type VerifyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerifyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimListUpsertWithoutUserInput = {
    update: XOR<ClaimListUpdateWithoutUserInput, ClaimListUncheckedUpdateWithoutUserInput>
    create: XOR<ClaimListCreateWithoutUserInput, ClaimListUncheckedCreateWithoutUserInput>
    where?: ClaimListWhereInput
  }

  export type ClaimListUpdateToOneWithWhereWithoutUserInput = {
    where?: ClaimListWhereInput
    data: XOR<ClaimListUpdateWithoutUserInput, ClaimListUncheckedUpdateWithoutUserInput>
  }

  export type ClaimListUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    claim?: ClaimUpdateManyWithoutClaimlistNestedInput
    question?: QuestionUpdateManyWithoutClaimListNestedInput
  }

  export type ClaimListUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    claim?: ClaimUncheckedUpdateManyWithoutClaimlistNestedInput
    question?: QuestionUncheckedUpdateManyWithoutClaimListNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatedByInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TaskAssigneeUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    update: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
  }

  export type TaskAssigneeUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    data: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>
  }

  export type TaskAssigneeUpdateManyWithWhereWithoutUserInput = {
    where: TaskAssigneeScalarWhereInput
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectUserWhereUniqueInput
    update: XOR<ProjectUserUpdateWithoutUserInput, ProjectUserUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectUserCreateWithoutUserInput, ProjectUserUncheckedCreateWithoutUserInput>
  }

  export type ProjectUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectUserWhereUniqueInput
    data: XOR<ProjectUserUpdateWithoutUserInput, ProjectUserUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUserUpdateManyWithWhereWithoutUserInput = {
    where: ProjectUserScalarWhereInput
    data: XOR<ProjectUserUpdateManyMutationInput, ProjectUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    update: XOR<TaskCommentUpdateWithoutUserInput, TaskCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput>
  }

  export type TaskCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    data: XOR<TaskCommentUpdateWithoutUserInput, TaskCommentUncheckedUpdateWithoutUserInput>
  }

  export type TaskCommentUpdateManyWithWhereWithoutUserInput = {
    where: TaskCommentScalarWhereInput
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type LabelUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutCreatedByInput, LabelUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LabelCreateWithoutCreatedByInput, LabelUncheckedCreateWithoutCreatedByInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutCreatedByInput, LabelUncheckedUpdateWithoutCreatedByInput>
  }

  export type LabelUpdateManyWithWhereWithoutCreatedByInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LabelScalarWhereInput = {
    AND?: LabelScalarWhereInput | LabelScalarWhereInput[]
    OR?: LabelScalarWhereInput[]
    NOT?: LabelScalarWhereInput | LabelScalarWhereInput[]
    id?: StringFilter<"Label"> | string
    name?: StringFilter<"Label"> | string
    description?: StringNullableFilter<"Label"> | string | null
    colour?: StringFilter<"Label"> | string
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    createdById?: StringFilter<"Label"> | string
  }

  export type TaskAttachmentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: TaskAttachmentWhereUniqueInput
    update: XOR<TaskAttachmentUpdateWithoutUploadedByInput, TaskAttachmentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<TaskAttachmentCreateWithoutUploadedByInput, TaskAttachmentUncheckedCreateWithoutUploadedByInput>
  }

  export type TaskAttachmentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: TaskAttachmentWhereUniqueInput
    data: XOR<TaskAttachmentUpdateWithoutUploadedByInput, TaskAttachmentUncheckedUpdateWithoutUploadedByInput>
  }

  export type TaskAttachmentUpdateManyWithWhereWithoutUploadedByInput = {
    where: TaskAttachmentScalarWhereInput
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type UserCreateWithoutVerifyInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutVerifyInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutVerifyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
  }

  export type UserUpsertWithoutVerifyInput = {
    update: XOR<UserUpdateWithoutVerifyInput, UserUncheckedUpdateWithoutVerifyInput>
    create: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifyInput, UserUncheckedUpdateWithoutVerifyInput>
  }

  export type UserUpdateWithoutVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutClaimsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutClaimsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutClaimsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
  }

  export type RoleCreateWithoutClientClaimsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutClientClaimsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutClientClaimsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutClientClaimsInput, RoleUncheckedCreateWithoutClientClaimsInput>
  }

  export type RoleCreateWithoutInjuredPartyClaimsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutInjuredPartyClaimsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutInjuredPartyClaimsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutInjuredPartyClaimsInput, RoleUncheckedCreateWithoutInjuredPartyClaimsInput>
  }

  export type IncidentCreateWithoutClaimInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policeStation?: RoleCreateNestedOneWithoutPoliceStationIncidentsInput
    policeOfficer?: SubAccountCreateNestedOneWithoutPoliceIncidentsInput
    lawfirm?: RoleCreateNestedOneWithoutLawfirmIncidentsInput
    attorney?: SubAccountCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutClaimInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateOrConnectWithoutClaimInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutClaimInput, IncidentUncheckedCreateWithoutClaimInput>
  }

  export type RoleCreateWithoutHealthInsuranceClaimsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutHealthInsuranceClaimsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutHealthInsuranceClaimsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutHealthInsuranceClaimsInput, RoleUncheckedCreateWithoutHealthInsuranceClaimsInput>
  }

  export type WitnessCreateWithoutClaimInput = {
    id?: string
    witnessDetails?: WitnessDetailsCreateNestedManyWithoutWitnessInput
  }

  export type WitnessUncheckedCreateWithoutClaimInput = {
    id?: string
    witnessDetails?: WitnessDetailsUncheckedCreateNestedManyWithoutWitnessInput
  }

  export type WitnessCreateOrConnectWithoutClaimInput = {
    where: WitnessWhereUniqueInput
    create: XOR<WitnessCreateWithoutClaimInput, WitnessUncheckedCreateWithoutClaimInput>
  }

  export type DefendantCreateWithoutClaimInput = {
    id?: string
    defendantDetails?: DefendantDetailsCreateNestedManyWithoutDefendantInput
  }

  export type DefendantUncheckedCreateWithoutClaimInput = {
    id?: string
    defendantDetails?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInput
  }

  export type DefendantCreateOrConnectWithoutClaimInput = {
    where: DefendantWhereUniqueInput
    create: XOR<DefendantCreateWithoutClaimInput, DefendantUncheckedCreateWithoutClaimInput>
  }

  export type TreatmentAndInjuryCreateWithoutClaimInput = {
    id?: string
    treatment: TreatmentCreateNestedOneWithoutTreatmentsAndInjuriesInput
  }

  export type TreatmentAndInjuryUncheckedCreateWithoutClaimInput = {
    id?: string
    treatmentId: string
  }

  export type TreatmentAndInjuryCreateOrConnectWithoutClaimInput = {
    where: TreatmentAndInjuryWhereUniqueInput
    create: XOR<TreatmentAndInjuryCreateWithoutClaimInput, TreatmentAndInjuryUncheckedCreateWithoutClaimInput>
  }

  export type QuestionnaireCreateWithoutClaimInput = {
    id?: string
    question?: QuestionAnswerCreateNestedManyWithoutQuestionnaireInput
  }

  export type QuestionnaireUncheckedCreateWithoutClaimInput = {
    id?: string
    question?: QuestionAnswerUncheckedCreateNestedManyWithoutQuestionnaireInput
  }

  export type QuestionnaireCreateOrConnectWithoutClaimInput = {
    where: QuestionnaireWhereUniqueInput
    create: XOR<QuestionnaireCreateWithoutClaimInput, QuestionnaireUncheckedCreateWithoutClaimInput>
  }

  export type ClaimListCreateWithoutClaimInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    user?: UserCreateNestedManyWithoutClaimlistInput
    question?: QuestionCreateNestedManyWithoutClaimListInput
  }

  export type ClaimListUncheckedCreateWithoutClaimInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    user?: UserUncheckedCreateNestedManyWithoutClaimlistInput
    question?: QuestionUncheckedCreateNestedManyWithoutClaimListInput
  }

  export type ClaimListCreateOrConnectWithoutClaimInput = {
    where: ClaimListWhereUniqueInput
    create: XOR<ClaimListCreateWithoutClaimInput, ClaimListUncheckedCreateWithoutClaimInput>
  }

  export type EnvelopCreateWithoutClaimInput = {
    id?: string
    status?: boolean
    submitterUrl?: string | null
    submitterId?: number | null
    submittedUrl?: string | null
    createdAt?: Date | string
  }

  export type EnvelopUncheckedCreateWithoutClaimInput = {
    id?: string
    status?: boolean
    submitterUrl?: string | null
    submitterId?: number | null
    submittedUrl?: string | null
    createdAt?: Date | string
  }

  export type EnvelopCreateOrConnectWithoutClaimInput = {
    where: EnvelopWhereUniqueInput
    create: XOR<EnvelopCreateWithoutClaimInput, EnvelopUncheckedCreateWithoutClaimInput>
  }

  export type EnvelopCreateManyClaimInputEnvelope = {
    data: EnvelopCreateManyClaimInput | EnvelopCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type AccidentMediaCreateWithoutClaimInput = {
    id?: string
    url: string
    type: string
    thumbnail?: string | null
  }

  export type AccidentMediaUncheckedCreateWithoutClaimInput = {
    id?: string
    url: string
    type: string
    thumbnail?: string | null
  }

  export type AccidentMediaCreateOrConnectWithoutClaimInput = {
    where: AccidentMediaWhereUniqueInput
    create: XOR<AccidentMediaCreateWithoutClaimInput, AccidentMediaUncheckedCreateWithoutClaimInput>
  }

  export type AccidentMediaCreateManyClaimInputEnvelope = {
    data: AccidentMediaCreateManyClaimInput | AccidentMediaCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutClaimInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutClaimInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutClaimInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutClaimInput, TaskUncheckedCreateWithoutClaimInput>
  }

  export type TaskCreateManyClaimInputEnvelope = {
    data: TaskCreateManyClaimInput | TaskCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type ProjectClaimCreateWithoutClaimInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectClaimsInput
  }

  export type ProjectClaimUncheckedCreateWithoutClaimInput = {
    projectId: string
    assignedAt?: Date | string
  }

  export type ProjectClaimCreateOrConnectWithoutClaimInput = {
    where: ProjectClaimWhereUniqueInput
    create: XOR<ProjectClaimCreateWithoutClaimInput, ProjectClaimUncheckedCreateWithoutClaimInput>
  }

  export type ProjectClaimCreateManyClaimInputEnvelope = {
    data: ProjectClaimCreateManyClaimInput | ProjectClaimCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClaimsInput = {
    update: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type UserUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type RoleUpsertWithoutClientClaimsInput = {
    update: XOR<RoleUpdateWithoutClientClaimsInput, RoleUncheckedUpdateWithoutClientClaimsInput>
    create: XOR<RoleCreateWithoutClientClaimsInput, RoleUncheckedCreateWithoutClientClaimsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutClientClaimsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutClientClaimsInput, RoleUncheckedUpdateWithoutClientClaimsInput>
  }

  export type RoleUpdateWithoutClientClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutClientClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUpsertWithoutInjuredPartyClaimsInput = {
    update: XOR<RoleUpdateWithoutInjuredPartyClaimsInput, RoleUncheckedUpdateWithoutInjuredPartyClaimsInput>
    create: XOR<RoleCreateWithoutInjuredPartyClaimsInput, RoleUncheckedCreateWithoutInjuredPartyClaimsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutInjuredPartyClaimsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutInjuredPartyClaimsInput, RoleUncheckedUpdateWithoutInjuredPartyClaimsInput>
  }

  export type RoleUpdateWithoutInjuredPartyClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutInjuredPartyClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type IncidentUpsertWithoutClaimInput = {
    update: XOR<IncidentUpdateWithoutClaimInput, IncidentUncheckedUpdateWithoutClaimInput>
    create: XOR<IncidentCreateWithoutClaimInput, IncidentUncheckedCreateWithoutClaimInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutClaimInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutClaimInput, IncidentUncheckedUpdateWithoutClaimInput>
  }

  export type IncidentUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policeStation?: RoleUpdateOneWithoutPoliceStationIncidentsNestedInput
    policeOfficer?: SubAccountUpdateOneWithoutPoliceIncidentsNestedInput
    lawfirm?: RoleUpdateOneWithoutLawfirmIncidentsNestedInput
    attorney?: SubAccountUpdateOneWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpsertWithoutHealthInsuranceClaimsInput = {
    update: XOR<RoleUpdateWithoutHealthInsuranceClaimsInput, RoleUncheckedUpdateWithoutHealthInsuranceClaimsInput>
    create: XOR<RoleCreateWithoutHealthInsuranceClaimsInput, RoleUncheckedCreateWithoutHealthInsuranceClaimsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutHealthInsuranceClaimsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutHealthInsuranceClaimsInput, RoleUncheckedUpdateWithoutHealthInsuranceClaimsInput>
  }

  export type RoleUpdateWithoutHealthInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutHealthInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type WitnessUpsertWithoutClaimInput = {
    update: XOR<WitnessUpdateWithoutClaimInput, WitnessUncheckedUpdateWithoutClaimInput>
    create: XOR<WitnessCreateWithoutClaimInput, WitnessUncheckedCreateWithoutClaimInput>
    where?: WitnessWhereInput
  }

  export type WitnessUpdateToOneWithWhereWithoutClaimInput = {
    where?: WitnessWhereInput
    data: XOR<WitnessUpdateWithoutClaimInput, WitnessUncheckedUpdateWithoutClaimInput>
  }

  export type WitnessUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    witnessDetails?: WitnessDetailsUpdateManyWithoutWitnessNestedInput
  }

  export type WitnessUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    witnessDetails?: WitnessDetailsUncheckedUpdateManyWithoutWitnessNestedInput
  }

  export type DefendantUpsertWithoutClaimInput = {
    update: XOR<DefendantUpdateWithoutClaimInput, DefendantUncheckedUpdateWithoutClaimInput>
    create: XOR<DefendantCreateWithoutClaimInput, DefendantUncheckedCreateWithoutClaimInput>
    where?: DefendantWhereInput
  }

  export type DefendantUpdateToOneWithWhereWithoutClaimInput = {
    where?: DefendantWhereInput
    data: XOR<DefendantUpdateWithoutClaimInput, DefendantUncheckedUpdateWithoutClaimInput>
  }

  export type DefendantUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantDetails?: DefendantDetailsUpdateManyWithoutDefendantNestedInput
  }

  export type DefendantUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantDetails?: DefendantDetailsUncheckedUpdateManyWithoutDefendantNestedInput
  }

  export type TreatmentAndInjuryUpsertWithoutClaimInput = {
    update: XOR<TreatmentAndInjuryUpdateWithoutClaimInput, TreatmentAndInjuryUncheckedUpdateWithoutClaimInput>
    create: XOR<TreatmentAndInjuryCreateWithoutClaimInput, TreatmentAndInjuryUncheckedCreateWithoutClaimInput>
    where?: TreatmentAndInjuryWhereInput
  }

  export type TreatmentAndInjuryUpdateToOneWithWhereWithoutClaimInput = {
    where?: TreatmentAndInjuryWhereInput
    data: XOR<TreatmentAndInjuryUpdateWithoutClaimInput, TreatmentAndInjuryUncheckedUpdateWithoutClaimInput>
  }

  export type TreatmentAndInjuryUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatment?: TreatmentUpdateOneRequiredWithoutTreatmentsAndInjuriesNestedInput
  }

  export type TreatmentAndInjuryUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionnaireUpsertWithoutClaimInput = {
    update: XOR<QuestionnaireUpdateWithoutClaimInput, QuestionnaireUncheckedUpdateWithoutClaimInput>
    create: XOR<QuestionnaireCreateWithoutClaimInput, QuestionnaireUncheckedCreateWithoutClaimInput>
    where?: QuestionnaireWhereInput
  }

  export type QuestionnaireUpdateToOneWithWhereWithoutClaimInput = {
    where?: QuestionnaireWhereInput
    data: XOR<QuestionnaireUpdateWithoutClaimInput, QuestionnaireUncheckedUpdateWithoutClaimInput>
  }

  export type QuestionnaireUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: QuestionAnswerUpdateManyWithoutQuestionnaireNestedInput
  }

  export type QuestionnaireUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: QuestionAnswerUncheckedUpdateManyWithoutQuestionnaireNestedInput
  }

  export type ClaimListUpsertWithoutClaimInput = {
    update: XOR<ClaimListUpdateWithoutClaimInput, ClaimListUncheckedUpdateWithoutClaimInput>
    create: XOR<ClaimListCreateWithoutClaimInput, ClaimListUncheckedCreateWithoutClaimInput>
    where?: ClaimListWhereInput
  }

  export type ClaimListUpdateToOneWithWhereWithoutClaimInput = {
    where?: ClaimListWhereInput
    data: XOR<ClaimListUpdateWithoutClaimInput, ClaimListUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimListUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateManyWithoutClaimlistNestedInput
    question?: QuestionUpdateManyWithoutClaimListNestedInput
  }

  export type ClaimListUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateManyWithoutClaimlistNestedInput
    question?: QuestionUncheckedUpdateManyWithoutClaimListNestedInput
  }

  export type EnvelopUpsertWithWhereUniqueWithoutClaimInput = {
    where: EnvelopWhereUniqueInput
    update: XOR<EnvelopUpdateWithoutClaimInput, EnvelopUncheckedUpdateWithoutClaimInput>
    create: XOR<EnvelopCreateWithoutClaimInput, EnvelopUncheckedCreateWithoutClaimInput>
  }

  export type EnvelopUpdateWithWhereUniqueWithoutClaimInput = {
    where: EnvelopWhereUniqueInput
    data: XOR<EnvelopUpdateWithoutClaimInput, EnvelopUncheckedUpdateWithoutClaimInput>
  }

  export type EnvelopUpdateManyWithWhereWithoutClaimInput = {
    where: EnvelopScalarWhereInput
    data: XOR<EnvelopUpdateManyMutationInput, EnvelopUncheckedUpdateManyWithoutClaimInput>
  }

  export type EnvelopScalarWhereInput = {
    AND?: EnvelopScalarWhereInput | EnvelopScalarWhereInput[]
    OR?: EnvelopScalarWhereInput[]
    NOT?: EnvelopScalarWhereInput | EnvelopScalarWhereInput[]
    id?: StringFilter<"Envelop"> | string
    status?: BoolFilter<"Envelop"> | boolean
    claimId?: StringFilter<"Envelop"> | string
    submitterUrl?: StringNullableFilter<"Envelop"> | string | null
    submitterId?: IntNullableFilter<"Envelop"> | number | null
    submittedUrl?: StringNullableFilter<"Envelop"> | string | null
    createdAt?: DateTimeFilter<"Envelop"> | Date | string
  }

  export type AccidentMediaUpsertWithWhereUniqueWithoutClaimInput = {
    where: AccidentMediaWhereUniqueInput
    update: XOR<AccidentMediaUpdateWithoutClaimInput, AccidentMediaUncheckedUpdateWithoutClaimInput>
    create: XOR<AccidentMediaCreateWithoutClaimInput, AccidentMediaUncheckedCreateWithoutClaimInput>
  }

  export type AccidentMediaUpdateWithWhereUniqueWithoutClaimInput = {
    where: AccidentMediaWhereUniqueInput
    data: XOR<AccidentMediaUpdateWithoutClaimInput, AccidentMediaUncheckedUpdateWithoutClaimInput>
  }

  export type AccidentMediaUpdateManyWithWhereWithoutClaimInput = {
    where: AccidentMediaScalarWhereInput
    data: XOR<AccidentMediaUpdateManyMutationInput, AccidentMediaUncheckedUpdateManyWithoutClaimInput>
  }

  export type AccidentMediaScalarWhereInput = {
    AND?: AccidentMediaScalarWhereInput | AccidentMediaScalarWhereInput[]
    OR?: AccidentMediaScalarWhereInput[]
    NOT?: AccidentMediaScalarWhereInput | AccidentMediaScalarWhereInput[]
    id?: StringFilter<"AccidentMedia"> | string
    url?: StringFilter<"AccidentMedia"> | string
    type?: StringFilter<"AccidentMedia"> | string
    thumbnail?: StringNullableFilter<"AccidentMedia"> | string | null
    claimId?: StringFilter<"AccidentMedia"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutClaimInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutClaimInput, TaskUncheckedUpdateWithoutClaimInput>
    create: XOR<TaskCreateWithoutClaimInput, TaskUncheckedCreateWithoutClaimInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutClaimInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutClaimInput, TaskUncheckedUpdateWithoutClaimInput>
  }

  export type TaskUpdateManyWithWhereWithoutClaimInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutClaimInput>
  }

  export type ProjectClaimUpsertWithWhereUniqueWithoutClaimInput = {
    where: ProjectClaimWhereUniqueInput
    update: XOR<ProjectClaimUpdateWithoutClaimInput, ProjectClaimUncheckedUpdateWithoutClaimInput>
    create: XOR<ProjectClaimCreateWithoutClaimInput, ProjectClaimUncheckedCreateWithoutClaimInput>
  }

  export type ProjectClaimUpdateWithWhereUniqueWithoutClaimInput = {
    where: ProjectClaimWhereUniqueInput
    data: XOR<ProjectClaimUpdateWithoutClaimInput, ProjectClaimUncheckedUpdateWithoutClaimInput>
  }

  export type ProjectClaimUpdateManyWithWhereWithoutClaimInput = {
    where: ProjectClaimScalarWhereInput
    data: XOR<ProjectClaimUpdateManyMutationInput, ProjectClaimUncheckedUpdateManyWithoutClaimInput>
  }

  export type ProjectCreateWithoutProjectClaimsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectsOwnedInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectClaimsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectClaimsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectClaimsInput, ProjectUncheckedCreateWithoutProjectClaimsInput>
  }

  export type ClaimCreateWithoutProjectClaimsInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutProjectClaimsInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutProjectClaimsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutProjectClaimsInput, ClaimUncheckedCreateWithoutProjectClaimsInput>
  }

  export type ProjectUpsertWithoutProjectClaimsInput = {
    update: XOR<ProjectUpdateWithoutProjectClaimsInput, ProjectUncheckedUpdateWithoutProjectClaimsInput>
    create: XOR<ProjectCreateWithoutProjectClaimsInput, ProjectUncheckedCreateWithoutProjectClaimsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectClaimsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectClaimsInput, ProjectUncheckedUpdateWithoutProjectClaimsInput>
  }

  export type ProjectUpdateWithoutProjectClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectsOwnedNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ClaimUpsertWithoutProjectClaimsInput = {
    update: XOR<ClaimUpdateWithoutProjectClaimsInput, ClaimUncheckedUpdateWithoutProjectClaimsInput>
    create: XOR<ClaimCreateWithoutProjectClaimsInput, ClaimUncheckedCreateWithoutProjectClaimsInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutProjectClaimsInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutProjectClaimsInput, ClaimUncheckedUpdateWithoutProjectClaimsInput>
  }

  export type ClaimUpdateWithoutProjectClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutProjectClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateWithoutEnvelopInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutEnvelopInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutEnvelopInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutEnvelopInput, ClaimUncheckedCreateWithoutEnvelopInput>
  }

  export type ClaimUpsertWithoutEnvelopInput = {
    update: XOR<ClaimUpdateWithoutEnvelopInput, ClaimUncheckedUpdateWithoutEnvelopInput>
    create: XOR<ClaimCreateWithoutEnvelopInput, ClaimUncheckedCreateWithoutEnvelopInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutEnvelopInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutEnvelopInput, ClaimUncheckedUpdateWithoutEnvelopInput>
  }

  export type ClaimUpdateWithoutEnvelopInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutEnvelopInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateWithoutClaimlistInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutClaimlistInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutClaimlistInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClaimlistInput, ClaimUncheckedCreateWithoutClaimlistInput>
  }

  export type ClaimCreateManyClaimlistInputEnvelope = {
    data: ClaimCreateManyClaimlistInput | ClaimCreateManyClaimlistInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClaimlistInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    source?: SourceCreateNestedOneWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutClaimlistInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutClaimlistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimlistInput, UserUncheckedCreateWithoutClaimlistInput>
  }

  export type UserCreateManyClaimlistInputEnvelope = {
    data: UserCreateManyClaimlistInput | UserCreateManyClaimlistInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutClaimListInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    enable?: boolean
    choices?: ChoiceCreateNestedManyWithoutQuestionInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutClaimListInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    enable?: boolean
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuestionInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutClaimListInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutClaimListInput, QuestionUncheckedCreateWithoutClaimListInput>
  }

  export type QuestionCreateManyClaimListInputEnvelope = {
    data: QuestionCreateManyClaimListInput | QuestionCreateManyClaimListInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithWhereUniqueWithoutClaimlistInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutClaimlistInput, ClaimUncheckedUpdateWithoutClaimlistInput>
    create: XOR<ClaimCreateWithoutClaimlistInput, ClaimUncheckedCreateWithoutClaimlistInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutClaimlistInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutClaimlistInput, ClaimUncheckedUpdateWithoutClaimlistInput>
  }

  export type ClaimUpdateManyWithWhereWithoutClaimlistInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutClaimlistInput>
  }

  export type UserUpsertWithWhereUniqueWithoutClaimlistInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClaimlistInput, UserUncheckedUpdateWithoutClaimlistInput>
    create: XOR<UserCreateWithoutClaimlistInput, UserUncheckedCreateWithoutClaimlistInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClaimlistInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClaimlistInput, UserUncheckedUpdateWithoutClaimlistInput>
  }

  export type UserUpdateManyWithWhereWithoutClaimlistInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClaimlistInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    injured?: EnumWereYouInjuredFilter<"User"> | $Enums.WereYouInjured
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone2?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    isUnder18?: BoolFilter<"User"> | boolean
    fatherFirstName?: StringNullableFilter<"User"> | string | null
    fatherLastName?: StringNullableFilter<"User"> | string | null
    motherFirstName?: StringNullableFilter<"User"> | string | null
    motherLastName?: StringNullableFilter<"User"> | string | null
    mailingAddress1?: StringNullableFilter<"User"> | string | null
    mailingAddress2?: StringNullableFilter<"User"> | string | null
    mailingCity?: StringNullableFilter<"User"> | string | null
    mailingState?: StringNullableFilter<"User"> | string | null
    mailingZipCode?: StringNullableFilter<"User"> | string | null
    isPOBoxOrDifferentAddress?: BoolNullableFilter<"User"> | boolean | null
    physicalAddress1?: StringNullableFilter<"User"> | string | null
    physicalAddress2?: StringNullableFilter<"User"> | string | null
    physicalCity?: StringNullableFilter<"User"> | string | null
    physicalState?: StringNullableFilter<"User"> | string | null
    physicalZipCode?: StringNullableFilter<"User"> | string | null
    maritalStatus?: StringNullableFilter<"User"> | string | null
    spouseFirstName?: StringNullableFilter<"User"> | string | null
    spouseLastName?: StringNullableFilter<"User"> | string | null
    spousePhone?: StringNullableFilter<"User"> | string | null
    employmentStatus?: StringNullableFilter<"User"> | string | null
    employerName?: StringNullableFilter<"User"> | string | null
    employerTitle?: StringNullableFilter<"User"> | string | null
    employmentType?: StringNullableFilter<"User"> | string | null
    pay?: StringNullableFilter<"User"> | string | null
    schoolName?: StringNullableFilter<"User"> | string | null
    expectedGraduationYear?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    sourceId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    claimlistId?: StringFilter<"User"> | string
    accountSync?: StringNullableFilter<"User"> | string | null
  }

  export type QuestionUpsertWithWhereUniqueWithoutClaimListInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutClaimListInput, QuestionUncheckedUpdateWithoutClaimListInput>
    create: XOR<QuestionCreateWithoutClaimListInput, QuestionUncheckedCreateWithoutClaimListInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutClaimListInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutClaimListInput, QuestionUncheckedUpdateWithoutClaimListInput>
  }

  export type QuestionUpdateManyWithWhereWithoutClaimListInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutClaimListInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    question?: StringFilter<"Question"> | string
    claimListId?: StringNullableFilter<"Question"> | string | null
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    enable?: BoolFilter<"Question"> | boolean
  }

  export type UserCreateWithoutSourceInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
    claims?: ClaimCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedOneWithoutUserInput
    claimlist: ClaimListCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    labelsCreated?: LabelCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutSourceInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedOneWithoutUserInput
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    taskAssignments?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectAssignments?: ProjectUserUncheckedCreateNestedManyWithoutUserInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    labelsCreated?: LabelUncheckedCreateNestedManyWithoutCreatedByInput
    taskAttachments?: TaskAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutSourceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSourceInput, UserUncheckedCreateWithoutSourceInput>
  }

  export type UserCreateManySourceInputEnvelope = {
    data: UserCreateManySourceInput | UserCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSourceInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSourceInput, UserUncheckedUpdateWithoutSourceInput>
    create: XOR<UserCreateWithoutSourceInput, UserUncheckedCreateWithoutSourceInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSourceInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSourceInput, UserUncheckedUpdateWithoutSourceInput>
  }

  export type UserUpdateManyWithWhereWithoutSourceInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSourceInput>
  }

  export type ClaimCreateWithoutQuestionnaireInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutQuestionnaireInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutQuestionnaireInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutQuestionnaireInput, ClaimUncheckedCreateWithoutQuestionnaireInput>
  }

  export type QuestionAnswerCreateWithoutQuestionnaireInput = {
    id?: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutQuestionnaireInput = {
    id?: string
    questionId: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutQuestionnaireInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutQuestionnaireInput, QuestionAnswerUncheckedCreateWithoutQuestionnaireInput>
  }

  export type QuestionAnswerCreateManyQuestionnaireInputEnvelope = {
    data: QuestionAnswerCreateManyQuestionnaireInput | QuestionAnswerCreateManyQuestionnaireInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithoutQuestionnaireInput = {
    update: XOR<ClaimUpdateWithoutQuestionnaireInput, ClaimUncheckedUpdateWithoutQuestionnaireInput>
    create: XOR<ClaimCreateWithoutQuestionnaireInput, ClaimUncheckedCreateWithoutQuestionnaireInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutQuestionnaireInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutQuestionnaireInput, ClaimUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type ClaimUpdateWithoutQuestionnaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutQuestionnaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutQuestionnaireInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutQuestionnaireInput, QuestionAnswerUncheckedUpdateWithoutQuestionnaireInput>
    create: XOR<QuestionAnswerCreateWithoutQuestionnaireInput, QuestionAnswerUncheckedCreateWithoutQuestionnaireInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutQuestionnaireInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutQuestionnaireInput, QuestionAnswerUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutQuestionnaireInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutQuestionnaireInput>
  }

  export type QuestionAnswerScalarWhereInput = {
    AND?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
    OR?: QuestionAnswerScalarWhereInput[]
    NOT?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
    id?: StringFilter<"QuestionAnswer"> | string
    questionnaireId?: StringNullableFilter<"QuestionAnswer"> | string | null
    questionId?: StringFilter<"QuestionAnswer"> | string
    answer?: StringFilter<"QuestionAnswer"> | string
    createdAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
  }

  export type QuestionnaireCreateWithoutQuestionInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutQuestionnaireInput
  }

  export type QuestionnaireUncheckedCreateWithoutQuestionInput = {
    id?: string
    claimId: string
  }

  export type QuestionnaireCreateOrConnectWithoutQuestionInput = {
    where: QuestionnaireWhereUniqueInput
    create: XOR<QuestionnaireCreateWithoutQuestionInput, QuestionnaireUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionCreateWithoutQuestionAnswerInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    enable?: boolean
    claimList?: ClaimListCreateNestedOneWithoutQuestionInput
    choices?: ChoiceCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutQuestionAnswerInput = {
    id?: string
    question: string
    claimListId?: string | null
    type: $Enums.QuestionType
    enable?: boolean
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutQuestionAnswerInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutQuestionAnswerInput, QuestionUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type QuestionnaireUpsertWithoutQuestionInput = {
    update: XOR<QuestionnaireUpdateWithoutQuestionInput, QuestionnaireUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionnaireCreateWithoutQuestionInput, QuestionnaireUncheckedCreateWithoutQuestionInput>
    where?: QuestionnaireWhereInput
  }

  export type QuestionnaireUpdateToOneWithWhereWithoutQuestionInput = {
    where?: QuestionnaireWhereInput
    data: XOR<QuestionnaireUpdateWithoutQuestionInput, QuestionnaireUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionnaireUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutQuestionnaireNestedInput
  }

  export type QuestionnaireUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionUpsertWithoutQuestionAnswerInput = {
    update: XOR<QuestionUpdateWithoutQuestionAnswerInput, QuestionUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<QuestionCreateWithoutQuestionAnswerInput, QuestionUncheckedCreateWithoutQuestionAnswerInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutQuestionAnswerInput, QuestionUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type QuestionUpdateWithoutQuestionAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    claimList?: ClaimListUpdateOneWithoutQuestionNestedInput
    choices?: ChoiceUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    claimListId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ClaimListCreateWithoutQuestionInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    claim?: ClaimCreateNestedManyWithoutClaimlistInput
    user?: UserCreateNestedManyWithoutClaimlistInput
  }

  export type ClaimListUncheckedCreateWithoutQuestionInput = {
    id?: string
    name: string
    enable?: boolean | null
    questionId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    claim?: ClaimUncheckedCreateNestedManyWithoutClaimlistInput
    user?: UserUncheckedCreateNestedManyWithoutClaimlistInput
  }

  export type ClaimListCreateOrConnectWithoutQuestionInput = {
    where: ClaimListWhereUniqueInput
    create: XOR<ClaimListCreateWithoutQuestionInput, ClaimListUncheckedCreateWithoutQuestionInput>
  }

  export type ChoiceCreateWithoutQuestionInput = {
    id?: string
    text: string
  }

  export type ChoiceUncheckedCreateWithoutQuestionInput = {
    id?: string
    text: string
  }

  export type ChoiceCreateOrConnectWithoutQuestionInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type ChoiceCreateManyQuestionInputEnvelope = {
    data: ChoiceCreateManyQuestionInput | ChoiceCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionAnswerCreateWithoutQuestionInput = {
    id?: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Questionnaire?: QuestionnaireCreateNestedOneWithoutQuestionInput
  }

  export type QuestionAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    questionnaireId?: string | null
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionAnswerCreateManyQuestionInputEnvelope = {
    data: QuestionAnswerCreateManyQuestionInput | QuestionAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ClaimListUpsertWithoutQuestionInput = {
    update: XOR<ClaimListUpdateWithoutQuestionInput, ClaimListUncheckedUpdateWithoutQuestionInput>
    create: XOR<ClaimListCreateWithoutQuestionInput, ClaimListUncheckedCreateWithoutQuestionInput>
    where?: ClaimListWhereInput
  }

  export type ClaimListUpdateToOneWithWhereWithoutQuestionInput = {
    where?: ClaimListWhereInput
    data: XOR<ClaimListUpdateWithoutQuestionInput, ClaimListUncheckedUpdateWithoutQuestionInput>
  }

  export type ClaimListUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    claim?: ClaimUpdateManyWithoutClaimlistNestedInput
    user?: UserUpdateManyWithoutClaimlistNestedInput
  }

  export type ClaimListUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    claim?: ClaimUncheckedUpdateManyWithoutClaimlistNestedInput
    user?: UserUncheckedUpdateManyWithoutClaimlistNestedInput
  }

  export type ChoiceUpsertWithWhereUniqueWithoutQuestionInput = {
    where: ChoiceWhereUniqueInput
    update: XOR<ChoiceUpdateWithoutQuestionInput, ChoiceUncheckedUpdateWithoutQuestionInput>
    create: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type ChoiceUpdateWithWhereUniqueWithoutQuestionInput = {
    where: ChoiceWhereUniqueInput
    data: XOR<ChoiceUpdateWithoutQuestionInput, ChoiceUncheckedUpdateWithoutQuestionInput>
  }

  export type ChoiceUpdateManyWithWhereWithoutQuestionInput = {
    where: ChoiceScalarWhereInput
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyWithoutQuestionInput>
  }

  export type ChoiceScalarWhereInput = {
    AND?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
    OR?: ChoiceScalarWhereInput[]
    NOT?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
    id?: StringFilter<"Choice"> | string
    text?: StringFilter<"Choice"> | string
    questionId?: StringFilter<"Choice"> | string
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutQuestionInput, QuestionAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionAnswerCreateWithoutQuestionInput, QuestionAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutQuestionInput, QuestionAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionCreateWithoutChoicesInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    enable?: boolean
    claimList?: ClaimListCreateNestedOneWithoutQuestionInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutChoicesInput = {
    id?: string
    question: string
    claimListId?: string | null
    type: $Enums.QuestionType
    enable?: boolean
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutChoicesInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
  }

  export type QuestionUpsertWithoutChoicesInput = {
    update: XOR<QuestionUpdateWithoutChoicesInput, QuestionUncheckedUpdateWithoutChoicesInput>
    create: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutChoicesInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutChoicesInput, QuestionUncheckedUpdateWithoutChoicesInput>
  }

  export type QuestionUpdateWithoutChoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    claimList?: ClaimListUpdateOneWithoutQuestionNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutChoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    claimListId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ClaimCreateWithoutDefendantInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutDefendantInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutDefendantInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutDefendantInput, ClaimUncheckedCreateWithoutDefendantInput>
  }

  export type DefendantDetailsCreateWithoutDefendantInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantAccount: RoleCreateNestedOneWithoutDefendantAccountInput
    defendantInsuranceCarrier?: RoleCreateNestedOneWithoutDefendantInsuranceCarrierInput
  }

  export type DefendantDetailsUncheckedCreateWithoutDefendantInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantAccountId: string
    defendantInsuranceCarrierId?: string | null
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
  }

  export type DefendantDetailsCreateOrConnectWithoutDefendantInput = {
    where: DefendantDetailsWhereUniqueInput
    create: XOR<DefendantDetailsCreateWithoutDefendantInput, DefendantDetailsUncheckedCreateWithoutDefendantInput>
  }

  export type DefendantDetailsCreateManyDefendantInputEnvelope = {
    data: DefendantDetailsCreateManyDefendantInput | DefendantDetailsCreateManyDefendantInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithoutDefendantInput = {
    update: XOR<ClaimUpdateWithoutDefendantInput, ClaimUncheckedUpdateWithoutDefendantInput>
    create: XOR<ClaimCreateWithoutDefendantInput, ClaimUncheckedCreateWithoutDefendantInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutDefendantInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutDefendantInput, ClaimUncheckedUpdateWithoutDefendantInput>
  }

  export type ClaimUpdateWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInput = {
    where: DefendantDetailsWhereUniqueInput
    update: XOR<DefendantDetailsUpdateWithoutDefendantInput, DefendantDetailsUncheckedUpdateWithoutDefendantInput>
    create: XOR<DefendantDetailsCreateWithoutDefendantInput, DefendantDetailsUncheckedCreateWithoutDefendantInput>
  }

  export type DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInput = {
    where: DefendantDetailsWhereUniqueInput
    data: XOR<DefendantDetailsUpdateWithoutDefendantInput, DefendantDetailsUncheckedUpdateWithoutDefendantInput>
  }

  export type DefendantDetailsUpdateManyWithWhereWithoutDefendantInput = {
    where: DefendantDetailsScalarWhereInput
    data: XOR<DefendantDetailsUpdateManyMutationInput, DefendantDetailsUncheckedUpdateManyWithoutDefendantInput>
  }

  export type DefendantDetailsScalarWhereInput = {
    AND?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
    OR?: DefendantDetailsScalarWhereInput[]
    NOT?: DefendantDetailsScalarWhereInput | DefendantDetailsScalarWhereInput[]
    id?: StringFilter<"DefendantDetails"> | string
    defendantRole?: EnumDefendantRoleFilter<"DefendantDetails"> | $Enums.DefendantRole
    defendantAccountId?: StringFilter<"DefendantDetails"> | string
    defendantInsuranceCarrierId?: StringNullableFilter<"DefendantDetails"> | string | null
    insurancePolicyNumber?: StringNullableFilter<"DefendantDetails"> | string | null
    driverLicenseNumber?: StringNullableFilter<"DefendantDetails"> | string | null
    driverLicenseState?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleMake?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleModel?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleYear?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleColor?: StringNullableFilter<"DefendantDetails"> | string | null
    vehiclePlate?: StringNullableFilter<"DefendantDetails"> | string | null
    vehiclePosition?: StringNullableFilter<"DefendantDetails"> | string | null
    vehicleRegisteredState?: StringNullableFilter<"DefendantDetails"> | string | null
    collisionType?: EnumCollisionTypeNullableFilter<"DefendantDetails"> | $Enums.CollisionType | null
    supervisorName?: StringNullableFilter<"DefendantDetails"> | string | null
    supervisorContact?: StringNullableFilter<"DefendantDetails"> | string | null
    client?: BoolFilter<"DefendantDetails"> | boolean
    groupId?: StringNullableFilter<"DefendantDetails"> | string | null
    sort?: IntFilter<"DefendantDetails"> | number
    defendantId?: StringFilter<"DefendantDetails"> | string
  }

  export type RoleCreateWithoutDefendantAccountInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutDefendantAccountInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutDefendantAccountInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutDefendantAccountInput, RoleUncheckedCreateWithoutDefendantAccountInput>
  }

  export type RoleCreateWithoutDefendantInsuranceCarrierInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutDefendantInsuranceCarrierInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutDefendantInsuranceCarrierInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutDefendantInsuranceCarrierInput, RoleUncheckedCreateWithoutDefendantInsuranceCarrierInput>
  }

  export type DefendantCreateWithoutDefendantDetailsInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutDefendantInput
  }

  export type DefendantUncheckedCreateWithoutDefendantDetailsInput = {
    id?: string
    claimId: string
  }

  export type DefendantCreateOrConnectWithoutDefendantDetailsInput = {
    where: DefendantWhereUniqueInput
    create: XOR<DefendantCreateWithoutDefendantDetailsInput, DefendantUncheckedCreateWithoutDefendantDetailsInput>
  }

  export type RoleUpsertWithoutDefendantAccountInput = {
    update: XOR<RoleUpdateWithoutDefendantAccountInput, RoleUncheckedUpdateWithoutDefendantAccountInput>
    create: XOR<RoleCreateWithoutDefendantAccountInput, RoleUncheckedCreateWithoutDefendantAccountInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutDefendantAccountInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutDefendantAccountInput, RoleUncheckedUpdateWithoutDefendantAccountInput>
  }

  export type RoleUpdateWithoutDefendantAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutDefendantAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUpsertWithoutDefendantInsuranceCarrierInput = {
    update: XOR<RoleUpdateWithoutDefendantInsuranceCarrierInput, RoleUncheckedUpdateWithoutDefendantInsuranceCarrierInput>
    create: XOR<RoleCreateWithoutDefendantInsuranceCarrierInput, RoleUncheckedCreateWithoutDefendantInsuranceCarrierInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutDefendantInsuranceCarrierInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutDefendantInsuranceCarrierInput, RoleUncheckedUpdateWithoutDefendantInsuranceCarrierInput>
  }

  export type RoleUpdateWithoutDefendantInsuranceCarrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutDefendantInsuranceCarrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type DefendantUpsertWithoutDefendantDetailsInput = {
    update: XOR<DefendantUpdateWithoutDefendantDetailsInput, DefendantUncheckedUpdateWithoutDefendantDetailsInput>
    create: XOR<DefendantCreateWithoutDefendantDetailsInput, DefendantUncheckedCreateWithoutDefendantDetailsInput>
    where?: DefendantWhereInput
  }

  export type DefendantUpdateToOneWithWhereWithoutDefendantDetailsInput = {
    where?: DefendantWhereInput
    data: XOR<DefendantUpdateWithoutDefendantDetailsInput, DefendantUncheckedUpdateWithoutDefendantDetailsInput>
  }

  export type DefendantUpdateWithoutDefendantDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutDefendantNestedInput
  }

  export type DefendantUncheckedUpdateWithoutDefendantDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimCreateWithoutTreatmentsAndInjuriesInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutTreatmentsAndInjuriesInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutTreatmentsAndInjuriesInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutTreatmentsAndInjuriesInput, ClaimUncheckedCreateWithoutTreatmentsAndInjuriesInput>
  }

  export type TreatmentCreateWithoutTreatmentsAndInjuriesInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    role?: RoleCreateNestedOneWithoutHospitalTreatmentsInput
    doctor?: RoleCreateNestedOneWithoutDoctorTreatmentsInput
    injuries?: InjuryCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateWithoutTreatmentsAndInjuriesInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    hospitalId?: string | null
    doctorId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    injuries?: InjuryUncheckedCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentCreateOrConnectWithoutTreatmentsAndInjuriesInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutTreatmentsAndInjuriesInput, TreatmentUncheckedCreateWithoutTreatmentsAndInjuriesInput>
  }

  export type ClaimUpsertWithoutTreatmentsAndInjuriesInput = {
    update: XOR<ClaimUpdateWithoutTreatmentsAndInjuriesInput, ClaimUncheckedUpdateWithoutTreatmentsAndInjuriesInput>
    create: XOR<ClaimCreateWithoutTreatmentsAndInjuriesInput, ClaimUncheckedCreateWithoutTreatmentsAndInjuriesInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutTreatmentsAndInjuriesInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutTreatmentsAndInjuriesInput, ClaimUncheckedUpdateWithoutTreatmentsAndInjuriesInput>
  }

  export type ClaimUpdateWithoutTreatmentsAndInjuriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutTreatmentsAndInjuriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type TreatmentUpsertWithoutTreatmentsAndInjuriesInput = {
    update: XOR<TreatmentUpdateWithoutTreatmentsAndInjuriesInput, TreatmentUncheckedUpdateWithoutTreatmentsAndInjuriesInput>
    create: XOR<TreatmentCreateWithoutTreatmentsAndInjuriesInput, TreatmentUncheckedCreateWithoutTreatmentsAndInjuriesInput>
    where?: TreatmentWhereInput
  }

  export type TreatmentUpdateToOneWithWhereWithoutTreatmentsAndInjuriesInput = {
    where?: TreatmentWhereInput
    data: XOR<TreatmentUpdateWithoutTreatmentsAndInjuriesInput, TreatmentUncheckedUpdateWithoutTreatmentsAndInjuriesInput>
  }

  export type TreatmentUpdateWithoutTreatmentsAndInjuriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneWithoutHospitalTreatmentsNestedInput
    doctor?: RoleUpdateOneWithoutDoctorTreatmentsNestedInput
    injuries?: InjuryUpdateManyWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutTreatmentsAndInjuriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: InjuryUncheckedUpdateManyWithoutTreatmentNestedInput
  }

  export type RoleCreateWithoutHospitalTreatmentsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutHospitalTreatmentsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutHospitalTreatmentsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutHospitalTreatmentsInput, RoleUncheckedCreateWithoutHospitalTreatmentsInput>
  }

  export type RoleCreateWithoutDoctorTreatmentsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutDoctorTreatmentsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutDoctorTreatmentsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutDoctorTreatmentsInput, RoleUncheckedCreateWithoutDoctorTreatmentsInput>
  }

  export type InjuryCreateWithoutTreatmentInput = {
    id?: string
    injuryLocation: $Enums.InjuryPoint
    injury: $Enums.InjuryType
    injuryLocationSide: $Enums.InjurySide
    other?: string | null
  }

  export type InjuryUncheckedCreateWithoutTreatmentInput = {
    id?: string
    injuryLocation: $Enums.InjuryPoint
    injury: $Enums.InjuryType
    injuryLocationSide: $Enums.InjurySide
    other?: string | null
  }

  export type InjuryCreateOrConnectWithoutTreatmentInput = {
    where: InjuryWhereUniqueInput
    create: XOR<InjuryCreateWithoutTreatmentInput, InjuryUncheckedCreateWithoutTreatmentInput>
  }

  export type InjuryCreateManyTreatmentInputEnvelope = {
    data: InjuryCreateManyTreatmentInput | InjuryCreateManyTreatmentInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentAndInjuryCreateWithoutTreatmentInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutTreatmentsAndInjuriesInput
  }

  export type TreatmentAndInjuryUncheckedCreateWithoutTreatmentInput = {
    id?: string
    claimId: string
  }

  export type TreatmentAndInjuryCreateOrConnectWithoutTreatmentInput = {
    where: TreatmentAndInjuryWhereUniqueInput
    create: XOR<TreatmentAndInjuryCreateWithoutTreatmentInput, TreatmentAndInjuryUncheckedCreateWithoutTreatmentInput>
  }

  export type RoleUpsertWithoutHospitalTreatmentsInput = {
    update: XOR<RoleUpdateWithoutHospitalTreatmentsInput, RoleUncheckedUpdateWithoutHospitalTreatmentsInput>
    create: XOR<RoleCreateWithoutHospitalTreatmentsInput, RoleUncheckedCreateWithoutHospitalTreatmentsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutHospitalTreatmentsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutHospitalTreatmentsInput, RoleUncheckedUpdateWithoutHospitalTreatmentsInput>
  }

  export type RoleUpdateWithoutHospitalTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutHospitalTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUpsertWithoutDoctorTreatmentsInput = {
    update: XOR<RoleUpdateWithoutDoctorTreatmentsInput, RoleUncheckedUpdateWithoutDoctorTreatmentsInput>
    create: XOR<RoleCreateWithoutDoctorTreatmentsInput, RoleUncheckedCreateWithoutDoctorTreatmentsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutDoctorTreatmentsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutDoctorTreatmentsInput, RoleUncheckedUpdateWithoutDoctorTreatmentsInput>
  }

  export type RoleUpdateWithoutDoctorTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutDoctorTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type InjuryUpsertWithWhereUniqueWithoutTreatmentInput = {
    where: InjuryWhereUniqueInput
    update: XOR<InjuryUpdateWithoutTreatmentInput, InjuryUncheckedUpdateWithoutTreatmentInput>
    create: XOR<InjuryCreateWithoutTreatmentInput, InjuryUncheckedCreateWithoutTreatmentInput>
  }

  export type InjuryUpdateWithWhereUniqueWithoutTreatmentInput = {
    where: InjuryWhereUniqueInput
    data: XOR<InjuryUpdateWithoutTreatmentInput, InjuryUncheckedUpdateWithoutTreatmentInput>
  }

  export type InjuryUpdateManyWithWhereWithoutTreatmentInput = {
    where: InjuryScalarWhereInput
    data: XOR<InjuryUpdateManyMutationInput, InjuryUncheckedUpdateManyWithoutTreatmentInput>
  }

  export type InjuryScalarWhereInput = {
    AND?: InjuryScalarWhereInput | InjuryScalarWhereInput[]
    OR?: InjuryScalarWhereInput[]
    NOT?: InjuryScalarWhereInput | InjuryScalarWhereInput[]
    id?: StringFilter<"Injury"> | string
    injuryLocation?: EnumInjuryPointFilter<"Injury"> | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFilter<"Injury"> | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFilter<"Injury"> | $Enums.InjurySide
    other?: StringNullableFilter<"Injury"> | string | null
    treatmentId?: StringFilter<"Injury"> | string
  }

  export type TreatmentAndInjuryUpsertWithoutTreatmentInput = {
    update: XOR<TreatmentAndInjuryUpdateWithoutTreatmentInput, TreatmentAndInjuryUncheckedUpdateWithoutTreatmentInput>
    create: XOR<TreatmentAndInjuryCreateWithoutTreatmentInput, TreatmentAndInjuryUncheckedCreateWithoutTreatmentInput>
    where?: TreatmentAndInjuryWhereInput
  }

  export type TreatmentAndInjuryUpdateToOneWithWhereWithoutTreatmentInput = {
    where?: TreatmentAndInjuryWhereInput
    data: XOR<TreatmentAndInjuryUpdateWithoutTreatmentInput, TreatmentAndInjuryUncheckedUpdateWithoutTreatmentInput>
  }

  export type TreatmentAndInjuryUpdateWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutTreatmentsAndInjuriesNestedInput
  }

  export type TreatmentAndInjuryUncheckedUpdateWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentCreateWithoutInjuriesInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    role?: RoleCreateNestedOneWithoutHospitalTreatmentsInput
    doctor?: RoleCreateNestedOneWithoutDoctorTreatmentsInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateWithoutInjuriesInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    hospitalId?: string | null
    doctorId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentCreateOrConnectWithoutInjuriesInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutInjuriesInput, TreatmentUncheckedCreateWithoutInjuriesInput>
  }

  export type TreatmentUpsertWithoutInjuriesInput = {
    update: XOR<TreatmentUpdateWithoutInjuriesInput, TreatmentUncheckedUpdateWithoutInjuriesInput>
    create: XOR<TreatmentCreateWithoutInjuriesInput, TreatmentUncheckedCreateWithoutInjuriesInput>
    where?: TreatmentWhereInput
  }

  export type TreatmentUpdateToOneWithWhereWithoutInjuriesInput = {
    where?: TreatmentWhereInput
    data: XOR<TreatmentUpdateWithoutInjuriesInput, TreatmentUncheckedUpdateWithoutInjuriesInput>
  }

  export type TreatmentUpdateWithoutInjuriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneWithoutHospitalTreatmentsNestedInput
    doctor?: RoleUpdateOneWithoutDoctorTreatmentsNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutInjuriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutTreatmentNestedInput
  }

  export type ClaimCreateWithoutMediaInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutMediaInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutMediaInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutMediaInput, ClaimUncheckedCreateWithoutMediaInput>
  }

  export type ClaimUpsertWithoutMediaInput = {
    update: XOR<ClaimUpdateWithoutMediaInput, ClaimUncheckedUpdateWithoutMediaInput>
    create: XOR<ClaimCreateWithoutMediaInput, ClaimUncheckedCreateWithoutMediaInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutMediaInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutMediaInput, ClaimUncheckedUpdateWithoutMediaInput>
  }

  export type ClaimUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type RoleCreateWithoutPoliceStationIncidentsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
  }

  export type RoleUncheckedCreateWithoutPoliceStationIncidentsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
  }

  export type RoleCreateOrConnectWithoutPoliceStationIncidentsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPoliceStationIncidentsInput, RoleUncheckedCreateWithoutPoliceStationIncidentsInput>
  }

  export type SubAccountCreateWithoutPoliceIncidentsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutSubAccountInput
    incidents?: IncidentCreateNestedManyWithoutAttorneyInput
  }

  export type SubAccountUncheckedCreateWithoutPoliceIncidentsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    accountId: string
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentUncheckedCreateNestedManyWithoutAttorneyInput
  }

  export type SubAccountCreateOrConnectWithoutPoliceIncidentsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutPoliceIncidentsInput, SubAccountUncheckedCreateWithoutPoliceIncidentsInput>
  }

  export type RoleCreateWithoutLawfirmIncidentsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutLawfirmIncidentsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutLawfirmIncidentsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutLawfirmIncidentsInput, RoleUncheckedCreateWithoutLawfirmIncidentsInput>
  }

  export type SubAccountCreateWithoutIncidentsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutSubAccountInput
    policeIncidents?: IncidentCreateNestedManyWithoutPoliceOfficerInput
  }

  export type SubAccountUncheckedCreateWithoutIncidentsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    accountId: string
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policeIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceOfficerInput
  }

  export type SubAccountCreateOrConnectWithoutIncidentsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutIncidentsInput, SubAccountUncheckedCreateWithoutIncidentsInput>
  }

  export type ClaimCreateWithoutIncidentInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutIncidentInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutIncidentInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutIncidentInput, ClaimUncheckedCreateWithoutIncidentInput>
  }

  export type RoleUpsertWithoutPoliceStationIncidentsInput = {
    update: XOR<RoleUpdateWithoutPoliceStationIncidentsInput, RoleUncheckedUpdateWithoutPoliceStationIncidentsInput>
    create: XOR<RoleCreateWithoutPoliceStationIncidentsInput, RoleUncheckedCreateWithoutPoliceStationIncidentsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPoliceStationIncidentsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPoliceStationIncidentsInput, RoleUncheckedUpdateWithoutPoliceStationIncidentsInput>
  }

  export type RoleUpdateWithoutPoliceStationIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
  }

  export type RoleUncheckedUpdateWithoutPoliceStationIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
  }

  export type SubAccountUpsertWithoutPoliceIncidentsInput = {
    update: XOR<SubAccountUpdateWithoutPoliceIncidentsInput, SubAccountUncheckedUpdateWithoutPoliceIncidentsInput>
    create: XOR<SubAccountCreateWithoutPoliceIncidentsInput, SubAccountUncheckedCreateWithoutPoliceIncidentsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutPoliceIncidentsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutPoliceIncidentsInput, SubAccountUncheckedUpdateWithoutPoliceIncidentsInput>
  }

  export type SubAccountUpdateWithoutPoliceIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSubAccountNestedInput
    incidents?: IncidentUpdateManyWithoutAttorneyNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutPoliceIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentUncheckedUpdateManyWithoutAttorneyNestedInput
  }

  export type RoleUpsertWithoutLawfirmIncidentsInput = {
    update: XOR<RoleUpdateWithoutLawfirmIncidentsInput, RoleUncheckedUpdateWithoutLawfirmIncidentsInput>
    create: XOR<RoleCreateWithoutLawfirmIncidentsInput, RoleUncheckedCreateWithoutLawfirmIncidentsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutLawfirmIncidentsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutLawfirmIncidentsInput, RoleUncheckedUpdateWithoutLawfirmIncidentsInput>
  }

  export type RoleUpdateWithoutLawfirmIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutLawfirmIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type SubAccountUpsertWithoutIncidentsInput = {
    update: XOR<SubAccountUpdateWithoutIncidentsInput, SubAccountUncheckedUpdateWithoutIncidentsInput>
    create: XOR<SubAccountCreateWithoutIncidentsInput, SubAccountUncheckedCreateWithoutIncidentsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutIncidentsInput, SubAccountUncheckedUpdateWithoutIncidentsInput>
  }

  export type SubAccountUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSubAccountNestedInput
    policeIncidents?: IncidentUpdateManyWithoutPoliceOfficerNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policeIncidents?: IncidentUncheckedUpdateManyWithoutPoliceOfficerNestedInput
  }

  export type ClaimUpsertWithoutIncidentInput = {
    update: XOR<ClaimUpdateWithoutIncidentInput, ClaimUncheckedUpdateWithoutIncidentInput>
    create: XOR<ClaimCreateWithoutIncidentInput, ClaimUncheckedCreateWithoutIncidentInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutIncidentInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutIncidentInput, ClaimUncheckedUpdateWithoutIncidentInput>
  }

  export type ClaimUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateWithoutWitnessInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutWitnessInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutWitnessInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutWitnessInput, ClaimUncheckedCreateWithoutWitnessInput>
  }

  export type WitnessDetailsCreateWithoutWitnessInput = {
    id?: string
    role: RoleCreateNestedOneWithoutWitnessDetailsInput
  }

  export type WitnessDetailsUncheckedCreateWithoutWitnessInput = {
    id?: string
    roleId: string
  }

  export type WitnessDetailsCreateOrConnectWithoutWitnessInput = {
    where: WitnessDetailsWhereUniqueInput
    create: XOR<WitnessDetailsCreateWithoutWitnessInput, WitnessDetailsUncheckedCreateWithoutWitnessInput>
  }

  export type WitnessDetailsCreateManyWitnessInputEnvelope = {
    data: WitnessDetailsCreateManyWitnessInput | WitnessDetailsCreateManyWitnessInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithoutWitnessInput = {
    update: XOR<ClaimUpdateWithoutWitnessInput, ClaimUncheckedUpdateWithoutWitnessInput>
    create: XOR<ClaimCreateWithoutWitnessInput, ClaimUncheckedCreateWithoutWitnessInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutWitnessInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutWitnessInput, ClaimUncheckedUpdateWithoutWitnessInput>
  }

  export type ClaimUpdateWithoutWitnessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutWitnessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type WitnessDetailsUpsertWithWhereUniqueWithoutWitnessInput = {
    where: WitnessDetailsWhereUniqueInput
    update: XOR<WitnessDetailsUpdateWithoutWitnessInput, WitnessDetailsUncheckedUpdateWithoutWitnessInput>
    create: XOR<WitnessDetailsCreateWithoutWitnessInput, WitnessDetailsUncheckedCreateWithoutWitnessInput>
  }

  export type WitnessDetailsUpdateWithWhereUniqueWithoutWitnessInput = {
    where: WitnessDetailsWhereUniqueInput
    data: XOR<WitnessDetailsUpdateWithoutWitnessInput, WitnessDetailsUncheckedUpdateWithoutWitnessInput>
  }

  export type WitnessDetailsUpdateManyWithWhereWithoutWitnessInput = {
    where: WitnessDetailsScalarWhereInput
    data: XOR<WitnessDetailsUpdateManyMutationInput, WitnessDetailsUncheckedUpdateManyWithoutWitnessInput>
  }

  export type WitnessDetailsScalarWhereInput = {
    AND?: WitnessDetailsScalarWhereInput | WitnessDetailsScalarWhereInput[]
    OR?: WitnessDetailsScalarWhereInput[]
    NOT?: WitnessDetailsScalarWhereInput | WitnessDetailsScalarWhereInput[]
    id?: StringFilter<"WitnessDetails"> | string
    witnessId?: StringFilter<"WitnessDetails"> | string
    roleId?: StringFilter<"WitnessDetails"> | string
  }

  export type WitnessCreateWithoutWitnessDetailsInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutWitnessInput
  }

  export type WitnessUncheckedCreateWithoutWitnessDetailsInput = {
    id?: string
    claimId: string
  }

  export type WitnessCreateOrConnectWithoutWitnessDetailsInput = {
    where: WitnessWhereUniqueInput
    create: XOR<WitnessCreateWithoutWitnessDetailsInput, WitnessUncheckedCreateWithoutWitnessDetailsInput>
  }

  export type RoleCreateWithoutWitnessDetailsInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutWitnessDetailsInput = {
    id?: string
    accountId?: string | null
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutWitnessDetailsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutWitnessDetailsInput, RoleUncheckedCreateWithoutWitnessDetailsInput>
  }

  export type WitnessUpsertWithoutWitnessDetailsInput = {
    update: XOR<WitnessUpdateWithoutWitnessDetailsInput, WitnessUncheckedUpdateWithoutWitnessDetailsInput>
    create: XOR<WitnessCreateWithoutWitnessDetailsInput, WitnessUncheckedCreateWithoutWitnessDetailsInput>
    where?: WitnessWhereInput
  }

  export type WitnessUpdateToOneWithWhereWithoutWitnessDetailsInput = {
    where?: WitnessWhereInput
    data: XOR<WitnessUpdateWithoutWitnessDetailsInput, WitnessUncheckedUpdateWithoutWitnessDetailsInput>
  }

  export type WitnessUpdateWithoutWitnessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneRequiredWithoutWitnessNestedInput
  }

  export type WitnessUncheckedUpdateWithoutWitnessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUpsertWithoutWitnessDetailsInput = {
    update: XOR<RoleUpdateWithoutWitnessDetailsInput, RoleUncheckedUpdateWithoutWitnessDetailsInput>
    create: XOR<RoleCreateWithoutWitnessDetailsInput, RoleUncheckedCreateWithoutWitnessDetailsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutWitnessDetailsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutWitnessDetailsInput, RoleUncheckedUpdateWithoutWitnessDetailsInput>
  }

  export type RoleUpdateWithoutWitnessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutWitnessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type AccountCreateWithoutRoleInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccount?: SubAccountCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutRoleInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccount?: SubAccountUncheckedCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutRoleInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutRoleInput, AccountUncheckedCreateWithoutRoleInput>
  }

  export type RoleTypeCreateWithoutRoleInput = {
    id?: string
    roleType: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
  }

  export type RoleTypeUncheckedCreateWithoutRoleInput = {
    id?: string
    roleType: string
    createdAt?: Date | string
    createdBy?: string | null
    enable?: boolean | null
  }

  export type RoleTypeCreateOrConnectWithoutRoleInput = {
    where: RoleTypeWhereUniqueInput
    create: XOR<RoleTypeCreateWithoutRoleInput, RoleTypeUncheckedCreateWithoutRoleInput>
  }

  export type ClaimCreateWithoutClientRoleInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutClientRoleInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutClientRoleInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClientRoleInput, ClaimUncheckedCreateWithoutClientRoleInput>
  }

  export type ClaimCreateManyClientRoleInputEnvelope = {
    data: ClaimCreateManyClientRoleInput | ClaimCreateManyClientRoleInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutInjuredPartyRoleInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    healthInsuranceProvider?: RoleCreateNestedOneWithoutHealthInsuranceClaimsInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutInjuredPartyRoleInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutInjuredPartyRoleInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutInjuredPartyRoleInput, ClaimUncheckedCreateWithoutInjuredPartyRoleInput>
  }

  export type ClaimCreateManyInjuredPartyRoleInputEnvelope = {
    data: ClaimCreateManyInjuredPartyRoleInput | ClaimCreateManyInjuredPartyRoleInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutHealthInsuranceProviderInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClaimsInput
    clientRole?: RoleCreateNestedOneWithoutClientClaimsInput
    injuredPartyRole?: RoleCreateNestedOneWithoutInjuredPartyClaimsInput
    incident?: IncidentCreateNestedOneWithoutClaimInput
    witness?: WitnessCreateNestedOneWithoutClaimInput
    defendant?: DefendantCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireCreateNestedOneWithoutClaimInput
    claimlist: ClaimListCreateNestedOneWithoutClaimInput
    envelop?: EnvelopCreateNestedManyWithoutClaimInput
    media?: AccidentMediaCreateNestedManyWithoutClaimInput
    tasks?: TaskCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutHealthInsuranceProviderInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    witness?: WitnessUncheckedCreateNestedOneWithoutClaimInput
    defendant?: DefendantUncheckedCreateNestedOneWithoutClaimInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutClaimInput
    questionnaire?: QuestionnaireUncheckedCreateNestedOneWithoutClaimInput
    envelop?: EnvelopUncheckedCreateNestedManyWithoutClaimInput
    media?: AccidentMediaUncheckedCreateNestedManyWithoutClaimInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClaimInput
    projectClaims?: ProjectClaimUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutHealthInsuranceProviderInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutHealthInsuranceProviderInput, ClaimUncheckedCreateWithoutHealthInsuranceProviderInput>
  }

  export type ClaimCreateManyHealthInsuranceProviderInputEnvelope = {
    data: ClaimCreateManyHealthInsuranceProviderInput | ClaimCreateManyHealthInsuranceProviderInput[]
    skipDuplicates?: boolean
  }

  export type WitnessDetailsCreateWithoutRoleInput = {
    id?: string
    witness: WitnessCreateNestedOneWithoutWitnessDetailsInput
  }

  export type WitnessDetailsUncheckedCreateWithoutRoleInput = {
    id?: string
    witnessId: string
  }

  export type WitnessDetailsCreateOrConnectWithoutRoleInput = {
    where: WitnessDetailsWhereUniqueInput
    create: XOR<WitnessDetailsCreateWithoutRoleInput, WitnessDetailsUncheckedCreateWithoutRoleInput>
  }

  export type DefendantDetailsCreateWithoutDefendantAccountInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantInsuranceCarrier?: RoleCreateNestedOneWithoutDefendantInsuranceCarrierInput
    defendant: DefendantCreateNestedOneWithoutDefendantDetailsInput
  }

  export type DefendantDetailsUncheckedCreateWithoutDefendantAccountInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantInsuranceCarrierId?: string | null
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantId: string
  }

  export type DefendantDetailsCreateOrConnectWithoutDefendantAccountInput = {
    where: DefendantDetailsWhereUniqueInput
    create: XOR<DefendantDetailsCreateWithoutDefendantAccountInput, DefendantDetailsUncheckedCreateWithoutDefendantAccountInput>
  }

  export type DefendantDetailsCreateManyDefendantAccountInputEnvelope = {
    data: DefendantDetailsCreateManyDefendantAccountInput | DefendantDetailsCreateManyDefendantAccountInput[]
    skipDuplicates?: boolean
  }

  export type DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantAccount: RoleCreateNestedOneWithoutDefendantAccountInput
    defendant: DefendantCreateNestedOneWithoutDefendantDetailsInput
  }

  export type DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantAccountId: string
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantId: string
  }

  export type DefendantDetailsCreateOrConnectWithoutDefendantInsuranceCarrierInput = {
    where: DefendantDetailsWhereUniqueInput
    create: XOR<DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput>
  }

  export type DefendantDetailsCreateManyDefendantInsuranceCarrierInputEnvelope = {
    data: DefendantDetailsCreateManyDefendantInsuranceCarrierInput | DefendantDetailsCreateManyDefendantInsuranceCarrierInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentCreateWithoutRoleInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    doctor?: RoleCreateNestedOneWithoutDoctorTreatmentsInput
    injuries?: InjuryCreateNestedManyWithoutTreatmentInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateWithoutRoleInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    doctorId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    injuries?: InjuryUncheckedCreateNestedManyWithoutTreatmentInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentCreateOrConnectWithoutRoleInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutRoleInput, TreatmentUncheckedCreateWithoutRoleInput>
  }

  export type TreatmentCreateManyRoleInputEnvelope = {
    data: TreatmentCreateManyRoleInput | TreatmentCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentCreateWithoutDoctorInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    role?: RoleCreateNestedOneWithoutHospitalTreatmentsInput
    injuries?: InjuryCreateNestedManyWithoutTreatmentInput
    treatmentsAndInjuries?: TreatmentAndInjuryCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateWithoutDoctorInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    hospitalId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
    injuries?: InjuryUncheckedCreateNestedManyWithoutTreatmentInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedCreateNestedOneWithoutTreatmentInput
  }

  export type TreatmentCreateOrConnectWithoutDoctorInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput>
  }

  export type TreatmentCreateManyDoctorInputEnvelope = {
    data: TreatmentCreateManyDoctorInput | TreatmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutLawfirmInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policeStation?: RoleCreateNestedOneWithoutPoliceStationIncidentsInput
    policeOfficer?: SubAccountCreateNestedOneWithoutPoliceIncidentsInput
    attorney?: SubAccountCreateNestedOneWithoutIncidentsInput
    Claim?: ClaimCreateNestedOneWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutLawfirmInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Claim?: ClaimUncheckedCreateNestedOneWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutLawfirmInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutLawfirmInput, IncidentUncheckedCreateWithoutLawfirmInput>
  }

  export type IncidentCreateManyLawfirmInputEnvelope = {
    data: IncidentCreateManyLawfirmInput | IncidentCreateManyLawfirmInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutPoliceStationInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policeOfficer?: SubAccountCreateNestedOneWithoutPoliceIncidentsInput
    lawfirm?: RoleCreateNestedOneWithoutLawfirmIncidentsInput
    attorney?: SubAccountCreateNestedOneWithoutIncidentsInput
    Claim?: ClaimCreateNestedOneWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutPoliceStationInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Claim?: ClaimUncheckedCreateNestedOneWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutPoliceStationInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutPoliceStationInput, IncidentUncheckedCreateWithoutPoliceStationInput>
  }

  export type IncidentCreateManyPoliceStationInputEnvelope = {
    data: IncidentCreateManyPoliceStationInput | IncidentCreateManyPoliceStationInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutRoleInput = {
    update: XOR<AccountUpdateWithoutRoleInput, AccountUncheckedUpdateWithoutRoleInput>
    create: XOR<AccountCreateWithoutRoleInput, AccountUncheckedCreateWithoutRoleInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutRoleInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutRoleInput, AccountUncheckedUpdateWithoutRoleInput>
  }

  export type AccountUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccount?: SubAccountUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccount?: SubAccountUncheckedUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type RoleTypeUpsertWithoutRoleInput = {
    update: XOR<RoleTypeUpdateWithoutRoleInput, RoleTypeUncheckedUpdateWithoutRoleInput>
    create: XOR<RoleTypeCreateWithoutRoleInput, RoleTypeUncheckedCreateWithoutRoleInput>
    where?: RoleTypeWhereInput
  }

  export type RoleTypeUpdateToOneWithWhereWithoutRoleInput = {
    where?: RoleTypeWhereInput
    data: XOR<RoleTypeUpdateWithoutRoleInput, RoleTypeUncheckedUpdateWithoutRoleInput>
  }

  export type RoleTypeUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RoleTypeUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ClaimUpsertWithWhereUniqueWithoutClientRoleInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutClientRoleInput, ClaimUncheckedUpdateWithoutClientRoleInput>
    create: XOR<ClaimCreateWithoutClientRoleInput, ClaimUncheckedCreateWithoutClientRoleInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutClientRoleInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutClientRoleInput, ClaimUncheckedUpdateWithoutClientRoleInput>
  }

  export type ClaimUpdateManyWithWhereWithoutClientRoleInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutClientRoleInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutInjuredPartyRoleInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutInjuredPartyRoleInput, ClaimUncheckedUpdateWithoutInjuredPartyRoleInput>
    create: XOR<ClaimCreateWithoutInjuredPartyRoleInput, ClaimUncheckedCreateWithoutInjuredPartyRoleInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutInjuredPartyRoleInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutInjuredPartyRoleInput, ClaimUncheckedUpdateWithoutInjuredPartyRoleInput>
  }

  export type ClaimUpdateManyWithWhereWithoutInjuredPartyRoleInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutInjuredPartyRoleInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutHealthInsuranceProviderInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutHealthInsuranceProviderInput, ClaimUncheckedUpdateWithoutHealthInsuranceProviderInput>
    create: XOR<ClaimCreateWithoutHealthInsuranceProviderInput, ClaimUncheckedCreateWithoutHealthInsuranceProviderInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutHealthInsuranceProviderInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutHealthInsuranceProviderInput, ClaimUncheckedUpdateWithoutHealthInsuranceProviderInput>
  }

  export type ClaimUpdateManyWithWhereWithoutHealthInsuranceProviderInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderInput>
  }

  export type WitnessDetailsUpsertWithoutRoleInput = {
    update: XOR<WitnessDetailsUpdateWithoutRoleInput, WitnessDetailsUncheckedUpdateWithoutRoleInput>
    create: XOR<WitnessDetailsCreateWithoutRoleInput, WitnessDetailsUncheckedCreateWithoutRoleInput>
    where?: WitnessDetailsWhereInput
  }

  export type WitnessDetailsUpdateToOneWithWhereWithoutRoleInput = {
    where?: WitnessDetailsWhereInput
    data: XOR<WitnessDetailsUpdateWithoutRoleInput, WitnessDetailsUncheckedUpdateWithoutRoleInput>
  }

  export type WitnessDetailsUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    witness?: WitnessUpdateOneRequiredWithoutWitnessDetailsNestedInput
  }

  export type WitnessDetailsUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    witnessId?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantDetailsUpsertWithWhereUniqueWithoutDefendantAccountInput = {
    where: DefendantDetailsWhereUniqueInput
    update: XOR<DefendantDetailsUpdateWithoutDefendantAccountInput, DefendantDetailsUncheckedUpdateWithoutDefendantAccountInput>
    create: XOR<DefendantDetailsCreateWithoutDefendantAccountInput, DefendantDetailsUncheckedCreateWithoutDefendantAccountInput>
  }

  export type DefendantDetailsUpdateWithWhereUniqueWithoutDefendantAccountInput = {
    where: DefendantDetailsWhereUniqueInput
    data: XOR<DefendantDetailsUpdateWithoutDefendantAccountInput, DefendantDetailsUncheckedUpdateWithoutDefendantAccountInput>
  }

  export type DefendantDetailsUpdateManyWithWhereWithoutDefendantAccountInput = {
    where: DefendantDetailsScalarWhereInput
    data: XOR<DefendantDetailsUpdateManyMutationInput, DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountInput>
  }

  export type DefendantDetailsUpsertWithWhereUniqueWithoutDefendantInsuranceCarrierInput = {
    where: DefendantDetailsWhereUniqueInput
    update: XOR<DefendantDetailsUpdateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedUpdateWithoutDefendantInsuranceCarrierInput>
    create: XOR<DefendantDetailsCreateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedCreateWithoutDefendantInsuranceCarrierInput>
  }

  export type DefendantDetailsUpdateWithWhereUniqueWithoutDefendantInsuranceCarrierInput = {
    where: DefendantDetailsWhereUniqueInput
    data: XOR<DefendantDetailsUpdateWithoutDefendantInsuranceCarrierInput, DefendantDetailsUncheckedUpdateWithoutDefendantInsuranceCarrierInput>
  }

  export type DefendantDetailsUpdateManyWithWhereWithoutDefendantInsuranceCarrierInput = {
    where: DefendantDetailsScalarWhereInput
    data: XOR<DefendantDetailsUpdateManyMutationInput, DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierInput>
  }

  export type TreatmentUpsertWithWhereUniqueWithoutRoleInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutRoleInput, TreatmentUncheckedUpdateWithoutRoleInput>
    create: XOR<TreatmentCreateWithoutRoleInput, TreatmentUncheckedCreateWithoutRoleInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutRoleInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutRoleInput, TreatmentUncheckedUpdateWithoutRoleInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutRoleInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutRoleInput>
  }

  export type TreatmentScalarWhereInput = {
    AND?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
    OR?: TreatmentScalarWhereInput[]
    NOT?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
    id?: StringFilter<"Treatment"> | string
    takenHospital?: BoolFilter<"Treatment"> | boolean
    isCurrentlyTreated?: BoolFilter<"Treatment"> | boolean
    hospitalId?: StringNullableFilter<"Treatment"> | string | null
    doctorId?: StringNullableFilter<"Treatment"> | string | null
    admission?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    discharge?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    lastVisit?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    otherInjuries?: StringNullableFilter<"Treatment"> | string | null
  }

  export type TreatmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutDoctorInput, TreatmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutDoctorInput, TreatmentUncheckedUpdateWithoutDoctorInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutDoctorInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type IncidentUpsertWithWhereUniqueWithoutLawfirmInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutLawfirmInput, IncidentUncheckedUpdateWithoutLawfirmInput>
    create: XOR<IncidentCreateWithoutLawfirmInput, IncidentUncheckedCreateWithoutLawfirmInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutLawfirmInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutLawfirmInput, IncidentUncheckedUpdateWithoutLawfirmInput>
  }

  export type IncidentUpdateManyWithWhereWithoutLawfirmInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutLawfirmInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    vehicleRole?: StringNullableFilter<"Incident"> | string | null
    vehicleCount?: IntNullableFilter<"Incident"> | number | null
    busOrVehicle?: EnumBusOrVehicleNullableFilter<"Incident"> | $Enums.BusOrVehicle | null
    transportType?: EnumTransportTypeNullableFilter<"Incident"> | $Enums.TransportType | null
    rideShareCompany?: StringNullableFilter<"Incident"> | string | null
    rideShareOtherName?: StringNullableFilter<"Incident"> | string | null
    propertyType?: EnumPropertyTypeNullableFilter<"Incident"> | $Enums.PropertyType | null
    datetime?: DateTimeFilter<"Incident"> | Date | string
    location?: StringNullableFilter<"Incident"> | string | null
    workRelated?: BoolFilter<"Incident"> | boolean
    description?: StringNullableFilter<"Incident"> | string | null
    policeReportCompleted?: BoolFilter<"Incident"> | boolean
    policeStationId?: StringNullableFilter<"Incident"> | string | null
    policeOfficerId?: StringNullableFilter<"Incident"> | string | null
    reportCompleted?: BoolFilter<"Incident"> | boolean
    reportNumber?: StringNullableFilter<"Incident"> | string | null
    supportingDocument?: BoolFilter<"Incident"> | boolean
    lostEarning?: StringFilter<"Incident"> | string
    amountLoss?: StringNullableFilter<"Incident"> | string | null
    timeLoss?: StringNullableFilter<"Incident"> | string | null
    witness?: BoolFilter<"Incident"> | boolean
    priorRepresentation?: BoolFilter<"Incident"> | boolean
    priorRepresentationReason?: StringNullableFilter<"Incident"> | string | null
    lawfirmId?: StringNullableFilter<"Incident"> | string | null
    attorneyId?: StringNullableFilter<"Incident"> | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutPoliceStationInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutPoliceStationInput, IncidentUncheckedUpdateWithoutPoliceStationInput>
    create: XOR<IncidentCreateWithoutPoliceStationInput, IncidentUncheckedCreateWithoutPoliceStationInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutPoliceStationInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutPoliceStationInput, IncidentUncheckedUpdateWithoutPoliceStationInput>
  }

  export type IncidentUpdateManyWithWhereWithoutPoliceStationInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutPoliceStationInput>
  }

  export type RoleCreateWithoutRoletypeInput = {
    id?: string
    account?: AccountCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutRoletypeInput = {
    id?: string
    accountId?: string | null
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutRoletypeInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRoletypeInput, RoleUncheckedCreateWithoutRoletypeInput>
  }

  export type RoleCreateManyRoletypeInputEnvelope = {
    data: RoleCreateManyRoletypeInput | RoleCreateManyRoletypeInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithWhereUniqueWithoutRoletypeInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutRoletypeInput, RoleUncheckedUpdateWithoutRoletypeInput>
    create: XOR<RoleCreateWithoutRoletypeInput, RoleUncheckedCreateWithoutRoletypeInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutRoletypeInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutRoletypeInput, RoleUncheckedUpdateWithoutRoletypeInput>
  }

  export type RoleUpdateManyWithWhereWithoutRoletypeInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRoletypeInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    accountId?: StringNullableFilter<"Role"> | string | null
    roletypeId?: StringFilter<"Role"> | string
  }

  export type RoleCreateWithoutAccountInput = {
    id?: string
    roletype: RoleTypeCreateNestedOneWithoutRoleInput
    clientClaims?: ClaimCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleUncheckedCreateWithoutAccountInput = {
    id?: string
    roletypeId: string
    clientClaims?: ClaimUncheckedCreateNestedManyWithoutClientRoleInput
    injuredPartyClaims?: ClaimUncheckedCreateNestedManyWithoutInjuredPartyRoleInput
    healthInsuranceClaims?: ClaimUncheckedCreateNestedManyWithoutHealthInsuranceProviderInput
    witnessDetails?: WitnessDetailsUncheckedCreateNestedOneWithoutRoleInput
    defendantAccount?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantAccountInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedCreateNestedManyWithoutDefendantInsuranceCarrierInput
    hospitalTreatments?: TreatmentUncheckedCreateNestedManyWithoutRoleInput
    doctorTreatments?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    lawfirmIncidents?: IncidentUncheckedCreateNestedManyWithoutLawfirmInput
    policeStationIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceStationInput
  }

  export type RoleCreateOrConnectWithoutAccountInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutAccountInput, RoleUncheckedCreateWithoutAccountInput>
  }

  export type RoleCreateManyAccountInputEnvelope = {
    data: RoleCreateManyAccountInput | RoleCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountCreateWithoutAccountInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentCreateNestedManyWithoutAttorneyInput
    policeIncidents?: IncidentCreateNestedManyWithoutPoliceOfficerInput
  }

  export type SubAccountUncheckedCreateWithoutAccountInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentUncheckedCreateNestedManyWithoutAttorneyInput
    policeIncidents?: IncidentUncheckedCreateNestedManyWithoutPoliceOfficerInput
  }

  export type SubAccountCreateOrConnectWithoutAccountInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutAccountInput, SubAccountUncheckedCreateWithoutAccountInput>
  }

  export type SubAccountCreateManyAccountInputEnvelope = {
    data: SubAccountCreateManyAccountInput | SubAccountCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ProjectAccountCreateWithoutAccountInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectAccountsInput
  }

  export type ProjectAccountUncheckedCreateWithoutAccountInput = {
    projectId: string
    assignedAt?: Date | string
  }

  export type ProjectAccountCreateOrConnectWithoutAccountInput = {
    where: ProjectAccountWhereUniqueInput
    create: XOR<ProjectAccountCreateWithoutAccountInput, ProjectAccountUncheckedCreateWithoutAccountInput>
  }

  export type ProjectAccountCreateManyAccountInputEnvelope = {
    data: ProjectAccountCreateManyAccountInput | ProjectAccountCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TaskAccountCreateWithoutAccountInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskAccountsInput
  }

  export type TaskAccountUncheckedCreateWithoutAccountInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskAccountCreateOrConnectWithoutAccountInput = {
    where: TaskAccountWhereUniqueInput
    create: XOR<TaskAccountCreateWithoutAccountInput, TaskAccountUncheckedCreateWithoutAccountInput>
  }

  export type TaskAccountCreateManyAccountInputEnvelope = {
    data: TaskAccountCreateManyAccountInput | TaskAccountCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithWhereUniqueWithoutAccountInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutAccountInput, RoleUncheckedUpdateWithoutAccountInput>
    create: XOR<RoleCreateWithoutAccountInput, RoleUncheckedCreateWithoutAccountInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutAccountInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutAccountInput, RoleUncheckedUpdateWithoutAccountInput>
  }

  export type RoleUpdateManyWithWhereWithoutAccountInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutAccountInput>
  }

  export type SubAccountUpsertWithWhereUniqueWithoutAccountInput = {
    where: SubAccountWhereUniqueInput
    update: XOR<SubAccountUpdateWithoutAccountInput, SubAccountUncheckedUpdateWithoutAccountInput>
    create: XOR<SubAccountCreateWithoutAccountInput, SubAccountUncheckedCreateWithoutAccountInput>
  }

  export type SubAccountUpdateWithWhereUniqueWithoutAccountInput = {
    where: SubAccountWhereUniqueInput
    data: XOR<SubAccountUpdateWithoutAccountInput, SubAccountUncheckedUpdateWithoutAccountInput>
  }

  export type SubAccountUpdateManyWithWhereWithoutAccountInput = {
    where: SubAccountScalarWhereInput
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type SubAccountScalarWhereInput = {
    AND?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    OR?: SubAccountScalarWhereInput[]
    NOT?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    firstName?: StringNullableFilter<"SubAccount"> | string | null
    lastName?: StringNullableFilter<"SubAccount"> | string | null
    phone?: StringNullableFilter<"SubAccount"> | string | null
    accountId?: StringFilter<"SubAccount"> | string
    enable?: BoolNullableFilter<"SubAccount"> | boolean | null
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
  }

  export type ProjectAccountUpsertWithWhereUniqueWithoutAccountInput = {
    where: ProjectAccountWhereUniqueInput
    update: XOR<ProjectAccountUpdateWithoutAccountInput, ProjectAccountUncheckedUpdateWithoutAccountInput>
    create: XOR<ProjectAccountCreateWithoutAccountInput, ProjectAccountUncheckedCreateWithoutAccountInput>
  }

  export type ProjectAccountUpdateWithWhereUniqueWithoutAccountInput = {
    where: ProjectAccountWhereUniqueInput
    data: XOR<ProjectAccountUpdateWithoutAccountInput, ProjectAccountUncheckedUpdateWithoutAccountInput>
  }

  export type ProjectAccountUpdateManyWithWhereWithoutAccountInput = {
    where: ProjectAccountScalarWhereInput
    data: XOR<ProjectAccountUpdateManyMutationInput, ProjectAccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type TaskAccountUpsertWithWhereUniqueWithoutAccountInput = {
    where: TaskAccountWhereUniqueInput
    update: XOR<TaskAccountUpdateWithoutAccountInput, TaskAccountUncheckedUpdateWithoutAccountInput>
    create: XOR<TaskAccountCreateWithoutAccountInput, TaskAccountUncheckedCreateWithoutAccountInput>
  }

  export type TaskAccountUpdateWithWhereUniqueWithoutAccountInput = {
    where: TaskAccountWhereUniqueInput
    data: XOR<TaskAccountUpdateWithoutAccountInput, TaskAccountUncheckedUpdateWithoutAccountInput>
  }

  export type TaskAccountUpdateManyWithWhereWithoutAccountInput = {
    where: TaskAccountScalarWhereInput
    data: XOR<TaskAccountUpdateManyMutationInput, TaskAccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountCreateWithoutSubAccountInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSubAccountInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    phone2?: string | null
    fax?: string | null
    mailingAddress?: string | null
    mailingAddressBuilding?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    billingAddressStreet?: string | null
    billingAddressBuilding?: string | null
    billingAddressCity?: string | null
    billingAddressState?: string | null
    billingAddressPostalCode?: string | null
    website?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role?: RoleUncheckedCreateNestedManyWithoutAccountInput
    projectAccounts?: ProjectAccountUncheckedCreateNestedManyWithoutAccountInput
    taskAccounts?: TaskAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSubAccountInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSubAccountInput, AccountUncheckedCreateWithoutSubAccountInput>
  }

  export type IncidentCreateWithoutAttorneyInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policeStation?: RoleCreateNestedOneWithoutPoliceStationIncidentsInput
    policeOfficer?: SubAccountCreateNestedOneWithoutPoliceIncidentsInput
    lawfirm?: RoleCreateNestedOneWithoutLawfirmIncidentsInput
    Claim?: ClaimCreateNestedOneWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutAttorneyInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Claim?: ClaimUncheckedCreateNestedOneWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutAttorneyInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutAttorneyInput, IncidentUncheckedCreateWithoutAttorneyInput>
  }

  export type IncidentCreateManyAttorneyInputEnvelope = {
    data: IncidentCreateManyAttorneyInput | IncidentCreateManyAttorneyInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutPoliceOfficerInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policeStation?: RoleCreateNestedOneWithoutPoliceStationIncidentsInput
    lawfirm?: RoleCreateNestedOneWithoutLawfirmIncidentsInput
    attorney?: SubAccountCreateNestedOneWithoutIncidentsInput
    Claim?: ClaimCreateNestedOneWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutPoliceOfficerInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Claim?: ClaimUncheckedCreateNestedOneWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutPoliceOfficerInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutPoliceOfficerInput, IncidentUncheckedCreateWithoutPoliceOfficerInput>
  }

  export type IncidentCreateManyPoliceOfficerInputEnvelope = {
    data: IncidentCreateManyPoliceOfficerInput | IncidentCreateManyPoliceOfficerInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutSubAccountInput = {
    update: XOR<AccountUpdateWithoutSubAccountInput, AccountUncheckedUpdateWithoutSubAccountInput>
    create: XOR<AccountCreateWithoutSubAccountInput, AccountUncheckedCreateWithoutSubAccountInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSubAccountInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSubAccountInput, AccountUncheckedUpdateWithoutSubAccountInput>
  }

  export type AccountUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressBuilding?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddressPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUncheckedUpdateManyWithoutAccountNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutAccountNestedInput
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type IncidentUpsertWithWhereUniqueWithoutAttorneyInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutAttorneyInput, IncidentUncheckedUpdateWithoutAttorneyInput>
    create: XOR<IncidentCreateWithoutAttorneyInput, IncidentUncheckedCreateWithoutAttorneyInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutAttorneyInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutAttorneyInput, IncidentUncheckedUpdateWithoutAttorneyInput>
  }

  export type IncidentUpdateManyWithWhereWithoutAttorneyInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutAttorneyInput>
  }

  export type IncidentUpsertWithWhereUniqueWithoutPoliceOfficerInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutPoliceOfficerInput, IncidentUncheckedUpdateWithoutPoliceOfficerInput>
    create: XOR<IncidentCreateWithoutPoliceOfficerInput, IncidentUncheckedCreateWithoutPoliceOfficerInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutPoliceOfficerInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutPoliceOfficerInput, IncidentUncheckedUpdateWithoutPoliceOfficerInput>
  }

  export type IncidentUpdateManyWithWhereWithoutPoliceOfficerInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutPoliceOfficerInput>
  }

  export type BoardCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectClaimCreateManyProjectInput = {
    claimId: string
    assignedAt?: Date | string
  }

  export type ProjectAccountCreateManyProjectInput = {
    accountId: string
    assignedAt?: Date | string
  }

  export type ProjectUserCreateManyProjectInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type BoardUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: ColumnUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: ColumnUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectClaimUpdateWithoutProjectInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneRequiredWithoutProjectClaimsNestedInput
  }

  export type ProjectClaimUncheckedUpdateWithoutProjectInput = {
    claimId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectClaimUncheckedUpdateManyWithoutProjectInput = {
    claimId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAccountUpdateWithoutProjectInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutProjectAccountsNestedInput
  }

  export type ProjectAccountUncheckedUpdateWithoutProjectInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAccountUncheckedUpdateManyWithoutProjectInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUpdateWithoutProjectInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectAssignmentsNestedInput
  }

  export type ProjectUserUncheckedUpdateWithoutProjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUncheckedUpdateManyWithoutProjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnCreateManyBoardInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColumnUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateManyWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyColumnInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    claimId?: string | null
  }

  export type TaskUpdateWithoutColumnInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutColumnInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutColumnInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAccountCreateManyTaskInput = {
    accountId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeCreateManyTaskInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type TaskCommentCreateManyTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type TaskAttachmentCreateManyTaskInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    uploadedById: string
  }

  export type TaskLabelCreateManyTaskInput = {
    labelId: string
    assignedAt?: Date | string
  }

  export type TaskAccountUpdateWithoutTaskInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTaskAccountsNestedInput
  }

  export type TaskAccountUncheckedUpdateWithoutTaskInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAccountUncheckedUpdateManyWithoutTaskInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUpdateWithoutTaskInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskAssignmentsNestedInput
  }

  export type TaskAssigneeUncheckedUpdateWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCommentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAttachmentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: UserUpdateOneRequiredWithoutTaskAttachmentsNestedInput
  }

  export type TaskAttachmentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type TaskLabelUpdateWithoutTaskInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: LabelUpdateOneRequiredWithoutTaskLabelsNestedInput
  }

  export type TaskLabelUncheckedUpdateWithoutTaskInput = {
    labelId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelUncheckedUpdateManyWithoutTaskInput = {
    labelId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelCreateManyLabelInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskLabelUpdateWithoutLabelInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutLabelsNestedInput
  }

  export type TaskLabelUncheckedUpdateWithoutLabelInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelUncheckedUpdateManyWithoutLabelInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateManyUserInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    claimId?: string | null
  }

  export type TaskAssigneeCreateManyUserInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type ProjectUserCreateManyUserInput = {
    projectId: string
    assignedAt?: Date | string
  }

  export type TaskCommentCreateManyUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
  }

  export type LabelCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    colour?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskAttachmentCreateManyUploadedByInput = {
    id?: string
    fileName: string
    originalName: string
    s3Key: string
    s3Bucket: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isPublic?: boolean
    etag?: string | null
    checksum?: string | null
    taskId: string
  }

  export type ClaimUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boards?: BoardUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutProjectNestedInput
    projectAccounts?: ProjectAccountUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    claim?: ClaimUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAssigneeUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskAssigneesNestedInput
  }

  export type TaskAssigneeUncheckedUpdateWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectUsersNestedInput
  }

  export type ProjectUserUncheckedUpdateWithoutUserInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUncheckedUpdateManyWithoutUserInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type LabelUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskLabels?: TaskLabelUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskLabels?: TaskLabelUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    colour?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TaskAttachmentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    etag?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type EnvelopCreateManyClaimInput = {
    id?: string
    status?: boolean
    submitterUrl?: string | null
    submitterId?: number | null
    submittedUrl?: string | null
    createdAt?: Date | string
  }

  export type AccidentMediaCreateManyClaimInput = {
    id?: string
    url: string
    type: string
    thumbnail?: string | null
  }

  export type TaskCreateManyClaimInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.TaskPriority
    dueDate?: Date | string | null
    status?: string
    position?: number
    archive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    columnId: string
    createdById: string
  }

  export type ProjectClaimCreateManyClaimInput = {
    projectId: string
    assignedAt?: Date | string
  }

  export type EnvelopUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    submitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: NullableIntFieldUpdateOperationsInput | number | null
    submittedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    submitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: NullableIntFieldUpdateOperationsInput | number | null
    submittedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopUncheckedUpdateManyWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    submitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submitterId?: NullableIntFieldUpdateOperationsInput | number | null
    submittedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccidentMediaUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccidentMediaUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccidentMediaUncheckedUpdateManyWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    taskAccounts?: TaskAccountUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    taskAccounts?: TaskAccountUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    archive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columnId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectClaimUpdateWithoutClaimInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectClaimsNestedInput
  }

  export type ProjectClaimUncheckedUpdateWithoutClaimInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectClaimUncheckedUpdateManyWithoutClaimInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateManyClaimlistInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyClaimlistInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountSync?: string | null
  }

  export type QuestionCreateManyClaimListInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    enable?: boolean
  }

  export type ClaimUpdateWithoutClaimlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClaimlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutClaimlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutClaimlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUpdateOneWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClaimlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutClaimlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionUpdateWithoutClaimListInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUpdateManyWithoutQuestionNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutClaimListInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutClaimListInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    enable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManySourceInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    injured: $Enums.WereYouInjured
    email: string
    phone: string
    password: string
    phone2?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    isUnder18?: boolean
    fatherFirstName?: string | null
    fatherLastName?: string | null
    motherFirstName?: string | null
    motherLastName?: string | null
    mailingAddress1?: string | null
    mailingAddress2?: string | null
    mailingCity?: string | null
    mailingState?: string | null
    mailingZipCode?: string | null
    isPOBoxOrDifferentAddress?: boolean | null
    physicalAddress1?: string | null
    physicalAddress2?: string | null
    physicalCity?: string | null
    physicalState?: string | null
    physicalZipCode?: string | null
    maritalStatus?: string | null
    spouseFirstName?: string | null
    spouseLastName?: string | null
    spousePhone?: string | null
    employmentStatus?: string | null
    employerName?: string | null
    employerTitle?: string | null
    employmentType?: string | null
    pay?: string | null
    schoolName?: string | null
    expectedGraduationYear?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    verificationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimlistId: string
    accountSync?: string | null
  }

  export type UserUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUpdateManyWithoutUserNestedInput
    verify?: VerifyUpdateOneWithoutUserNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutUserNestedInput
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    verify?: VerifyUncheckedUpdateOneWithoutUserNestedInput
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAssignments?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectAssignments?: ProjectUserUncheckedUpdateManyWithoutUserNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    labelsCreated?: LabelUncheckedUpdateManyWithoutCreatedByNestedInput
    taskAttachments?: TaskAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    injured?: EnumWereYouInjuredFieldUpdateOperationsInput | $Enums.WereYouInjured
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isUnder18?: BoolFieldUpdateOperationsInput | boolean
    fatherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    motherFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    motherLastName?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    mailingCity?: NullableStringFieldUpdateOperationsInput | string | null
    mailingState?: NullableStringFieldUpdateOperationsInput | string | null
    mailingZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isPOBoxOrDifferentAddress?: NullableBoolFieldUpdateOperationsInput | boolean | null
    physicalAddress1?: NullableStringFieldUpdateOperationsInput | string | null
    physicalAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCity?: NullableStringFieldUpdateOperationsInput | string | null
    physicalState?: NullableStringFieldUpdateOperationsInput | string | null
    physicalZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    spouseFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseLastName?: NullableStringFieldUpdateOperationsInput | string | null
    spousePhone?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    pay?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    expectedGraduationYear?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimlistId?: StringFieldUpdateOperationsInput | string
    accountSync?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionAnswerCreateManyQuestionnaireInput = {
    id?: string
    questionId: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerUpdateWithoutQuestionnaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutQuestionnaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutQuestionnaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateManyQuestionInput = {
    id?: string
    text: string
  }

  export type QuestionAnswerCreateManyQuestionInput = {
    id?: string
    questionnaireId?: string | null
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type ChoiceUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type ChoiceUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Questionnaire?: QuestionnaireUpdateOneWithoutQuestionNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefendantDetailsCreateManyDefendantInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantAccountId: string
    defendantInsuranceCarrierId?: string | null
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
  }

  export type DefendantDetailsUpdateWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantAccount?: RoleUpdateOneRequiredWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: RoleUpdateOneWithoutDefendantInsuranceCarrierNestedInput
  }

  export type DefendantDetailsUncheckedUpdateWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantAccountId?: StringFieldUpdateOperationsInput | string
    defendantInsuranceCarrierId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type DefendantDetailsUncheckedUpdateManyWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantAccountId?: StringFieldUpdateOperationsInput | string
    defendantInsuranceCarrierId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type InjuryCreateManyTreatmentInput = {
    id?: string
    injuryLocation: $Enums.InjuryPoint
    injury: $Enums.InjuryType
    injuryLocationSide: $Enums.InjurySide
    other?: string | null
  }

  export type InjuryUpdateWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    injuryLocation?: EnumInjuryPointFieldUpdateOperationsInput | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFieldUpdateOperationsInput | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFieldUpdateOperationsInput | $Enums.InjurySide
    other?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InjuryUncheckedUpdateWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    injuryLocation?: EnumInjuryPointFieldUpdateOperationsInput | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFieldUpdateOperationsInput | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFieldUpdateOperationsInput | $Enums.InjurySide
    other?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InjuryUncheckedUpdateManyWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    injuryLocation?: EnumInjuryPointFieldUpdateOperationsInput | $Enums.InjuryPoint
    injury?: EnumInjuryTypeFieldUpdateOperationsInput | $Enums.InjuryType
    injuryLocationSide?: EnumInjurySideFieldUpdateOperationsInput | $Enums.InjurySide
    other?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WitnessDetailsCreateManyWitnessInput = {
    id?: string
    roleId: string
  }

  export type WitnessDetailsUpdateWithoutWitnessInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutWitnessDetailsNestedInput
  }

  export type WitnessDetailsUncheckedUpdateWithoutWitnessInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type WitnessDetailsUncheckedUpdateManyWithoutWitnessInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimCreateManyClientRoleInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimCreateManyInjuredPartyRoleInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    incidentId?: string | null
    healthInsuranceProviderId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimCreateManyHealthInsuranceProviderInput = {
    id?: string
    status?: $Enums.ClaimStatus | null
    injured?: boolean | null
    relationship?: $Enums.Relationship | null
    otherRelationship?: string | null
    healthInsurance?: boolean | null
    healthInsuranceNumber?: string | null
    isOver65?: boolean | null
    receiveMedicare?: ClaimCreatereceiveMedicareInput | string[]
    assignedCaseManager?: string | null
    userId: string
    clientRoleId?: string | null
    injuredPartyRoleId?: string | null
    incidentId?: string | null
    claimlistId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefendantDetailsCreateManyDefendantAccountInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantInsuranceCarrierId?: string | null
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantId: string
  }

  export type DefendantDetailsCreateManyDefendantInsuranceCarrierInput = {
    id?: string
    defendantRole: $Enums.DefendantRole
    defendantAccountId: string
    insurancePolicyNumber?: string | null
    driverLicenseNumber?: string | null
    driverLicenseState?: string | null
    vehicleMake?: string | null
    vehicleModel?: string | null
    vehicleYear?: string | null
    vehicleColor?: string | null
    vehiclePlate?: string | null
    vehiclePosition?: string | null
    vehicleRegisteredState?: string | null
    collisionType?: $Enums.CollisionType | null
    supervisorName?: string | null
    supervisorContact?: string | null
    client?: boolean
    groupId?: string | null
    sort?: number
    defendantId: string
  }

  export type TreatmentCreateManyRoleInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    doctorId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
  }

  export type TreatmentCreateManyDoctorInput = {
    id?: string
    takenHospital: boolean
    isCurrentlyTreated: boolean
    hospitalId?: string | null
    admission?: Date | string | null
    discharge?: Date | string | null
    lastVisit?: Date | string | null
    otherInjuries?: string | null
  }

  export type IncidentCreateManyLawfirmInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyPoliceStationInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateWithoutClientRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClientRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutClientRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUpdateWithoutInjuredPartyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    healthInsuranceProvider?: RoleUpdateOneWithoutHealthInsuranceClaimsNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutInjuredPartyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutInjuredPartyRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsuranceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUpdateWithoutHealthInsuranceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
    clientRole?: RoleUpdateOneWithoutClientClaimsNestedInput
    injuredPartyRole?: RoleUpdateOneWithoutInjuredPartyClaimsNestedInput
    incident?: IncidentUpdateOneWithoutClaimNestedInput
    witness?: WitnessUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUpdateOneWithoutClaimNestedInput
    claimlist?: ClaimListUpdateOneRequiredWithoutClaimNestedInput
    envelop?: EnvelopUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUpdateManyWithoutClaimNestedInput
    tasks?: TaskUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutHealthInsuranceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    witness?: WitnessUncheckedUpdateOneWithoutClaimNestedInput
    defendant?: DefendantUncheckedUpdateOneWithoutClaimNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutClaimNestedInput
    questionnaire?: QuestionnaireUncheckedUpdateOneWithoutClaimNestedInput
    envelop?: EnvelopUncheckedUpdateManyWithoutClaimNestedInput
    media?: AccidentMediaUncheckedUpdateManyWithoutClaimNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClaimNestedInput
    projectClaims?: ProjectClaimUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus | null
    injured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relationship?: NullableEnumRelationshipFieldUpdateOperationsInput | $Enums.Relationship | null
    otherRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    healthInsurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    healthInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isOver65?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiveMedicare?: ClaimUpdatereceiveMedicareInput | string[]
    assignedCaseManager?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    clientRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    injuredPartyRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    claimlistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefendantDetailsUpdateWithoutDefendantAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantInsuranceCarrier?: RoleUpdateOneWithoutDefendantInsuranceCarrierNestedInput
    defendant?: DefendantUpdateOneRequiredWithoutDefendantDetailsNestedInput
  }

  export type DefendantDetailsUncheckedUpdateWithoutDefendantAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantInsuranceCarrierId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantId?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantInsuranceCarrierId?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantId?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantDetailsUpdateWithoutDefendantInsuranceCarrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantAccount?: RoleUpdateOneRequiredWithoutDefendantAccountNestedInput
    defendant?: DefendantUpdateOneRequiredWithoutDefendantDetailsNestedInput
  }

  export type DefendantDetailsUncheckedUpdateWithoutDefendantInsuranceCarrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantAccountId?: StringFieldUpdateOperationsInput | string
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantId?: StringFieldUpdateOperationsInput | string
  }

  export type DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    defendantRole?: EnumDefendantRoleFieldUpdateOperationsInput | $Enums.DefendantRole
    defendantAccountId?: StringFieldUpdateOperationsInput | string
    insurancePolicyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    driverLicenseState?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleMake?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleModel?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleYear?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleColor?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePlate?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclePosition?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleRegisteredState?: NullableStringFieldUpdateOperationsInput | string | null
    collisionType?: NullableEnumCollisionTypeFieldUpdateOperationsInput | $Enums.CollisionType | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorContact?: NullableStringFieldUpdateOperationsInput | string | null
    client?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    defendantId?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: RoleUpdateOneWithoutDoctorTreatmentsNestedInput
    injuries?: InjuryUpdateManyWithoutTreatmentNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: InjuryUncheckedUpdateManyWithoutTreatmentNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TreatmentUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneWithoutHospitalTreatmentsNestedInput
    injuries?: InjuryUpdateManyWithoutTreatmentNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUpdateOneWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: InjuryUncheckedUpdateManyWithoutTreatmentNestedInput
    treatmentsAndInjuries?: TreatmentAndInjuryUncheckedUpdateOneWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    takenHospital?: BoolFieldUpdateOperationsInput | boolean
    isCurrentlyTreated?: BoolFieldUpdateOperationsInput | boolean
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discharge?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otherInjuries?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentUpdateWithoutLawfirmInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policeStation?: RoleUpdateOneWithoutPoliceStationIncidentsNestedInput
    policeOfficer?: SubAccountUpdateOneWithoutPoliceIncidentsNestedInput
    attorney?: SubAccountUpdateOneWithoutIncidentsNestedInput
    Claim?: ClaimUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutLawfirmInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Claim?: ClaimUncheckedUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutLawfirmInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutPoliceStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policeOfficer?: SubAccountUpdateOneWithoutPoliceIncidentsNestedInput
    lawfirm?: RoleUpdateOneWithoutLawfirmIncidentsNestedInput
    attorney?: SubAccountUpdateOneWithoutIncidentsNestedInput
    Claim?: ClaimUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutPoliceStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Claim?: ClaimUncheckedUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutPoliceStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateManyRoletypeInput = {
    id?: string
    accountId?: string | null
  }

  export type RoleUpdateWithoutRoletypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutRoletypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutRoletypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateManyAccountInput = {
    id?: string
    roletypeId: string
  }

  export type SubAccountCreateManyAccountInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    enable?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectAccountCreateManyAccountInput = {
    projectId: string
    assignedAt?: Date | string
  }

  export type TaskAccountCreateManyAccountInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type RoleUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    roletype?: RoleTypeUpdateOneRequiredWithoutRoleNestedInput
    clientClaims?: ClaimUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    roletypeId?: StringFieldUpdateOperationsInput | string
    clientClaims?: ClaimUncheckedUpdateManyWithoutClientRoleNestedInput
    injuredPartyClaims?: ClaimUncheckedUpdateManyWithoutInjuredPartyRoleNestedInput
    healthInsuranceClaims?: ClaimUncheckedUpdateManyWithoutHealthInsuranceProviderNestedInput
    witnessDetails?: WitnessDetailsUncheckedUpdateOneWithoutRoleNestedInput
    defendantAccount?: DefendantDetailsUncheckedUpdateManyWithoutDefendantAccountNestedInput
    defendantInsuranceCarrier?: DefendantDetailsUncheckedUpdateManyWithoutDefendantInsuranceCarrierNestedInput
    hospitalTreatments?: TreatmentUncheckedUpdateManyWithoutRoleNestedInput
    doctorTreatments?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    lawfirmIncidents?: IncidentUncheckedUpdateManyWithoutLawfirmNestedInput
    policeStationIncidents?: IncidentUncheckedUpdateManyWithoutPoliceStationNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    roletypeId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentUpdateManyWithoutAttorneyNestedInput
    policeIncidents?: IncidentUpdateManyWithoutPoliceOfficerNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentUncheckedUpdateManyWithoutAttorneyNestedInput
    policeIncidents?: IncidentUncheckedUpdateManyWithoutPoliceOfficerNestedInput
  }

  export type SubAccountUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAccountUpdateWithoutAccountInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectAccountsNestedInput
  }

  export type ProjectAccountUncheckedUpdateWithoutAccountInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectAccountUncheckedUpdateManyWithoutAccountInput = {
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAccountUpdateWithoutAccountInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskAccountsNestedInput
  }

  export type TaskAccountUncheckedUpdateWithoutAccountInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAccountUncheckedUpdateManyWithoutAccountInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateManyAttorneyInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    policeOfficerId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyPoliceOfficerInput = {
    id?: string
    vehicleRole?: string | null
    vehicleCount?: number | null
    busOrVehicle?: $Enums.BusOrVehicle | null
    transportType?: $Enums.TransportType | null
    rideShareCompany?: string | null
    rideShareOtherName?: string | null
    propertyType?: $Enums.PropertyType | null
    datetime: Date | string
    location?: string | null
    workRelated: boolean
    description?: string | null
    policeReportCompleted: boolean
    policeStationId?: string | null
    reportCompleted: boolean
    reportNumber?: string | null
    supportingDocument: boolean
    lostEarning: string
    amountLoss?: string | null
    timeLoss?: string | null
    witness: boolean
    priorRepresentation: boolean
    priorRepresentationReason?: string | null
    lawfirmId?: string | null
    attorneyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateWithoutAttorneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policeStation?: RoleUpdateOneWithoutPoliceStationIncidentsNestedInput
    policeOfficer?: SubAccountUpdateOneWithoutPoliceIncidentsNestedInput
    lawfirm?: RoleUpdateOneWithoutLawfirmIncidentsNestedInput
    Claim?: ClaimUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutAttorneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Claim?: ClaimUncheckedUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutAttorneyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    policeOfficerId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutPoliceOfficerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policeStation?: RoleUpdateOneWithoutPoliceStationIncidentsNestedInput
    lawfirm?: RoleUpdateOneWithoutLawfirmIncidentsNestedInput
    attorney?: SubAccountUpdateOneWithoutIncidentsNestedInput
    Claim?: ClaimUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutPoliceOfficerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Claim?: ClaimUncheckedUpdateOneWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutPoliceOfficerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleRole?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleCount?: NullableIntFieldUpdateOperationsInput | number | null
    busOrVehicle?: NullableEnumBusOrVehicleFieldUpdateOperationsInput | $Enums.BusOrVehicle | null
    transportType?: NullableEnumTransportTypeFieldUpdateOperationsInput | $Enums.TransportType | null
    rideShareCompany?: NullableStringFieldUpdateOperationsInput | string | null
    rideShareOtherName?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workRelated?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    policeReportCompleted?: BoolFieldUpdateOperationsInput | boolean
    policeStationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportCompleted?: BoolFieldUpdateOperationsInput | boolean
    reportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocument?: BoolFieldUpdateOperationsInput | boolean
    lostEarning?: StringFieldUpdateOperationsInput | string
    amountLoss?: NullableStringFieldUpdateOperationsInput | string | null
    timeLoss?: NullableStringFieldUpdateOperationsInput | string | null
    witness?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentation?: BoolFieldUpdateOperationsInput | boolean
    priorRepresentationReason?: NullableStringFieldUpdateOperationsInput | string | null
    lawfirmId?: NullableStringFieldUpdateOperationsInput | string | null
    attorneyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BoardCountOutputTypeDefaultArgs instead
     */
    export type BoardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BoardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ColumnCountOutputTypeDefaultArgs instead
     */
    export type ColumnCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ColumnCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCountOutputTypeDefaultArgs instead
     */
    export type TaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabelCountOutputTypeDefaultArgs instead
     */
    export type LabelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimCountOutputTypeDefaultArgs instead
     */
    export type ClaimCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimListCountOutputTypeDefaultArgs instead
     */
    export type ClaimListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SourceCountOutputTypeDefaultArgs instead
     */
    export type SourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionnaireCountOutputTypeDefaultArgs instead
     */
    export type QuestionnaireCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionnaireCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionCountOutputTypeDefaultArgs instead
     */
    export type QuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefendantCountOutputTypeDefaultArgs instead
     */
    export type DefendantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefendantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreatmentCountOutputTypeDefaultArgs instead
     */
    export type TreatmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreatmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WitnessCountOutputTypeDefaultArgs instead
     */
    export type WitnessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WitnessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTypeCountOutputTypeDefaultArgs instead
     */
    export type RoleTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubAccountCountOutputTypeDefaultArgs instead
     */
    export type SubAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectUserDefaultArgs instead
     */
    export type ProjectUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectAccountDefaultArgs instead
     */
    export type ProjectAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BoardDefaultArgs instead
     */
    export type BoardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BoardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ColumnDefaultArgs instead
     */
    export type ColumnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ColumnDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskAccountDefaultArgs instead
     */
    export type TaskAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskAssigneeDefaultArgs instead
     */
    export type TaskAssigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskAssigneeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCommentDefaultArgs instead
     */
    export type TaskCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskAttachmentDefaultArgs instead
     */
    export type TaskAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskLabelDefaultArgs instead
     */
    export type TaskLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskLabelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabelDefaultArgs instead
     */
    export type LabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerifyDefaultArgs instead
     */
    export type VerifyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerifyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimDefaultArgs instead
     */
    export type ClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectClaimDefaultArgs instead
     */
    export type ProjectClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectClaimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnvelopDefaultArgs instead
     */
    export type EnvelopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnvelopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimListDefaultArgs instead
     */
    export type ClaimListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SourceDefaultArgs instead
     */
    export type SourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionnaireDefaultArgs instead
     */
    export type QuestionnaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionnaireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionAnswerDefaultArgs instead
     */
    export type QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionDefaultArgs instead
     */
    export type QuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceDefaultArgs instead
     */
    export type ChoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefendantDefaultArgs instead
     */
    export type DefendantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefendantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefendantDetailsDefaultArgs instead
     */
    export type DefendantDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefendantDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreatmentAndInjuryDefaultArgs instead
     */
    export type TreatmentAndInjuryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreatmentAndInjuryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreatmentDefaultArgs instead
     */
    export type TreatmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreatmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InjuryDefaultArgs instead
     */
    export type InjuryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InjuryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccidentMediaDefaultArgs instead
     */
    export type AccidentMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccidentMediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentDefaultArgs instead
     */
    export type IncidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WitnessDefaultArgs instead
     */
    export type WitnessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WitnessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WitnessDetailsDefaultArgs instead
     */
    export type WitnessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WitnessDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTypeDefaultArgs instead
     */
    export type RoleTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubAccountDefaultArgs instead
     */
    export type SubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarDefaultArgs instead
     */
    export type CarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}